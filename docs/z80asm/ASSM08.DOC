..PGNO89 
..HEAD01A-##- 
         Это  означает, что при циклическом сдвиге влево, как
показано выше, содержимое бита 0 перемещается в бит 1, бита 1
-  в бит 2 и т.д., а содержимое бита 7 перемещается и в бит 0
и  в  бит  переноса.  Сравните  это с командой RLA, описанной
выше, где бит 7 перемещается в бит переноса, а бит переноса -
в бит 0. 

                   ЦИКЛИЧЕСКИЕ СДВИГИ ВЛЕВО

         В  основном есть два типа циклических сдвигов влево:
Циклический  сдвиг  влево  регистров (циклический сдвиг влево
круговой  - "круговой" означает, что цикл охватывает только 8
битов,  как  в  команде  RLC, описанной выше) - это 9-битовый
сдвиг влево, аналогичный показанному выше для RL A. 

  RL  A        - "циклический сдвиг влево накопителя"; 
  RL  R        - "циклический сдвиг влево регистра R". 
  RLC A        - циклический сдвиг влево круговой регистра A
  RLC R        - циклический сдвиг влево круговой регистра R
  RLC (HL)     - циклический сдвиг влево круговой (HL)
  RLC (IX + Д) - циклический сдвиг влево круговой (IX + Д)
  RLC (IY + Д) - циклический сдвиг влево круговой (IY + Д)

         Помимо  этих  двух  команд циклического сдвига влево
есть  еще  команда  сдвига  влево,  но она может обрабатывать
только регистр A. 

                  SL A - сдвиг накопителя влево

         Отличие  этой  команды состоит в том, что содержимое
бита  переноса  теряется,  а  нулевой  бит заполняется нулем.
По-существу,  это  сводится  к  умножению  A  на 2, поскольку
ничего  в накопитель не переносится. Обдумайте работу команды
SL A в случае A =80H. 

                  ЦИКЛИЧЕСКИЕ СДВИГИ ВПРАВО

         Вновь у нас два основных режима циклического сдвига,
но  на  этот  раз  вправо.  Вращение вправо охватывает тот же
диапазон  допустимых  ячеек памяти и вращений, что и вращения
влево. 

 RR  A        - циклический сдвиг накопителя вправо
 RR  R        - циклический сдыиг регистра вправо
 RRC A        - циклический сдвиг вправо круговой регистра A
 RRC R        - циклический сдвиг вправо круговой регистра R
 RRC (HL)     - циклический сдвиг вправо круговой (HL)
 RRC (IX + Д) - циклический сдвиг вправо круговой (IX + Д)
 RRC (IY + Д) - циклический сдвиг вправо круговой (IY + Д)

         Имеется сдвиг вправо, аналогичный сдвигу влево. 

      SRL R - логический сдвиг вправо регистра R

         В  данном  случае,  это чистое деление на 2, если мы
используем  числа  без знака (т.е. диапазон чисел, которые мы
хотим представлять, составляет 0 - 255). 
         Поскольку   в   некоторых   прикладных   задачах  мы
применяем  соглашение  о  том,  что для задания отрицательных
чисел  бит  7 устанавливается равным 1 (что дает нам диапазон
от  -128  до  +127),  имеется  дополнительная  команда сдвига
вправо. 

      SRA R - арифметический сдвиг вправо регистра R

         Как  видите, это тоже деление на 2, но оно сохраняет
бит знака. 

                   В В О Д   И   В Ы В О Д

         Вопросы  ввода  и  вывода  - одни из самых простых в
программировании  на  машинноми  языке.  Возникают  ситуации,
когда  ЦП  необходимо  получить  информацию из внешнего мира,
например,   с  клавиатуры  или  кассетного  магнитофона.  Что
касаетя  ЦП,  то  для  него  это совершенно чуждый мир, и как
любой  добропорядрочный ЦП, он никогда из дома не отлучается.
Самое  большее,  что  он  может сделать - это открыть дверь и
получить доставленные вещи. ЦП не знает и не хочет знать, как
работает кассетный магнитофон. Все, что ему нужно знать - это
к  какой  двери  доставит свои товары посыльный от кассетного
магнитофона.  У  Z80  есть  выбор  до 256 дверей, но реальное
число,  доступное  конкретному  ЦП,  - это результат решений,
принятых    производителями    аппаратуры.    Что    касается
"Синклера",имеются  только клавиатура,печатающее устройство и
кассетный  магнитофон. Еще одно, о чем ЦП не хочет знать, это
как передаются данные. Все, что его касается, это то, что при
вводе  и  при выводе он получает 8-битовый байт. Клавиатура и
кассетный   магнитофон   расположены   за  дверью  номер  FEH
(десятичное  254),  так что для получения данных с клавиатуры
вы применяете команд 

                         IN  A,(FE) 

         Теперь  вы  можете задать себе вопрос, как 40 клавиш
на   клавиатуре  организованы  так,  что  они  представляются
8-битовыми байтами. 
         Ответ  для  вас  будет,  скорее всего, неожиданным -
клавиатура  за  один  раз  передает  информацию  только  от 5
клавиш.  Значание  регистра  A  определяет  в момент открытия
двери,  какая  группа  из  5  клавиш  будет  просматриваться.
Клавиатура  разделена  на  4 ряда, каждый из которых содержит
два блока по 5 клавиш. 

    3 =>   1   2   3   4   5     6   7   8   9   0   <= 4
    2 =>   Q   W   E   R   T     Y   U   I   O   P   <= 5
    1 =>   A   S   D   F   G     H   J   K   L  N/L  <= 6
    0 =>  SFT  Z   X   C   V     B   N   M   .  SPC

         Легко  видеть,  что  имеется  8  блоков  литер и мы,
поэтому,  можем  увязать  их  с 8 битами регистра A. Все биты
регистра   A   устанавливаются   в  положение  "включено"  за
исключением одного бита, задающего подлежащий чтению блок. Вы
можете  представлять это себе как секретный знак-рукопожатие.
Когда ЦП идет к двери за информацией, рукопожатие определяет,
какую часть информации он получит. 
         Чтобы прочитать клавиши из блока "1 2 3 4 5", должен
быть выключен бит 3 регистра A: 

                  A = 1 1 1 1  0 1 1 1 = F7

         Содержимое   посланной   с   клавиатуры  информамции
поступает в регистр A, в его младшие биты: 

               клавиша "1" -> бит 0 регистра A
               клавиша "2" -> бит 1 регистра A

         Вы   можете  считать,  что  информация  поступает  в
регистр  A сначала с внешних сторон клавиатуры, так что и "0"
и "1" попадут в бит 0 регистра A. 
         Для  некоторых  игр вам может понадобиться позволить
считывать  весь  верхний  ряд,  причем  весь его можно читать
одной  командой  (а не двумя, как потребовалось бы при чтении
одного  блока за раз). Для этого посыльного обманывают, чтобы
он выдал вам сразу две порции информации: 

                  A = 1 1 1 0   0 1 1 1 = E7

         Обратите внимание, что оба бита "3" и "4" выключены.
Такое рукопожатие говорит посыльному, что ЦП нужна информация
из  блоков  3  и  4,  и  именно ее он и получит. Конечно, две
порции  информации  оказываются  перемешанными, так что вы не
сможете  сказать,  была нажата клавиша "0" или "1", например,
обе установят бит 0 регистра A: 

             "1"  или  "0"  ->  бит 0 регистра A
             "2"  или  "9"  ->  бит 1 регистра A

         Это   полезно   для   динамических   игр,  поскольку
позволяет использовать клавиши "5" и "8" в качестве указателя
направления движения направо и налево, хотя они и находятся в
разных блоках клавиатуры. 
         Обратите внимание, что если вы применяете команду 

                          IN R,(C),

где  регистр  C задает используемую вами дверь, то содержимое
регистра  B  определяет,  какой  блок  клавиатуры выбирается.
Другие   двери,  представляющие  для  вас  интерес,  -  двери
ввода-вывода  с  кассетного  магнитофона.  Это  дверь FE, как
сказано   выше.   Основная  возникающая  проблема  связана  с
синхронизацией  ввода  и  вывода данных. Проблемы такого типа
требуют  большого  опыта программирования на машинном языке и
вычисления времени выполнения каждой команды. 
         Команда  OUT  также  применяется  для  генерирования
звукового   сигнала   на   "Спектрум"  и  установления  цвета
окаймления.     На     странице     руководства    "Спектрум"
рассматривается    команда    OUT   в   языке   "Бейсик",   а
программирование  команды  на машинном языке в точности такое
же.  Иными словами, биты 0, 1 и 2 определяют цвет окаймления,
бит  3 посылает импульс на гнезда MIC и EAR, а бит 4 посылает
импульс  на  внутренний громкоговоритель. Чтобы изменить цвет
окаймления,  нужно  загрузить  в  регистр  A  соответствующее
значение   цвета,  а  затем  выполнить  команду  OUT  (FE),A.
Обратите   внимание,   что  это  лишь  TEMPORARY  (временное)
изменение  цвета  окаймления.  Чтобы  постоянно изменить цвет
окаймления,  вы должны выполнить приведенную выше команду OUT
и   так   же   изменить   значение   ячейки   памяти   23624,
представляющую собой переменную BORDCR операционной системы. 
         Причина   этого   состоит   в  том,  что  аппаратура
"Спектрум" (чип ULA "Спектрум") управляет цветом окаймления и
она  получает  информацию о нем, просматривая содержимое этой
ячейки  памяти.  Вы можете предотвратить всю эту волынку ЦП с
цветом окаймления только заблокировав все прерывания (команда
DI).  Обратите  внимание,  что  некоторые  подпрограммы в ПЗУ
разблокируют прерывания (команда EI). 

         САМОСТОЯТЕЛЬНАЯ ГЕНЕРАЦИЯ ЗВУКОВОГО СИГНАЛА

         Вы  можете  сгенерировать  свой собственный звуковой
сигнал  на  "Спектрум",  но для пользователей, имеющих только
16К  памяти  с  произвольным  доступом  имеются  определенные
ограничения, порождаемые особенностями аппаратуры. 
         Поскольку  экран  постоянно  обновляется, аппаратура
регулярно  прерывает  выполнение  заданий Z80 для того, чтобы
показать,  что  находится  в  файле  дисплея. Это выполняется
путем   снижения   напряжения  в  схеме  WAIT.  В  результате
оказывается   невозможным   создание  какой  бы  то  ни  было
программы,  требующей  точной  или  регулярной синхронизации,
поскольку  невозможно  предсказать результаты синхронизации с
помощью  этих прерываний WAIT. Конструкция "Спектрум" такова,
что  прерывание  Z80  осуществляется  при  попытке  обработки
информации,  содержащейся  в первых 16К памяти с произвольным
доступом.  Такого  прерывания не происходит, если программа и
данные,  к которым осуществляется доступ Z80, находятся в ПЗУ
или верхних 32К памяти. 
         Обобщить все это в терминах, понятных непосвященным,
можно  следующим  образом:  вы  можете воспроизводить звуки и
шумы  с  помощью  команды  OUT на ЭВМ с 16К памяти, но это не
будут  чистые ноты. Обойти это можно с помощью программы BEEP
из  ПЗУ.(см.  главу  о  средствах  "Спектрум"). Для генерации
звука    вы    должны    послать    импульс   для   включения
громкоговорителя   (или/и  на  гнездо  MIC,  если  его  нужно
усиливать).  Затем, спустя некоторое время, вам нужно послать
другой   импульс   для  его  выключения.  Затем,  спустя  еще
некоторое время, вновь включить и т.д..... 
         Таким образом создается звук. Интервал времени между
двумя    последовательными    включениями    громкоговорителя
определяет   чистоту   звука,   продолжительность   интервала
времени,   в   течение   которого  громкоговоритель  остается
включенным,   в  противоположность  интервалу  времени  между
импульсами,  может  дать  вам  минимальную  степень  контроля
громкости звука. 
         Обратите  внимание,  что  вы  должны  применять  для
включения   и   выключения   такое  значение  A,  чтобы  цвет
окаймления   не   изменялся.  В  противном  случае  частотная
характеристика   полученного  звука  будет  напоминать  звуки
загрузки. 

                          УПРАЖНЕНИЕ

         Напишите  программу,  имитирующую звук сирены скорой
помощи  (частота  возрастает,  а  затем  снижается), Обратите
внимание,  что вы должны обеспечить звучание каждой частоты в
течение  некоторого  короткого  интервала времени, прежде чем
перейти к следующей частоте. 

     ПРЕДСТАВЛЕНИЕ ДВОИЧНО-КОДИРОВАННЫХ ДЕСЯТИЧНЫХ ЧИСЕЛ

         Двоично-кодированное   представление   по  английски
сокращается  как  BCD  (BINARY-CODED  DECIMAL).  Это  один из
способов представления информации в десятичной форме. 
         Чтобы   закодировать  каждую  из  цифр  от  0  до  9
необходимо  всего  4  бита. В каждом байте можно закодировать
две  цифры.  Это  называется  двоично-кодированным десятичным
представлением. 
         Например: 
 0000  0000 - двоично-кодированное десятичное пред- ставление
десятичного числа 00. 
 1001  1001 - двоично-кодированное десятичное пред- ставление
десятичного числа 99. 
         Каково   будет   двоично-кодированное  представление
чисел     58,10?    Будет    ли    1010    0000    допустимым
двоично-кодированным десятичным представлением числа? 

      АРИФМЕТИЧЕСКИЕ ДЕЙСТВИЯ НАД ДВОИЧНО-КОДИРОВАННЫМИ
                     ДЕСЯТИЧНЫМИ ЧИСЛАМИ

         Эта  странная  система обозначений для представления
чисел  может повести к потенциальным проблемам при сложении и
вычитании. Попробуем сложить следующие числа: 

                    BCD     08  0000 1000
                    BCD     03  0000 0011
                    ----------------------
                    BCD     11  0000 1011

         Вы заметите, что результат второй операции неверен и
является  недопустимым  в представлении двоично-кодированного
десятичного числа. Для компенсации этих трудностей необходимо
применять   особую   команду   DAA,   называемую  "десятичная
настройка арифметических действий", чтобы исправить результат
сложения (т.е. добавлять 6, если результат превышает 9). 
         Следующую  трудность  иллюстрирует  тот  же  пример.
Будет   генерироваться   бит  переноса  из  младшего  разряда
двоично-кодирован-  ного десятичного числа (самого первого) в
самый  левый.  Этот  внутренний  перенос  должен быть учтен и
добавлен во второй разряд двоично-кодированного десятичного. 
         Для   выявления  этого  переноса  используется  флаг
половинного переноса H. 

         LD A,12H      : LOAD LITERAL BCD "12"
        ADD A,24H      : ADD LITERAL BCD "24"
        DAA            : DECIMAL ADJUST RESULT
         LD (ADDR),A   : STORE RESULT

LOAD LITERAL - загрузить литерал;
ADD LITERAL - добавить литерал; 
DECIMAL ADJUST RESULT - десятичная настройка результата;
STORE RESULT - запоминание результата.

         При   программировании   вам   вряд  ли  потребуется
двоично-кодированное  десятичное  представление.  Но  неплохо
знать,  что чип Z80 все-таки поддерживает это представление и
команда  DAA  облегчает  жизнь небольшой группе пользователей
двоично-кодированного деся- тичного представления. 

                          ПРЕРЫВАНИЯ

         Прерывание  - это посылаемый микропроцессору сигнал,
который   может  появиться  в  любое  время  и  приостановить
выполнение  текущей  программы  (программа  даже не узнает об
этом). 
         Z80   предоставляет   три   механизма  осуществления
прерываний:  запрос  шины  (BUSRG),  немаскируемое прерывание
(NMI) и обычное прерывание (INT). 
         Команда  DI  (блокировка прерывания) применяется для
сброса   (маскирования),   а   команда   EI  (разблокирование
прерывания) - для установки (размаскирования). 
         В  общем  случае обычное прерывание приведет к тому,
что текущий счетчик команд будет помещен в стек, а управление
с помощью команды RST будет передано на нулевую страницу ПЗУ.
Для возвращения из прерывания требуется команда RETI (возврат
из прерывания). 
         При нормальном режиме работы у "Спектрум" прерывания
разблокированы (EI), и на самом деле программа прерывается 50
раз   в  секунду.  Это  прерывание  позволяет  программе  ПЗУ
осуществлять сканирование клавиатуры. 
         Вам  может  понадобиться  заблокировать прерывания в
вашей   программе,  поскольку  это  ускоряет  выполнение.  Вы
все-таки сможете получать информацию с клавиатуры при условии
использования   своей   собственной   программы   для  этого.
Обязательно   разблокируйте   прерывания,   когда   закончите
выполнение  программы,  поскольку  иначе  система  не  сможет
получать информацию с клавиатуры. 

                   КОМАНДА  РЕСТАРТА (RST)

         Это    скорее    всего    "рудименты"   чипа   8080,
реализованные  в  целях  совместимости.  Поэтому  вы  вряд ли
станете  применять команду RST в своей программе. Команда RST
выполняет  те  же  самые  действия, что и вызов, но позволяет
совершать  переход  только по восьми адресам, расположенным в
первых   256   ячейках  памяти:  00H,  08H,  10H,  18H,  20H,
28H,30H,38H. 
         Преимущество  команды  RST  состоит в том, что часто
используемые  подпрограммы  можно  вызвать, затрачивая на это
всего  один  байт.  Кроме  того,  команда RST занимает меньше
времени, чем команда CALL. 
         Недостатком  команды  RST  является то, что ее можно
применять  только для обращения к одной из восьми приведенных
выше допустимых ячеек. Поскольку все эти ячейки расположены в
ПЗУ,  вы  можете  воспользоваться  этим преимуществом в своей
собственной программе. Есть, однако, возможность использовать
подпрограммы  ПЗУ,  если  вы  знаете,  что  они делают и, тем
самым, использовать команды RST. 
         Вы  сможете  больше  узнать  о командах RST из нашей
книги "UNDERSTANDING YOUR SPECTRUM", написанной доктором Яном
Логаном. 

 Н А П И С А Н И Е  П Р О Г Р А М М  Д Л Я "С П Е К Т Р У M"

        ПЛАНИРОВАНИЕ ВАШЕЙ ПРОГРАММЫ НА МАШИННОМ ЯЗЫКЕ

         Программирование    на   машинном   языке   обладает
чрезвычайной гибкостью в том смысле, что позволяет вам делать
все, что угодно. 
         Поскольку  от  всех  языков  более высокого уровня в
конечном  счете  нужно переходить к машинному языку, все, что
вы  можете запрограммировать на языке "Фортран", или "Кобол",
или любом другом, можно запрограммировать на машинном языке. 
         Дополнительным преимуществом будет то, что программа
на машинном языке выполняется быстрее. 
         Эта  абсолютная  гибкость  может,  однако, оказаться
ловушкой  для  неосторожного  программиста. При наличии такой
полной  свободы  можно  делать  все, что угодно. В отличие от
операционной системы "Спектрум" для языка "Бейсик", например,
отсутствуют проверки предложений на допустимость. 
         Поскольку  любые вводимые вами числа будут командами
того  или  иного  типа,  чип  Z80  будет  обрабатывать все на
свете. 
         Но   даже   не   беря  в  расчет  проблемы  проверки
допустимости синтаксиса, нужно отметить, что программирование
на  машинном языке не накладывает ограничений на используемую
вами  логику.  Вы  можете выполнять функции, переходы и т.п.,
которые  будут  абсолютно  недопустимы  в  любом  языке более
высокого   уровня.   Поэтому  огромное  значение  приобретает
самодисциплина  при  разработке  программ  на машинном языке.
Невозможно   преувеличить  значение  концепции  "нисходящего"
подхода  в  программировании  в  целом,  но в особенности это
касается программирования на машинном языке. 
         "Нисходящий  подход  заставляет вас разбивать задачу
на  более  мелкие  единицы и позволяет проверить логику вашей
разработки,  на  протяжении  долгого  времени не записывая ни
одной строки текста программы. 
         Предположим,   вам   захотелось  написать  программу
посадки  на  луну.  Самый  первый путь мог бы напомнить нечто
подобное: 

         INSTR  выдача  на экран инструкций; переход назад на
                INSTR, пока не будет нажата кла- виша ENTER; 
         DRAW   нарисовать    ландшафт,    начать    движение
                спускаемого аппарата с вершины экрана; 
         LAND   движение спускаемого  аппарата  если  горючее
                кончилось,  перейти на CRASH перейти назад на
                LAND, если поверхность не до- стигнута; 
         GROUND напечатать  поздравления   перейти  назад  на
                INSTR для следующего прогона CRASH напечатать
                соболезнования  по  поводу  неудачной посадки
                перейти   назад   на   INSTR  для  следующего
                прогона. 
         Обратите  внимание, что вся эта "программа" написана
на  русском  языке.  На  этом  этапе  не  принималось никаких
решений, будет ли программа писаться на языке "Бейсик" или на
машинном языке. Такое решение и не нужно принимать. Концепция
программы  посадки  на  луну  не зависит от способа записи ее
текста. 
         Теперь наступает этап логической проверки. 
         Вы   выполняете   роль   ЭВМ   и  смотрите,  все  ли
возможности,  которые вы хотели включить в программу, имеются
в  наличии.  Нет  ли  переходов на объекты, которые вы хотели
написать, но забыли? Все ли есть? Нет ли избыточных программ?
Не следует ли некоторые объекты перенести в подпрограммы? 
         Давайте снова посмотрим на "программу" - ох-ох-ох! -
мы забыли как-нибудь закончить программу. 
         Описанная  выше  логика  может  быть  прекрасной для
некоторых прикладных задач, таких как игровая ЭВМ, но в своей
программе  вам  может  прийти  в голову, что неплохо бы иметь
возможность выключить работу программы. 
         Теперь   мы   изменим   последнюю   часть  программы
следующим образом: 

         GROUND напечатать  поздравления  перейти  назад  на
                INSTR для следующего прогона 
         CRASH  напечатать соболезнования по поводу неудачной
                посадки 
         FINISH спросить игрока, нужно ли закончить если нет,
                перейти на INSTR если да, STOP 

         Обратите  внимание,  что  мы  использовали метки для
описания  определенных  строк программы. Метки - очень ценный
аппарат,  особенно  если  вы  будете  выбирать  их краткими и
содержательными. 
         Когда  этот  уровень  закончен,  вы перемещаетесь на
уровень  глубже, чтобы проделать то же самое с одной из строк
или модулей, приведенных выше. 
         Именно поэтому этот подход называется нисходящим. 
         Например,   мы  можем  следующим  образом  расписать
модуль "FINISH", приведенный выше. 

         FINISH  -очистить экран
                 -напечатать:"хотите ли закончить?"
                 -опросить клавиатуру в ожидании ответа
                 -если ответ =ДА, то закончить
                 -перейти на INSTR

         Еще  одно преимущество нисходящего подхода состоит в
том,  что вы можете тестировать и выполнять конкретный модуль
автономно,так   что   он   будет   отлажен  для  включения  в
окончательный текст программы. 
         Давайте спустимся еще на один уровень и посмотрим на
строку "очистить экран" более подробно. 
         На  этом  этапе  нам  нужно решить,на каком языке мы
будем  писать  программу,  и  давайте  выберем  машинный язык
"Синклера". Если бы вы писали программу на языке "Бейсик", то
вам было бы достаточно написать: 

                           900 CLS,

но на машинном языке это простое предложение "очистить экран"
может оказаться обманчивым. 
         Поэтому мы могли бы сделать что-то в таком роде: 

     CLEAR  -найти начало экрана
            -заполнить следующие 6144 позиции пробелами 

         Мы  все еще не написали ни строчки текста программы,
но,  очевидно,  подход  основан  на  машинном  языке. Давайте
посмотрим  более  пристально, что должна делать эта программа
очистки экрана и что она делает на самом деле. 
         Вы  возможно  помните  из руководства по "Спектрум",
что  экран  состоит  из  6144 ячеек и что есть еще 768 ячеек,
описывающих атрибуты экрана: цвет бумаги, цвет чернил и т.п. 
         Приведенное   выше   краткое   описание   программы,
конечно,  очистит  часть экрана, но никак не повлияет на файл
атрибутов.  Если  не  у  всех  позиций  экрана совпадает цвет
бумаги  или  если  позиции  некоторых  литер имеют включенные
атрибуты  мигания  или  яркости,  то  ясная программа очистки
экрана, приведенная выше, окажется явно неадекватной. 
         Нам  придется  также  обработать  и  файл атрибутов.
Обратите  внимание  насколько  сложнее  оказываются некоторые
задачи на машинном языке, чем на языке "Бейсик". 
         Поэтому  нам  надо расширить программу до следующего
вида: 
         - найти начало экрана
         - заполнить следующие 6144 байта пробелами
         - найти начало файла атрибутов
         - заполнить     следующие   768   байтов  требуемыми
           значениями атрибутов бумаги (чернил,...) 
         Следующий  нижележащий  уровень  -  это  уже тот, на
котором  вы  должны, наконец, писать текст программы. Так что
давайте посмотрим, как экран заполняется пробелами. 

  CLEAR     LD HL,SCREEN     : SCREEN START
            LD BC,6144       : BYTES TO CLEAR
            LD D,0           : D = BLANK
  LOOP      LD (HL),D        : FILL BLANK
           INC HL            : NEXT POSITION
           DEC BC            : REDUCE COUNT
            LD A,B
            OR C             : TEST IF BC =0
            JR NZ,LOOP       : AGAIN IF NOT END

SCREEN  START  - начало экрана; 
BYTES TO CLEAR - очищаемые байты;
BLANK -пробел; 
FILL BLANK - заполнение пробелом; 
NEXT POSITION - следующая позиция; 
REDUCE COUNT - уменьшение счетчика; 
TEST -проверка; 
AGAIN IF NOT END - повторение, если не достигнут конец. 

         Теперь   вы   достаточно  легко  можете  работать  с
программами  такой  длины и таким способом строить достаточно
большие  программы. Кстати, вы теперь без сомнения понимаете,
почему программы на машинном языке часто так велики по объему
и почему люди изобрели программы на языках высокого уровня. 

                          УПРАЖНЕНИЯ

         Чтобы  написать  любую  конкретную  программу,  есть
всегда  больше  одного  способа,  так  что давайте рассмотрим
простую  программу очистки экрана, написанную выше. Для этого
есть несколько разных способов. 

                         УПРАЖНЕНИЕ 1

         Можете  ли  вы придумать способ, позволяющий в цикле
опробелить  6144 позиций без применения регистра BC, а только
с  помощью  регистра  B  так,  чтобы  мы  могли  пользоваться
командой DJNZ? 

                         УПРАЖНЕНИЕ 2

         Можете   ли   вы   придумать   способ,   позволяющий
опробелить  6144 позиций с помощью более мощной команды LDIR?
Тщательно  продумайте,  что  делает  команда  LDIR: не всегда
необходимо иметь где-то еще 6144 пробельных позиций. 

                            ОТВЕТЫ

         Есть   несколько  правильных  ответов.  Единственная
проверка  -  будет  ли это работать? Иными словами, делает ли
программа то, что вам нужно? С помощью DJNZ: 

         CLEAR     LD HL,SCREEN
                   LD A,0
                   LD B,24        : SET B=24
         BIGLOOP   PUSH BC        : SAVE VALUE
                   LD B,A         : SET B= 256
         LITLOOP   LD (HL),A
                   INC HL         : FILL IN 256 BLANKS
                   DJNZ LITLOOP
                   POP BC         : GET BACK VALUE OF B
                   DJNZ BIGLOOP   : DO IT UNTIL END

SET - установить; 
SAVE VALUE - запомнить значение; 
FILL  IN  256
BLANKS - заполнить 256 пробелов; 
GET BACK VALUE OF B - получить назад значение B; 
DO IT UNTIL END - выполнять до достижения конца. 

         Мы  смогли  использовать  24 раза по 256 (=6144) для
очистки экрана. Нужно отметить следующее: 
мы  можем задать B=0, чтобы пройти цикл DJNZ 256 раз. Почему?
Эта  процедура  обычно не будет применяться в программе, если
мы только не станем использовать регистр C для других целей. 

      Применение LDIR.
         CLEAR   LD HL,SCREEN     : SOURCE
                 PUSH HL
                 POP DE
                 INC DE           : DEST = HL + 1
                 LD BC,6144       : HOW MANY
                 LD (HL),0        : LAT POS = 0
                 LDIR             : MOVE IT

SOURCE - источник; 
HOW - сколько; 
LAT - первая;  
MOVE - перемещение

Обратите внимание, что мы получили DE = HL + 1, задавая DE=HL
и  давая  приращение  DE.  Это  можно сделать проще, загружая
значение  SCREEN  +  1  в  DE  непосредственно,  но для этого
требуется  на  один  байт  больше.  Причина,  по  которой эта
команда  LDIR  срабатывает,  состоит в том, что испиользуется
факт,  что  в  процессе  обработки  данные перезаписываются в
блок. Здесь происходит применение с положительным результатом
задачи, рассмотренной нами в главе о перемещении блоков. 
         Если  просуммировать потребную память, то при первом
методе  требуется  14  байтов,  при втором - 16 байтов, а при
последнем - 13 байтов. 

          С Р Е Д С Т В А   "Z X   С П Е К Т Р У М"

         Настало   время   рассмотреть  средства  вашего  "ZX
Спектрум",  полезные  при  разработке  для  него  программ на
машинном языке. 

                      ВВОД - КЛАВИАТУРА

         Что касается ввода информации в "Спектрум", мы будем
игнорировать ввод с кассетного магнитофона и сконцентрируемся
на клавиатуре. 
         Клавиатура   -   единственный  источник  информации,
предоставляющий  связь в реальном масштабе времени. Она может
динамически   влиять   на  выполнение  любой  программы,  как
операционной  системы в ПЗУ, так и пользовательской программы
в   памяти   с  произвольным  доступом.  Логически  мы  можем
рассматривать  клавиатуру  как  двухмерную  матрицу с восемью
рядами  и  пятью  столбцами, как в приложении А. Каждое из 40
пересечений  представляет  клавишу  клавиатуры.  В нормальном
состоянии   (когда  они  не  нажаты)  они  всегда  в  хорошем
настроении  ,  т.е. пересечение устанавливается равным 1. При
нажатии    конкретной    клавиши    "нажатое"    пересечение,
соответствующее   этой   клавише,  будет  сброшено  в  плохое
настроение,  т.е.  0.  Зная  связь  между  клавиатурой и этой
внутренней   матрицей   представления,   мы   можем   вывести
логический  способ  проверки  нажатия  клавиши, который можно
применять в программировании на машинном языке. 
         В  языке  "Бейсик"  при  сканировании клавиатуры нам
нужно  задать  адрес той конкретной половины ряда клавиатуры,
где  располагается  нужная  клавиша,  прежде чем использовать
функцию IN. 
         Аналогичным образом в программе на машинном языке мы
должны   загрузить  в  накопитель  значение,  соответствующее
адресу полуряда клавиш, который мы хотим проверить. Требуемое
значение  для  каждой  половины ряда приводится в самой левой
колонке таблицы в приложении А. 
         Например,  для "H - ENTER" (полуряда) мы загружаем в
регистр A значение 

                           LD A,BFH

затем  значение  A  будет  использоваться  для  поиска байта,
содержащего  состояние  той конкретной половины ряда клавиш и
возврата в A при задании команды INPUT. 
         Например, используется порт FEH 

                          IN A,(FEH)

         Поскольку  в  половине ряда имеются пять клавиш, нас
интересуют  только  пять младших битов байта, возвращаемого в
регистр  A.  Если в этой половине ряда никакие клавиши нажаты
не были, то значения пяти младших битов будут: 

(2^4 + 2^3 + 2^2 + 2^1 + 2^0 т.е. 16 + 8 + 4 + 2 + 1 = 31).

         Регистр A = XXX11111, когда нет нажатых клавиш. 
         Если  мы хотим проверить, нажат ли самый первый бит,
то  мы  проверяем,  сброшен ли он. Есть два способа проверить
это. 
   1.С помощью команды проверки бита, например, BIT 0,A. Если
бит сброшен (не установлен), то будет установлен флаг нуля. 
   2.С помощью команд логического И (AND 1). Если бит сброшен
(не установлен), то результат будет нулевым и флаг нуля будет
установлен. 
         Первый   способ  проще,  поскольку  конкретный  бит,
подлежащий   проверке,   указан   непосредственно  в  команде
проверки  бита.  Его  недостаток  в  том,  что если нам нужно
проверить  две  клавиши  в  этой  половине  ряда,нам придется
применять   две  команды  проверки  бита,  и,  возможно,  два
относительных перехода. 
         Например,  чтобы  проверить  биты  0  и  1 с помощью
первого способа 

        BIT 0,A         : TEST BIT 0 OF A SET OR NOT
         JR Z,NPRESS    : JUMP IF NOT PRESSED
        BIT 1,A         : TEST BIT 1 OF A SET OR NOT
         JR Z,NPRESS    : JUMP IF NOT PRESSED
                        .
               DO WHATEVER IF BOTH ARE PRESSED
                        .
                         NPRESS   . 

TEST  BIT 0 OF SET OR NOT - проверить, установлен или нет бит
0 регистра A; 
JUMP IF NOT PRESSED - переход, если не нажата;  
TEST
BIT  1  OF  SET  OR  NOT  - проверить, установлен или нет бит
регистра A;  
DO  WHATEVER  IF BOTH ARE PRESSED -выполнить то, что следует,
если обе клавиши нажаты. 

         Второй  способ  проверки  с  помощью  логического  И
требует  несколько  больше логических ухищрений. Для проверки
бита  0 мы используем AND 1, для проверки бита 1 - AND 2, для
проверки бита 2 - AND 4 и т.д. 
         Для проверки двух клавиш мы применяем AND X, где X -
сумма  значений, используемых для проверки каждой из клавиш в
отдельности.  Например,  чтобы  проверить,  что бит 0 и бит 1
регистра A установлены: 

  AND 1         : TEST BOTH BIT 0 AND BIT  1  IS SET     *
   CP 1         : TEST IF BOTH SET                      **
   JK NZ,NBOTH  : JUMP IF NOT BOTH PRESSED             ***

*     проверить, что оба бита установлены;
**    установлены ли;
***   переход, если не обе клавиши нажаты.

         Чтобы  проверить, что установлен один из битов 0 или
1 регистра A. 

   AND 3          : TEST EATHER BIT 0 AND BIT 1 IS SET    *
    JR Z,NOTONE   : JUMP IF NOT ONE IS PRESSED           **

*    проверить, что один из битов 0 или 1 установлен;
**  переход, если ни одна клавиша не нажата.

                          УПРАЖНЕНИЕ

         Чтобы   подвести   итог   всему,  что  мы  узнали  о
клавиатуре,  попробуйте  запрограммировать  на машинном языке
программу  для  вашего "Спектрума", выполняющую прерывание по
нажатию клавиши "ENTER". Вам понадобится: 
      а)  Проверить  адрес  ряда,  который  нужно загрузить в
регистр A; 
      б) Послать его на входной порт FEH; 
      в) проверить бит, устанавливаемый клавишей "ENTER". 

          ВЫВОД  -  ДИСПЛЕЙ С ТЕЛЕВИЗИОННЫМ ЭКРАНОМ

         Дисплей  с телевизионным экраном - основное средство
вывода для ЭВМ при общении с пользователем. 
         Приводимая   ниже   программа   на   машинном  языке
показывает план организации памяти экрана в "Спектрум". 

210040  LD HL,4000H   : LOAD HL WITH START OF DISPLAY FILE  *
36FF    LD (HL),FFH   : FILL THAT SCREEN LOCATION          **
110140  LD DE,4001H   : LOAD DE WITH BYTE IN DISPLAY      ***
010100  LD BC,1       : BC CONTAINS NUMBER OF BYTES TO BE
                      : TRANSFERRED                      ****
EDB0    LDIR          : MOVE A BLOCK LENGTH BC FROM (HL)
                      : TO (DE)                         *****
C9      RET           : END OF PROGRAM                 ******

*      загрузить в HL начало файла дисплея;
**     заполнить эту ячейку экрана;
***    загрузить в DE следующий байт дисплея;
****   в BC содержится число передаваемых байтов;
*****  переместить блок длиной BC из (HL) в (DE);
****** конец программы. 
