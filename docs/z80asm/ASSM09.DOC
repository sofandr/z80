..PGNO103 
..HEAD01A-##- 
         Загрузите   приведенную   выше   программу   в  свой
"Спектрум"  и  выполните  программу  на машинном языке. В том
виде,  как  она написана выше, из (HL) в (DE) будет перемещен
всего  один  байт.  Теперь  давайте изменим четвертую строчку
так:  LD  BC,31  (011F00).  Вас, возможно, удивит какие будут
высвечены  первые  32  байта  на  экране.  Обратите внимание,
вверху  экрана будет проведена очень тонкая полоса. Первые 32
байта  экранной  памяти  относятся к первому байту каждого из
первых 32 символов. 
         Теперь  изменим  эту строку так: LD BC,255 (01FF00).
Вновь,  возможно, вы удивитесь. Следующий байт после 32-го не
окажется во втором ряду точек на экране. Это - первый байт 32
символа. И так далее вплоть до 256-го символа. 
         Сможете  ли  вы  предсказать, куда попадет следующий
байт?   Измените  эту  строку  так:  LD  BC,2047  (01FF07)  и
выполните программу. Вы обнаружите, что заполненной оказалась
только верхняя треть экрана. 
         Вы  можете  поэкспериментировать  с  этим, пользуясь
разными  значениями  BC  вплоть до LD BC,6143 (01FF17). Таким
способом  вы  можете  посмотреть  как  "Спектрум"  организует
экран. Экранная память на самом деле разделена на три части. 

    1. Память с 4000H по 47FFH (===) первые восемь строк.
    2. Память с 4800H по 4FFFH (===) вторые восемь строк.
    3. Память с 5000H по 57FFH (===) третьи восемь строк.

         Но не только это. Вы еще вспомните, что в "Спектрум"
каждая   литера   состоит  из  восьми  8-битовых  байта,  что
составляет  64  точки. Например, для литеры "!" представление
имеет вид: 

                      0   00000000     0H
                     16   00010000    10H
                     16   00010000    10H
                     16   00010000    10H
                     16   00010000    10H
                      0   00000000     0H
                     16   00010000    10H
                      0   00000000     0H

         Структура  памяти  экрана дисплея "Спектрум" такова,
что  первые  256 байтов с 4000H по 40FFH соответствуют первым
байтам  каждой  из  256 8-байтовых литер первых восьми строк.
Далее  следующие  256  байтов  ячеек  памяти с 4100H по 42FFH
соответствуют  вторым  байтам  каждой  256  8-байтовых  литер
первых восьми строк и т.д. 
         Таким  образом, расположение в памяти восьми байтов,
соответствующих первой литере на экране, будет следкющим: 

                       1ST BYTE  4000H
                       2ND BYTE  4100H
                       3RD BYTE  4200H
                       4TH BYTE  4300H
                       5TH BYTE  4400H
                       6TH BYTE  4500H
                       7TH BYTE  4600H
                       8TH BYTE  4700H
                   1ST BYTE - первый байт.

         Странно,   не   так   ли?  Но  приходится  принимать
"Спектрум" таким, как его сконструировали. 
         Сможете    ли    вы    записать    восемь    байтов,
соответствующих  31-й литере третьей строки экрана? Вы можете
обратиться  к  приложению  B  (карта  памяти экрана). /405EH,
415EH, 425EH,......475EH/. 
         В  соответствии  с  принятым нами способом выдачи на
экран  ячеек  памяти,  соответствующие  первой  литере второй
группы из восьми строк, будут такими: 

    4800H, 4900H, 4A00H, 4B00H, 4C00H, 4D00H, 4E00H, 4F00H

         Аналогичным образом, первая литера третьей группы из
восьми   строк   отображается  восьмью  байтами  в  следующих
ячейках: 

   5000H, 5100H, 5200H, 5300H, 5400H, 5500H, 5600H, 5700H.

         В  применении  машинного  языка,  тем не менее, есть
определенные    преимущества.   Очевидные   трудности   стоит
преодолевать.  Вот тривиальный пример из языка "Бейсик". Если
вы  попытаетесь  выполнить  команду  PRINT  для вводной части
экрана  (нижние  две строки), то система "Бейсик" этому резко
воспротивится.  Но  на  машинном  языке  у вас имеется полный
доступ   ко   всему   экрану.   Если   вы  более  внимательно
присмотритесь  к  организации экрана дисплея, вы увидите, что
старший бит первого байта (H0BFB) каждой литеры определяет, к
какой из трех групп памяти литера относится. 
      Например:

Если  40H  = (H0BFB) 41H литера  находится в первой группе из
                         восьми строк 
Если  48H  = (H0BFB) 49H литера находится во второй группе из
                         восьми строк 
Если  50H  = (H0BFB) 51H литера находится в третьей группе из
                         восьми строк 

         Помимо  этого три младших бита HOB (HIGH ORDER BYTE)
старшего  байта  определяют, к какому из восьми байтов литеры
он принадлежит. 
         Ситуация     несколько    проясняется?    Посмотрите
приложение  B  и  постарайтесь  понять  связь  между ячейками
памяти и экраном дисплея (если она имеется?!!!). 
         Рассмотрим следующий пример. 
         Предположим,  нам  задан  адрес  4A36H. Старший байт
адреса будет 4AH, так что: 
      1.Мы  знаем,  что он находится в пределах памяти экрана
дисплея, поскольку его значение находится между 40H и 58H. 
      2.Его двоичное представление имеет вид 01001010. 
      3.По  младшим  трем  битам  мы знаем,что он принадлежит
третьему байту позиции литеры на экране. 
      4,Если  мы  сделаем  младшие  три бита равными нулю, то
значение HOB будет равно 48H. Таким образом, мы знаем, что он
при-  надлежит  второй  группе  из восьми строк, т.е. средней
порции экрана. 
         Мы   можем   прийти  к  выводу,  что  заданный  байт
относится  к  третьему  байту  литеры в средней порции памяти
дисплея. 
         Какой   литере   из   серединной  порции  этот  байт
принадлежит?  Для ответа на этот вопрос нам потребуется знать
значение  младшего  байта  адреса. Мы знаем, что младший байт
адреса  равен 36H. Так что адрес относится к литере 36H (48 +
6),  т.е.  к  54  позиции, считая от первой литеры серединной
позиции.  Поскольку  в  каждой  строке  32  литеры,  заданная
позиция  находится  во второй строке серединной порции экрана
дисплея и будет (54 - 32 + 1)-й литерой в этой строке. 
         Вывод,  который  мы  можем сделать, то, что заданный
байт  является  третьим  байтом  23-ей литеры 10-ой строки от
начала экрана. 

                          УПРАЖНЕНИЕ

         К какому байту какой литеры относится адрес 564FH? 
         Можете  ли вы написать короткую программу, выводящую
на   экран  восклицательный  знак?  Байты,  составляющие  эту
литеру, приведены выше. 

            ВЫВОД - АТРИБУТЫ ТЕЛЕВИЗИОННОГО ЭКРАНА

         Память,   предназначенная   для  хранения  атрибутов
экрана,    легче    для    понимания,    чем    сама   память
дисплея,поскольку   у   нее   имеется   взаимно   однозначное
соответствие  с литерами дисплея. Файл атрибутов расположен в
памяти   с  5800H  и  5AFFH.  Он  содержит  768  байтов,  что
соответствует  24 строкам по 32 литеры каждая. Иными словами,
имеется  по  одному  байту  -  атрибуту  для  каждой  позиции
литеры. 
         Так,   5800H  соответствует  атрибуту  певой  литеры
первой  строки,  5801H  -второй литеры, 5802 - третьей,.....,
581FH - 32-ой литере первой строки. 
         Мы  знаем,  что  для каждой позиции литеры на экране
имеется  соответствующий  байт-атрибут  в  памяти  атрибутов,
составленный следующим образом. 

          Байт-атрибут
          Биты 0 - 2   представляет цвет чернил от 0 до 7.
          Биты 3 - 5   представляет цвет бумаги от 0 до 7.
          Бит  6       повышенная яркость - 1, нормальная - 0
          Бит  7       мигание - 1, отсутствие мигания - 0

                          УПРАЖНЕНИЕ

         Каков адрес байта-атрибута, соответствующего первому
байту  серединной  части  экрана?  Каков  адрес первого байта
третьей   части?   Ответы  приведены  ниже,  но  постарайтесь
получить их сами. 
         Сможете  ли  вы написать подпрограмму, преобразующую
заданный   адрес  на  экране  в  адрес  соответствующего  ему
атрибута,  например, 4529H? По существу вам нужно определить,
какой   литере  экрана  соответствует  этот  адрес,  а  затем
прибавить это значение к 5800H. 
         Приводимая   ниже  программа  показывает  как  этого
достичь быстро. 

    LD  HL,4529H  : загрузить заданный адрес в HL
    LD  A,H       : загрузить старший байт в A
    AND 18H       : ловушка для  битов 3 и 4  для определения
                  : того, какой  части  экрана  соответствует
                  : адрес
    SRA A         : сдвиг накапливающего регистра вправо
    SRA A         : три раза, т.е. деление на 8. Результат
    SRA A         : может быть равен 0, 1 или 2 в зависимости
                  : от того, чему равнялся H:48H, 50H или 54H
    ADD A,58H     : преобразования в память атрибутов
    LD  H,A       : В HL - адрес атрибута, т.е. H = 58H, 59H
                  : или 60H. L остается неизменным!!!

         Вам, возможно, придется немного обдумать это. 
         Ответ на первое упражнение связан со способом работы
программы: 

1ST CHAR. OF 1ST SCREEN SECTION=4000H ATTRIBUTE ADDRESS=5800H
1ST CHAR. OF 2ND SCREEN SECTION=4800H ATTRIBUTE ADDRESS=5900H
1ST CHAR. OF 3RD SCREEN SECTION=5000H ATTRIBUTE ADDRESS=5A00

2ND CHAR. OF 1ST SCREEN SECTION=4801H ATTRIBUTE ADDRESS=5801H
                ETC....
                                ETC.....
1ST CHAR. OF 1ST SCREEN SECTION-1-я литера...-й части экрана
ATTRIBUTE ADDRESS - адрес атрибута

Это должно все прояснить. 

                   ВЫВОД - ЗВУКОВОЙ СИГНАЛ

         Еще одно средство связи в реальном масштабе времени,
предо-  ставляемое  вашей  микро-ЭВМ  "Спектрум"  -  звуковой
сигнал.  Было  бы  глупо  не воспользоваться этим средством в
полной мере. 
         В   машинном  языке  "Спектрум"  есть  два  основных
способа генерирования звука. 
      1. Посылка сигналов на выходной порт 254 для кассетного
магнитофона  в  течение  определенного  промежутка  времени с
помощью команды OUT 254. Например, OUT (254),A. 
      2.  Установить  определенные значения в HL,DE и вызвать
программу звукового сигнала из ПЗУ для генерации сигнала. 

      Входные параметры:
      DE - продолжительность в секундах * частота
      HL - (437 500 / частота) - 30,125
      потом
      CALL 0385H

         Преимуществом   первого   способа   генерации  звука
является  отсутствие  обращения  к  ПЗУ. Он выполняется очень
быстро, но... 
         Поскольку  ULA  постоянно  обращается  к  первым 16К
памяти  с  произвольным  доступом  для  выполнения  вывода на
экран, ваша программа, если она размещена в первых 16К, будет
часто подвергаться кратковременным прерываниям. 
         Если  программа  генерирует звуковой сигнал, то звук
будет  издаваться в виде непредсказуамых по продолжительности
гудков. Один из способов преодоления этой трудности состоит в
перемещении  той  части программы, которая генерирует звук, в
область  больших  значений  адресов  памяти, если у вас ЭВМ с
объемом памяти 48К. 
         Если  же  у  вас нет ЭВМ с объемом памяти 48К, то вы
все-таки  можете  генерировать  звук  этим методом, но это не
будет  "чистый  звук".  Вам  придется применять второй способ
генерации звука, чтобы добиться нужного результата. 
         Обратите  внимание, что при посылке значений на порт
вывода  254  они  будут  также  влиять  на  цвет окаймления и
включать  MIC,  а  также  громкоговоритель,  в зависимости от
посылаемого значения. 
         С другой стороны, программа из ПЗУ для генерирования
звука  по существу позволяет вам применять из своей программы
на машинном языке команду BEEP. Вы можете считать, что в паре
регистров  содержится  значение  продолжительности  звукового
сигнала,  а  в  HL  - значение частоты. Поэкспериментируйте с
различными  значениями  HL  и DE, пока не получите нужный вам
звук. 
         Ограниченность этого метода, конечно, состоит в том,
что  вы  не  можете  выйти  за пределы того диапазона звуков,
которые дает возможность издавать команда BEEP. 

      ВВЕДЕНИЕ В МОНИТОРНЫЕ ПРОГРАММЫ  НА МАШИННОМ ЯЗЫКЕ

                 МОНИТОРНАЯ ПРОГРАММА EZ CODE

         Это   мониторная   программа   на   машинном  языке,
позволяющая вам: 
      1.  Вводить  свой  программный  модуль,  написанный  на
машинном языке либо в полностью ассемблированном виде, либо в
полуассемблированном виде, когда все относительные переходы и
абсолютные переходы выражаются через номера строк. 
      2. Распечатывать исходный вводимый программный модуль. 
      3.   Делать   ДАМП   входного  программного  модуля  по
заданному адресу памяти. 
      4.   Просматривать   ячейки   памяти  из  определенного
диапазона. 
      5.   Запоминать   либо   исходный   модуль,  либо  ДАМП
программы, полностью переведенной на машинный язык. 
      6. Загружать записанную исходную программу с кассеты. 
      7. Выполнять ДАМП модуля программы на машинном языке. 

            Предварительные требования для кода EZ
           ---------------------------------------

         Прежде,  чем  применять эту мониторную программу для
ввода  каких-либо  программ  на  машинном  языке,  вы  должны
ассемблировать  свою  программу  на  языке ассемблера. Вам не
нужно вычислять относительные или абсолютные переходы. 
         Ваш  программный  модуль  не  должен  превышать  800
байтов или 200 команд. 
         Вы не должны загружать окончательный текст программы
по  адресам,  меньшим  31499 (чтобы не стереть программу кода
EZ). 

             Идейные основания программы кода EZ
             ------------------------------------

         Основная  идея  этой  программы состоит в том, чтобы
дать  возможность  вводить  команды  машинного  языка  в виде
нумерованных  строк, аналогично распечатке программы на языке
"Бейсик". 
         Каждая  строка  исходной  программы  (так называются
строки  текста  программы  на  машинноом языке) имеет номер и
содержит до 4 байтов текста. 
         Основное  преимущество  этого программного средства,
таким  образом,  состоит  в  возможности редактирования любой
строки.  Исходная программа может также отдельно записываться
на  ленту,  что  позволяет  запоминать  работу  на конкретных
этапах. 
         Основная  новизна  этой  программы  -  в возможности
вставки    относительных    и    абсолютных   переходов   без
необходимости  пересчета соответствующих чисел, любой переход
можно  сделать, просто сославшись на номер строки, на которую
вы  хотите перейти. Это означает, что изменения можно вносить
без труда даже в пределах диапазона относительного перехода. 
         Текст  исходной  программы  передается  в  память по
команде  ДАМП.  Получающийся  в результате текст программы на
машинном языке можно также записать в память. 

                    Сводка команд кода EZ
                    ---------------------

         Обратите внимание, что первый вопрос, задаваемый вам
программой:  "АДРЕС  ЗАГРУЗКИ".  Это  адрес,  по  которому вы
хотите  разместить  текст  программы на машинном языке. Он не
может быть меньше 31500. 

                          Ввод строк
                          ----------

         1.   для  ввода  строк  исходной  программы:  (номер
строки)     (пробел)(не     более     4     шестнадцатеричных
байтов)(ENTER). 
         Например: 
 1  210040  приведет  к вводу машинной команды LD HL,4000 H в
строку номер 1 
         2. Для редактирования строки: 
(номер   строки)(пробел)(заново  ввести  новые  байты)(ENTER)
         Например: 
1  210140  пприведет  к  замене  строки  номер  1 командой LD
HL,4001H 
         3.    Для    удаления    строки    команды:   (номер
строки)(ENTER) 
         Например: 
1 (ENTER) приведет к удалению строки номер 1. 
         4.   Для   задания  относительного  или  абсолютного
перехода:   (номер  строки)(пробел)(команда  перехода)("L"  в
нижнем регистре) (номер строки)(ENTER) 
         Например: 
1   C312   представляет  команду  JP  на  строку  2.   
2  1811  представляет команду JR на строку 1. 

                           Команды 
                           -------

         1. DUMP (ENTER)  
         *ДАМП   исходной  распечатки  в  память,  начиная  с
заданного адреса загрузки. 
         *   это   необходимо   проделать  перед  выполнением
программы на машинном языке. 
         Сокращение: DU 

         2. EXIT(ENTER) 
         *  выход  из  кода  EZ  и  повторный  вход в систему
"Бейсик". 
         Сокращение: EX 

         3. LIST(ENTER) 
         *  распечатка  первых  22  строк  команд  распечатки
исходного текста 
         *  нажмите любую клавишу, кроме "M" и "BREAK", чтобы
продолжить распечатку. 
         Сокращение: LI 

         LIST #(ENTER) 
         *  распечатка  22 строк распечатки исходного текста,
начиная со строки N#, где номер от 1 до 200 включительно. 
         Сокращение: без сокращения 

         4. LOAD(ENTER) 
         *  загрузить модуль с распечаткой исходного текста с
кассеты, заменив им существующий модуль. 
         Сокращение: LD 

         5. MEM(ENTER) 
         Подсказка: адрес начала: 
         *  введите адрес памяти, с которого вы хотите начать
выдачу 
         *  может быть от 0 до 32767 для "Спектрум" с объемом
памяти  16K или от 0 до 65535 для "Спектрум" с объемом памяти
48K 
         *  нажмите  "M",  чтобы  выйти  из  режима просмотра
памяти 
         Сокращение: ME 

         6. NEW(ENTER) 
         * удалить текущий модуль и заново стартовать код EZ 
         *  эта  команда  полезна для того, чтобы начать ввод
текста еще одного программного модуля 
         Сокращение: NE 

         7. RUN(ENTER) 
         *  выполнить  подвергнутый ДАМПу программный модуль,
начиная  с  адреса загрузки, заданного вами, когда стартовали
про-  грамму кода EZ или при загрузке новой распечатки исход-
ного текста 
         Сокращение: RU 

         8. SAVE(ENTER) 
         *  записать  на  кассету распечатку исходного текста
или ДАМП текста машинной программы 

         Подсказка: ввести имя: 
введите  имя,  которое вы хотите использовать, исходный текст
или  машинный  язык (S или M) введите S для записи распечатки
исходного  текста  введите  M  для  записи текста на машинном
языке   запустите   ленту,   потом   нажмите  любую  клавишу,
убедитесь,  что  кассета  правильно заправлена, нажмите любую
клавишу, когда кассета готова Сокращение: SA. 

                          Замечания
                          ---------

         1.   Если  вы  не  хотите,  чтобы  после  выполнения
программы  возвращался  результат  в  регистре  BC,  измените
строку 3090 следующим образом: 

             3090 IF K& = "RU"THEN LET L = USR R

         2. Для рестарта программы кода EZ: 
-  либо примените RUN, в результате чего все переменные будут
инициализированны; 
-  либо примените GO TO 2020, в результате чего выдается под-
сказка;"COMMAND OR LINE (###)"> 
         3.   Все   вводимые  числа,  за  исключением  текста
машинных команд, должны быть в десятичном формате. 
         4.  Чтобы вы могли вставлять дополнительные строки в
текущую  распечатку,  полезно  в распечатке пропускать номера
строк,  т.е.  вместо  того,  чтобы  вводить  строки  команд с
номерами  1, 2, 3 вводите 1, 5, 10 и т.д. Это придаст большую
гибкость вводимому модулю. 

                     Упражнение на код EZ
                     --------------------
         Введите следующий текст программы: 

          210040        LD HL,4000H         : FILL SCREEN
          110140        LD DE,4001H
          01FF17        LD BC,6143
          3EFF          LD A,0FFH
          77            LD (HL),A
          EDB0          LDIR
          3E7F    LOOP: LDF A,7FH           : TRAP BREAK KEY
          DBFE          IN A,(0FEH)
          E601          AND 1
          20F8          JR NZ,LOOP
          C9            RET

FILL SCREEN - заполнение экрана;  
TRAP BREAK KEY - прерывание по клавише. 
         Чтобы   ввести  приведенный  выше  текст  с  помощью
программы кода EZ: 

              (RUN)
              COMMAND OR LINE(###):  1 210040(ENTER)
              COMMAND OR LINE(###):  5 110140(ENTER)
              COMMAND OR LINE(###): 10 01FF17(ENTER)
              COMMAND OR LINE(###): 15   3EFF(ENTER)
              COMMAND OR LINE(###): 20     77(ENTER)
              COMMAND OR LINE(###): 25   EDB0(ENTER)
              COMMAND OR LINE(###): 30   3E7F(ENTER)
              COMMAND OR LINE(###): 35   DBFE(ENTER)
              COMMAND OR LINE(###): 40   E601(ENTER)
              COMMAND OR LINE(###): 45  20130(ENTER)

(Это будет 20, потом "L" в нижнем регистре, потом 30, т.е. JR
NZ,LINE 30) 

              COMMAND OR LINE(###): 50     C9(ENTER)
              COMMAND OR LINE(###):      LIST(ENTER)
              COMMAND OR LINE(###):      DUMP(ENTER)
              COMMAND OR LINE(###):       MEM(ENTER)
              STARTING ADDRESS: 31500(ENTER)
                              (THIS IS THE KEY TO EXIT THE
                               MEMORY DISPLAY MODE)
              COMMAND OR LINE(###): RUN(ENTER)
                                       (BREAK)

RUN - выполнить;  
LOADING ADDRESS - адрес загрузки;  
COMMAND OR LINE - команда или строка;  
STARTING ADDRESS - адрес начала;  
THIS IS THE KEY TO EXIT THE MEMORY DISPLAY MODE - это клавиша
для выхода из режима просмотра памяти. 

         Обратите  внимание,  что  после номеров строк должен
идти пробел. 

        EZCODE
        COPYRIGHT (C) 1982 BY WILLIAM TANG AND A.M.SULLIVAN

        100 REM MACHINE
        110 REM MACHINE CODE MONITOR
        120 GO TO 9000
        130 DEF FN D(S&) =(S&>"9"*(CODE S&-55)
               +(S&<="9")*(CODE S&-48)-(S& <> "@")*32
        140 DEF FN O(O&) = ((O& + "CA")+(O& + "DA")
               +(O& = "EA")+(O& = "FA")+(O& = "C2")
               +(O& = "D2")+(O& = "E2")+(O& = "F2")
               +(O& = "C3"))-((O& = "38")+(O& = "30)
               +O& = "28") +(O& = "20")+(O& = "18")
               +(O& = "10"))
       1000 REM
       1010 REM INV LINE-PRINTING-ROUTINE IRU
                ---                       ---
       1020 CLS : PRINT AT ZE,25;INVERSE ON;FLASH ON;"LISTING IRU
       1030 LET F = ZE : PRINT AT ZE, ZE
       1040 FOR J = PL1 TO PL2
       1050 IF C&(J,ON) = "--" THEN GO TO 1110
       1060 PRINT TAB TR- LEN STR& J; J; TAB FR; "-";
       1070 IF C&(J, TW, ON TO ON) ="1"
               THEN PRINT C&(J, ON)+"-"+C&(J, TW)+C&(J,TR)
            : GO TO 1090) 
       1080 PRINT C&(J,ON); "-"; C&(J,TW); "-"; C&(J, TR); "-";
                  C&(J,TR)
       1090 LET F = F+ON
       1100 IF F = 22 THEN GO TO 1120
       1110 NEXT J
       1120 PRINT AT ZE, 25; "-------"
       1130 RETURN
       2000 REM INV MAIN-ROUTINE IRU
                ---              ---
       2020 INPUT "COMMAND-OR-LINE(###) "-"; A&
       2030 IF A&(TO FR) = "----"THEN GO TO MR
       2040 IF A&(ON) > "9" THEN GO TO 3000
       2050 LET K& ="-"; FOR K = ON TO FR
       2060 IF A&(K TO K) = "-" THEN GO TO 2090
       2070 LET K& = K&+A&(K TO K)
       2080 NEXT K
       2090 IF K = 5 OR VAL K& = ZE OR VAL K& > IN THEN GO TO MR
       2100 LET J = VAL K&  : KLET N = J
            : REM LINE-NUMBER-MUST-BE-3-BYTES
       2110 LET A& = A&(K+ON TO)
       2120 LET K& = ""
       2130 FOR  K = ON TO LEN A&
       2140 IF A&(K TO K) <> "-" THEN LET K& = K&+A&(K TO K)
       2150 NEXT K
       2160 LET A& = K&
       2162 IF A&(ON) = "1" THEN GO TO MR
       2170 CLS : FOR I = ON TO 7 STEP TW
       2180 LET K = INT (I/TW+ON)
       2190 LET C&(J, K) =  A&(I TO I+ON)
       2200 NEXT I
       2210 IF C&(N, ON) = "--" THEN GO TO 2250
       2220 IF N < TP THEN LET TP = N
       2230 IF N > BP THEN LET BP = N
       2240 GO TO 2320
       2250 IF N <> BP THEN GO TO 2280
       2260 IF BP = ON OR C&(BP, ON) <> "--" THEN GO TO 2320
       2270 LET BP = BP-ON : GO TO 2260
       2280 IF N <> TP THEN GO TO 2320
       2290 IF C&(TP, ON) <> "--" THEN GO TO 2320
       2300 IF TP <> BP AND TP <> IN THEN LET TP = TP+ON
            : GO TO 2290
       2310 LET TP = ON
       2320 LET PP = N
       2330 IF N < TP THEN LET PP = TP : GO TO 2380
       2340 LET NUMLP = ZE
       2350 IF PP = TP OR NUMLP = 11 THEN GO TO 2380
       2360 IF C&(PP, ON) <> "--" THEN LET NUMLP = NUMLP+ON
       2370 LET PP = PP-ON : GO TO 2350
       2380 LET PL1 = PP : LET PL2 = BP
       2390 GO SUB 1000  * REM PRINT-A-BLOCK-OF-LINES
       2400 GO TO MR
       3000 REM
       3010 REM INV COMMANDS*************** IRU
                ---                         ---
       3020 LET K& = A&(TO TW)
       3030 IF K& = "DU" THEN GO TO 5000
       3040 IF K& = "EX" THEN STOP
       3050 IF K& = "LI" THEN GO TO 4000
       3060 IF K& = "LD" THEN GO TO 7000
       3070 IF K& = "ME" THEN GO TO 6000
       3080 IF K& = "NE" THEN RUN
       3090 IF K& = "RU" THEN PRINT USR R
       3100 IF K& = "SA" THEN GO TO 8000
       3110 GO TO MR
       4000 REM
       4010 REM INV LIST-ROUTINE*********** IRU
                ---                         ---
       4020 LET PL1 = TP : LET PL2 = BP
       4030 LET N1 = CODE A&(6 TO 6)
       4040 IF LEN A& > FR AND NL > 47 AND N1 < 58
            THEN LET PL1 = VAL A&(5 TO 8)
       4050 GO SUB 1000
       4060 GO TO MR
       5000 REM
       5010 REM INV DUMP-ROUTINE *********** IRU
                ---                          ---
       5020 CLS : PRINT AT ZE, 25; INK ON; INVERSE ON
               ; FLASH ON;  "DUMPING" : LET G = R
       5030 PRINT AT ON, ZE;
       5040 FOR J = TP TO BP
       5050 IF C&(J, ON) = "--" THEN GO TO 5470
       5060 IF C&(J, TW, ON TO ON) <> "1" THEN GO TO 5380
       5070 POKE G, ZE : POKE G+ON, ZE : POKE G+TW, ZE
            : POKE G+TR, ZE
       5080 LET JL = VAL (C&(J, TW, TW TO TW)+C&(J, TR))
       5090 PRINT TAB TR-LEN STR& J; INVERSE ON; J
            ; TAB FR; INVERSE ZE; "-"
            ; C&(J, ON)+"-"+C&(J, TW)+C&(J, TR)
            ; " = > ";
       5100 IF JL < ZE OR JL > LN THEN GO TO 5460
       5110 LET CJ = FN O(C&(J, ON))
       5120 PRINT TAB 17-LEN STR& JL; INVERSE ON; JL
            ; TAB 18; INVERSE ZE; "-"; C&(JL, ON)
            ; "-"; C&(JL, TW); "-"; C&(JL, TR); "-"
            ;C&(JL, FR);
       5130 IF ABC CJ <> ON THEN GO TO 5460
       5140 LET DD = (JL > J)-(JL < J)
       5150 LET JA = G :LET DP = ZE
       5170 LET CL = J+DD
       5180 LET NL = ZE : IF C&(CL,ON) = "--" THEN GO TO 5220
       5190 IF C&(CL, TW, ON TO ON <> "1"
               THEN LET NL = ON+(C&(CL, TW) <> "--")
                    +(C&(CL, TR) <> "--"0
                    +(C&(CL, FR) <> "--")
                    : GO TO 5220
       5200 LET TJ = FN O(C&(CL, ON))
       5210 LET N1 = (TJ = ON)*TR+(TJ = -ON)*TW
       5220 IF CL = JL AND DD > ZE THEN GO TO 5270
       5230 LET DP = DP+N1
       5240 IF CL = JL THEN GO TO 5270
       5250 LET CL = CL+DD
       5260 GO TO 5180
       5270 IF CJ = ON THEN LET JA = JA+_DD*DP+(DD > ZE)*TR
            :GO TO 5310 
       5280 IF DD > ZE THEN LET DP = DP+2
       5290 IF DP > 126 AND DD < ZE THEN GO TO 5460
       5300 IF DP > 129 AND DD > ZE THEN GO TO 5460
       5310 LET V = 16* FN D(C&(J, ON, ON TO ON))
            +FN D(C&(J, ON, TW TO TW))
       5320 POKE G, V : LET G = G+ON
       5330 IF CJ = ON THEN POKE G, JA-INT JA/QK)*QK
            : LET G = G+ON : POKE G, INT (JA/QK)
            : LET G = G+ON : GO TO 5360
       5340 IF DD < ZE THEN LET DP = -DP
       5350 LET DP = DP-TW : POKE G, DP : LET G = G+ON
       5360 PRINT "OK"
       5370 GO TO 5470
       5380 FOR I = ON TO 7 STEP TW
       5390 LET K = INT (I/TW+ON)
       5400 LET V = 16* FN D(C&(J, K, ON TO ON))
            +  FN D(C&(J, K, TW TO TW))
       5410 IF V < ZE THEN GO TO 5440
       5420 POKE G, V
       5430 LET G = G+ON
       5440 NEXT I
       5450 GO TO 5470
       5460 PRINT "**"
       5470 NEXT J
       5480 PRINT AT ZE, 25; "--------"
            : GO TO MR
       6000 REM
       6010 REM INV MEMORY-DISPLAY********* IRU
                ---                         ---
       6020 INPUT " STARTING ADDRESS :-A:; DM
       6030 CLS : PRINT AT ZE, ZE;
       6040 LET G = DM : LET F = ZE
       6050 LET F = F+ON
            : PRINT TAB 5-LEN STR& G; G; TAB 6;
       6060 FOR I = ON TO FR
       6070 LET V = PEEK G
       6080 LET H = INT (V/16)
       6090 LET L = V-16*H
       6100 PRINT D&(H+ON) ; D&(L+ON); "-";
       6110 LET G = G+ON
       6120 NEXT I
       6130 PRINT "-"
       6140 IF F <> 22 THEN GO TO 6050
       6150 LET K& = INKEY& : IF K& ="" THEN GO TO 6150
       6160 IF K& <> "M" AND K& <> "M" THEN LET F = ZE
            : POKE 23692, QK-ON : GO TO 6050
       6200 POKE 23692, ON : PAUSE 20 : GO TO MR
       7000 REM
       7010 REM INV LOAD ****************** IRU
                ---                         ---
       7020 CLS
       7030 INPUT
            "LOAD-ARRAY : PRESS-ANY-KEY-WHEN---READY.-"
            ; K&
       7040 PRINT AT ZE, 25; INVERSE ON; FLASH ON; "LOADING"
       7050 LOAD "SOURSE" DATA C&()
       7060 FOR I = ON TO ON
       7070 LET TP = I
       7080 IF C&(I, ON) <> "--"~ THEN GO TO 7100
       7090 NEXT I
       7100 FOR I = 1N TO ON STEP -1
       7110 LET BP = I
       7120 IF C&(I, ON) <> "--" THEN GO TO 7140
       7130 NEXT I
       7140 PRINT AT ZE, 25; "-------:
       7150 GO TO 9150
       8000 REM
       8010 REM INV SAVE****************** IRU
                ---                        ---
       8020 INPUT "ENTER-NAME :-"; N&
       8030 IF N& = "" THEN GO TO 8020
       8040 INPUT
               "SOURCE-OR-MACHINE-CODE :-(S-OR-M)"
               : K&
       8050 IF K& <> "S" AND K& <> "M" THEN GO TO 8040
       8060 IF K& = "S" THEN SAVE N& DATA C&() : GO TO MR
       8070 INPUT "STARTING-ADDRESS : -"; SS
       8080 INPUT "FINISHING-ADDRESS : -"; SF
       8090 LEN SB = SF-SS+ON
       8100 SAVE N& CODE SS, SB
       8110 GO TO MR
       9000 REM
       9010 REV INITIALISATION
       9020 LET ZE = PI - PI : LET ON = PI / PI
            : LET TW = ON+ON : LET TR = ON+TW
            : LET FR = TW+TW : LET QK = 2556
            : LET MR = 2020 : LET 1N = 200
       9025 BORDER 7 : PAPER 7 : INK ON : INVERSE ZE
            : OVER ZE : FLASH ZE : BRIGHT ZE
            : BEEP .25, 24 : BEEP .25, 12
       9030 DIM A&(15) : DIM O&(TW)
       9040 LET TP = LN : LET BP = ON : REM LINE-NUMBER-BUFFER
       9050 DIM C&(LN, FR, TW) : REM HOLDS-CODE
       9060 PRINT AT ZE, 20; INVERSE ON; FLASH ON
               ; "INITIALISING"
       9070 FOR I = ON TO LN
       9080 FOR J = ON TO FR
       9090 LET C&(I, J) = "-"
       9100 NEXT I
       9110 BEEP .01, 20
       9120 NEXT I
       9130 PRINT AT ZE, 20; "------------"
       9140 LET D& = "0123456789ABCDEF"
       9150 CLS : PRINT "LOWEST-ADDRESS : -"; 31500
       9160 INPUT "LOADING-ADDRESS : -"; R : PAUSE 20
       9170 IF R < 31500 THEN GO TO 9160
       9180 CLS : GO TO MR

COPYRIGHT -авторские права;  
MACHINE-CODE-MONITOR -монитор машинного языка;  
ROUTINE - программа;  
MAIN ROUTINE - основная программа;  
COMMAND OR LINE - команда или строка;  
NUMBER  MUST  BE 3 BYTES - номер строки должен составлять три
байта;  
PRINT A BLOCK OF LINES - напечатать блок строк;  
COMMANDS - команды;  
MEMORY DISPLAY - распечатка памяти;  
STARTING ADDRESS - начальный адрес;  
LOAD - загрузка;  
LOAD  ARRAY  : PRESS-ANY-KEY-WHEN---READY - загрузка массива:
нажмите любую клавишу,когда будете готовы;  
SAVE - запись;  
ENTER NAME - введите имя;  
SOURCE OR MACHINE CODE - исходный текст или текст на машинном
языке;  
FINISHING ADDRESS - конечный адрес;  
INITIALISATION - инициализация;  
LINE NUMBER BUFFER - буфер номеров строк;  
LOWEST ADDRESS - наименьший адрес; 
LOADING ADDRESS - адрес загрузки. 
