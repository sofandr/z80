

      МОНИТОРНАЯ  ПРОГРАММА ЗАГРУЗКИ ТЕКСТА ПРОГРАММЫ НА
      --------------------------------------------------
      МАШИННОМ ЯЗЫКЕ В ШЕСТНАДЦАТЕРИЧНОМ ФОРМАТЕ HEXLOAD
      --------------------------------------------------

         Эта,  написанная  на языке "Бейсик" программа, может
быть  монитором  сама по себе, поскольку она может записывать
данные  в  шестнадцатеричном  формате в память, распечатывать
содержимое  памяти,  перемещать содержимое памяти, записывать
содержимое памяти на кассету и загружать его с кассеты. 
         С  другой  стороны,  мы  можем  применять  программу
HEXLOAD  в качестве полусвязывающего загрузчика (SIME-LINKING
LOADER)  для текста программы, созданного программой кода EZ.
Так   получается   потому,   что   программа  кода  EZ  может
применяться   только   для   ввода   небольших   модулей,  не
превышающих  800  байтов  или 200 команд. Так что для больших
программ  мы  применяем  программу  кода  EZ  для  разработки
модулей  и записываем каждый модуль в виде текста на машинном
языке  на  кассету.  Затем  мы  используем программу HEXLOAD,
гораздо  меньшую по объему программу на языке "Бейсик", чтобы
загрузить эти модули и связать их, переместив в отведенные им
ячейки памяти. 
         Мы  применим  этот  метод на практике при разработке
программы FREEWAY FROG. 

             Идейные основания программы HEXLOAD
             -----------------------------------

         Идеи,    лежащие   в   основе   программы   HEXLOAD,
чрезвычайно   просты.  Мониторная  программа  на  самом  деле
устанавливает  RAMTOP  системы  "Бейсик"  равным  26999.  Это
означает,  что  вы  можете вводить свою программу на машинном
языке  в  любое  место  между  ячейками  27000  и  32578  для
"Спектрум"  с 16K оперативной памяти или с 27000 по 65343 для
"Спектрум" с 48K. 

  HEXLOAD  - достаточно  простая   мониторная  программа  для
             работы   с   текстом   на  машинном  языке.  Она
             представляет такие базисные функции управления: 
  WRITE    - запись в память в шестнадцатеричном формате;
  SAVE     - запись из памяти на кассету;
  LOAD     - запись с кассеты в память;
  LIST     - распечатка     содержимого   памяти    начиная с
             начального адреса 
  MOVE     - перемещение содержимого памяти  из одной  группы
             ячеек в другую. 

                   Сводка команд программы
                   -----------------------

         1. WRITE 
Запись   текста   программы  в  шестнадцатеричном  формате  в
память. 
Процедура: 
         а)  В  ответ  на  подсказку  ввести  начальный адрес
памяти,  с  которого  вы  хотите  вести  запись  в десятичном
формате. 

             Адрес должен лежать в диапазоне: 

             27000 - 32578 для памяти объемом 16K
             27000 - 65346 для памяти объемом 48K

         б)   Введите  текст  программы  в  шестнадцатеричном
формате. 
         в)  Нажмите клавишу "M", чтобы вернуться к основному
меню. 

         2. SAVE 
Запись содержимого памяти на кассету. 
Процедура: 
         а)  Вводимое  значение  начального  адреса памяти, с
которого  начинается  запись,  может быть любым из следующего
диа- пазона: 

               0 - 32767 для памяти объемом 16K
               0 - 65535 для памяти объемом 48K

         б) Введите количество записываемых байтов. 
         в) Введите имя записываемого модуля. 
         г)   Нажмите  любую  клавишу,  когда  кассета  будет
готова. 
         д)   Возможность  проверки  модуля,  записанного  на
кассету.  Неплохо сделать проверку, чтобы удостовериться, что
модуль не испортился во время процедуры записи. 

         3. LOAD 
Загрузка модуля на машинном языке с кассеты. 
Процедура: 
         а)  Введите адрес памяти, с которого модуль начинает
загружаться.  Адрес  должен  лежать в том же диапазоне, что и
для команд записи. 
         б)  Введите  имя,  использованное при записи модуля.
Если вы не уверены в имени, просто нажмите клавишу "ENTER". 

         4. LIST 
Выдача содержимого памяти, начиная с некоторого адреса. 
Процедура: 
         а)  Введите  адрес начала распечатки. Это может быть
любой адрес как в приведенной выше команде SAVE. 
         б) Нажмите любую клавишу для продолжения выдачи. 
         в)  Нажмите клавишу "M", чтобы вернуться к основному
меню. 

         5. MOVE 
Переместить  содержимое памяти с начального по конечный адрес
по новому адресу в памяти. 
Процедура: 
         а)  Ввести начальный адрес перемещаемой порции,любой
адрес, как в диапазоне для команды SAVE. 
         б)  Ввести конечный адрес перемещаемой порции, любой
адрес, как в диапазоне для команды SAVE. 
         в)   Введите   адрес   памяти,   куда   перемещается
информация, диапазон адресов, как в команде WRITE. 
         г)  Вы можете даже с помощью этой команды копировать
из ПЗУ в память с произвольным доступом. 
Например: 

             Переместить, начиная с: 0(ENTER)
             Переместить, кончая: 1000(ENTER)
             Переместить по адресу: 32000(ENTER)

         Такая   последовательность   действий   приведет   к
перемещению  содержимого  ПЗУ  с  0  по 1000 адрес в память с
произвольным доступом по адресу 32000. 
         Замечание:  любая  попытка  ввода в приведенных выше
командах,  нарушающая допустимый диапазон адресов, приведет к
повторению подсказки для ввода. 

                          Упражнение
                          ----------

         Попробуйте  с  помощью этого монитора ввести модуль,
разработанный нами, с помощью программы кода EZ. 

         HEXLOAD
         COPYRIGHT (C) 1982 BY WILLIAM TANG AND DAVID WEBB

         100 REM
         110 REM MONITOR-PROGRAM
         120 CLEAR 26999 : LET ZE = PI - PI
             : LET ON = PI / PI : LET TW = ON+ON
             : LET QK = 256 : LET LM = 27000
             : LET MR = 140 : LET WL = 340
         130 GO SUB 2000
         140 CLS
             : PRINT "START -OF,MACHINE-CODE-FREF ="
             ; LM
         150 PRINT "MENU" : PRINT
             : PRINT
                    "----WRITE-MACHINE-CODE.........1"
         160 PRINT
             : PRINT
                    "----SAVE--MACHINE-CODE.........2"
         170 PRINT
             : PRINT
                    "----LOAD--MACHINE-CODE.........3"
         180 PRINT
             : PRINT
                    "----LIST--MACHINE-CODE.........4"
         190 PRINT
             : PRINT
                    "----MOVE--MACHINE-CODE.........5"
         200 PRINT
             : PRINT
                    "PLEASE-PRESS-APPROPRIATE-KEY."
         210 LET G& = INKEY&
         220 IF G& = " " OR G& = "M" THEN STOP
         230 IF G& = " " OR G& < "1" OR G& > "5"
             THEN GO TO 210
         240 CLS
             : PRINT "START-OF-MACHINE-CODE-AREA = "
             ; LM
         250 GO TO 300* VAL G&
         300 REM INV WRITE****************** IRU
                 ---                         ---
         310 INPUT "WRITE-TO-ADDRESS :"; D
         320 IF D > MM OR D < LM THEN GO TO 310
         330 PRINT : PRINT "WRITE-ADDRESS:-"; D
             : PRINT "TO-RETURN-TO-MENU-ENTER-""M"""
         340 LET A& =""
         350 IF A& = "" THEN INPUT "ENTER-HEX.-CODE :"
             ; A& 
         360 IF A&(ON) =" " OR  A&(ON) = "M"
                THEN GO TO MR
         370 IF LEN A&/TW <> INT (LEN A&/TW)
                THEN PRINT "INCORRECT-ENTRY-";
             : GO TO WL
         380 LET C = ZE
         390 FOR F = 16 TO ON STEP -15
         400 LET A = CODE A&((F = 16)+TW*(F = ON))
         410 IF A < 48 OR A > 102 OR (A >57 AND A <B 65)
                OR (A > 70 AND A < 97)
                THEN PRINT "INCORRECT-ENTRY-";
             : GO TO WL
         420 LET C = C+F*((A < 58)*(A-48)
                 +(A > 64 AND A < 71)*(A-55)+(A < 96)*(A-87))
         430 NEXT F : POKE D, C :M LET D = D+ON
         440 PRINT A&(TO TW); "--";
         450 LET A& = A&(3 TO)
         460 IF D =UDG
                THEN PRINT
                "WARNING :YOU-ARE-NOW-IN-THE-USER
                GRAPHICS-AREA!"
             : GO TO WL
         470 IF D = UDR-20
                THEN PRINT
                "WARNING : YOU-ARE-NOW-IN-ROUTINES
                MEMORY-AREA!"
             : GO TO WL
         480 GO TO WL+ON
         600 REM INV SAVE****************** IRU
                 ---                        ---
         610 INPUT "SAVE-M,C.-FROM- ADDRESS :"; A
         620 INPUT "NUMBER-OF-BYTES-TO-BE-SAVED :"; N
         630 INPUT "NAME-OF-THE-ROUTINE :"; A&
         640 SAVE A& CODE A, N
         650 PRINT "DO-YOU-WISH-TO-VERITY?"
         660 INPUT V&
         670 IF V& <> "Y" THEN GO TO MR
         680 PRINT "REWIND-TAPE-AND-PRESS-""PLAY""."
         690 VERIFY A& CODE A, N
         700 PRINT "O.K." : PAUSE S&
         710 GO TO MR
         900 REM INV LOAD****************** IRU
                 ---                        ---
         910 INPUT
                "LOAD-M.C.-TO-ADDRESS-STARTING--- :-
                ; A
         920 IF A > MM OR A < LM THEN GO TO 910
         930 INPUT "PROGRAM-NAME :"; A&
         940 PRINT "PRESS-""PLAY""-ON-TAPE."
         950 LOAD A& CODE A : GO TO MR
        1200 REM INV LIST****************** IRU
                 ---                        ---
        1210 LET A& = "0123456789ABCDEF"
        1220 INPUT "LIST-ADDRESS :"; D
        1230 PRINT "PRESS-""M""-TO-RETURN-TO-MENU."
        1240 LET A = INT (PEEK D/16)
             : LET B = PEEK D-16* INT (PEEK D/16)
        1250 PRINT D; TAB 7; A&(A+ON); A&(B+ON)
        1260 LET D = D+ON
        1270 IF INKEY& = " " OR INKEY& = "M" THEN GO TO MR
        1280 GO TO 1240
        1500 REM INV MOVE****************** IRU
                 ---                        ---
        1510 INPUT "MOVE-FROM-MEMORY :-"; FM
        1520 INPUT "MOVE-UNTIL-MEMORY :-"; UM
        1530 INPUT "MOVE-TO-MEMORY :-"; TM
        1540 IF TM > FM THEN GO TO 1610
        1550 LET MO = TM
        1560    FOR I = FM TO UM
        1570 POKE MP, PEEK I
        1580 LET MP = MP+ON
        1590 NEXT I
        1600 GO TO MR
        1610 LET MP = UM+TM-FM
        1620 FOR I = UM TO FM STEP -ON
        1630 POKE MP, PEEK I
        1640 LET MP = MP-ON
        1650 NEXT I
        1660 GO TO MR
        2000 LET RT = PEEK 23732+QK* PEEK 23733
        2010 IF RT = 65535 THEN LET MM = 65347
             : LET UDG = 65367
        2020 IF RT = 32767 THEN LET MM = 32579
             : LET UDG = 32599
        2030 LET N1 = INT (UDG/QK)
        2040 POKE 23675, UDG-N1*QK : POKE 23676, N1
        2050 RETURN

MONITOR PROGRAM - мониторная программа;  
START  OF,  MACHINE  CODE  AREA  -  начало  области  текста в
машинных командах;  
MENU - меню; 
WRITE MACHINE CODE - записать текст на машинном языке;  
SAVE MACHINE CODE - запомнить текст на машинном языке;  
LOAD MACHINE CODE - загрузить текст на машинном языке;  
LIST MACHINE CODE - распечатать текст на машинном языке;  
MOVE MACHINE CODE - переместить текст на машинном языке;  
PLEASE   PRESS   APPROPRIATE   KEY   -   пожалуйста,  нажмите
соответствующую клавишу;  
START OF MACHINE CODE AREA - начало области текста в машинных
командах;  
WRITE TO ADDRESS - записать по адресу;  
TO RETURN TO MENU ENTER -чтобы вернуться к меню, введите;  
ENTER NEX. CODE - введите в шестнадцатеричных кодах;  
INCORRECT ENTRY - неверный ввод; 
WARNING:  YOU ARE NOW IN USER GRAPHICS AREA - предупреждение:
вы сейчас в графической области пользователя;  
WARNING"   YOU   ARE  NOW  IN  THE  ROUTINES  MEMORY  AREA  -
предупреждение: вы сейчас в области памяти программ;  
SAVE M.C. FROM ADDRESS - запомнить текст на машинном языке;  
NUMBER OF BYTES TO BE SAVED - количество запоминаемых байтов;
NAME OF THE ROUTINE - название программы;  
DO YOU WISH TO VERIFY - хотите проверить?;  
REWIND  TAPE  AND PRESS "PLAY" - перемотайте пленку и нажмите
"пуск";  
LOAD  M.C.  TO  ADDRESS  STARTING загрузить текст на машинном
языке по адресу; 
PRESS "PLAY" ON TAPE -нажмите "пуск" для пленки;  
LIST ADDRESS - адрес для распечатки;  
PRESS  "M" TO RETURN TO MENU - нажмите "М", чтобы вернуться в
меню;  
MOVE FROM MEMORY - переместить, начиная с ячейки памяти; MOVE
UNTIL MEMORY - переместить до ячейки памяти; 
MOVE TO MEMORY - переместить по адресу. 

        П Р О Г Р А М М А   "F R E E W A Y   F R O G"

                     Разработка программы
                     --------------------

         Эта   программа  посвящена  лягушкам,  прыгающим  по
направлению к дому, пересекая шоссе. По шоссе едут грузовики,
легковые   машины   и  мотоциклы,  и  его  часто  патрулируют
полицейские  машины.  Счет определяется тем, за сколько ходов
лягушка пропрыгает с одной стороны шоссе на другую. 
         Вы  должны  достаточно  ясно представлять себе игру,
поскольку вы - программист. 
         Это - просто этап формулирования задачи 
         Если  мы  не  смогли  ясно  сформулировать  и понять
задачу,  то  нам  будет очень трудно понять к чему мы идем на
последующих  этапах  конструирования  и  разработки проекта в
целом. 

              Структура программы "FREEWAY FROG"
              ----------------------------------

         Теперь  мы  можем  применить все, что нами изучено о
нисходящем  модульном  проектировании программ. Мы начинаем с
очень  высокого  уровня  и  разбиваем всю программу на хорошо
определенные логические модули. Вот они. 
1. Инициализация. 
         Выполняет все первоначальные задачи. 

2. Поток транспорта. 
         Управляет  движением  по  шоссе.  Этот модуль в свою
очередь можно подразбить логически: 
         а)регулярный  поток транспорта, например, грузовики,
легковые машины и мотоциклы. 
         б)нерегулярный     поток    транспорта,    например,
полицейские машины. 

3. Лягушка. 
         Управляет    движением    лягушки,    проверяет   на
столкновение, а также на достижение дома. 

4. Общее управление программой. 
         Эта  часть программы отвечает за ведение счета и его
выдачу, проверку конца игры. 

5. Завершение. 
         Выполняет   служебные  функции  перед  возвратом  из
программы. 

             Разработка программы "FREEWAY FROG"
             -----------------------------------

         Разработку  программы  FREEWAY  FROG мы разбили на 6
этапов.  Разбиение на эти 6 этапов очень близко к показанному
выше  логическому  разбиению.  На  каждом этапе разработки мы
будем  проверять,  что каждый этап работоспособен, прежде чем
перейти к следующему этапу. Вот эти шесть этапов. 
1. Разработка базы данных. 
         Включает  разработку  очертаний  объектов,  создание
базы  данных  для  каждого  объекта  и переменных, с которыми
будет работать программа. 
2. Инициализация. 
         Включает   распределение   экрана   и  инициализацию
различных переменных. 
3. Поток транспорта. 
         Здесь  мы  разрабатываем  только  регулярный поток и
проверяем  его отдельно от нерегулярных появлений полицейских
машин, которым свойственна другая логика. 
4. Полицейская машина. 
         Мы  разрабатываем  и  проверяем движение полицейской
машины. 
5. Лягушка. 
         Здесь    будет    проверяться    движение   лягушки,
перемещение  ее  путем  стирания  старой  и изображения новой
лягушки, проверка столкновений, подсчет счета ... и т.д. 
6. Управление программой. 
         Отвечает   за   обновление   наивысшего  результата,
рестарт   игры,   экстренное  прекращение  игры,  возврат  из
программы. 
         Прежде  чем  перейти  к  разработке этапов программы
FREEWAY  FROG  ,  мы  введем  программу на "Бейсике", которая
складывает  содержимое  блока  памяти  и генерирует сумму как
"контрольную  сумму".  Вы  можете  найти, что эта контрольная
сумма полезна для проверки ошибок при вводе данных. 

         9000 REM
         9010 REM CHECKSUM
         9020 INPUT "FROM ADDRESS: ";F
         9030 INPUT "TO ADDRESS : ";T
         9040 LET S=0
         9050 FOR I=F S=0
         9060 LET S=S+PEEK I
         9070 NEXT I
         9080 PRINT "CHECKSUM: ";S
         9090 GO TO 9020

CHECKSUM - контрольная сумма;  
FROM ADDRESS - начиная с адреса;  
TO ADDRES - по адрес. 

         Введите  начало  блока  памяти,  затем  конец  блока
памяти,  для  которого вы хотите просчитать контрольную сумму
(значения  вводятся в десятичном формате). Программа на языке
"Бейсик " подсчитает значение контрольной суммы. 

                         Э Т А П   1

         Разработка формы объектов. 
         Поскольку   эта   игра   с  двухсторонним  движением
транспорта,  нам  нужно  создать  два изображения грузовиков:
движущийся влево и движущийся вправо и т.д. 
         Для  лягушки будет 4 возможных направления движения,
так   что   будет   4  изображения,  по  одному  для  каждого
направления. 
         Давайте  примем  следующие  соглашения  о  положении
объекта и изображение каждого объекта. 
         Если изображение составлено из 4 литер 

                            C   D
                            A   B

то  указатель положения будет направлен на литеру A. Литера A
изображается  первой,  затем  -  литера  B...., пока не будет
закончен весь ряд. 
         Затем   мы   изобразим   следующий  выше  ряд.  Т.е.
сдвинемся на одну строку вверх на литеру C. 
         Таким образом, мы создадим базу данных форм в виде 

                          ФОРМА ABCD

         Не   забудьте,   что   изображение   каждой   литеры
определяется 8 байтами. 
         Если  мы  применим принцип изображения каждой литеры
начиная  с верхнего байта и кончая нижним, то нам понадобится
организовать  базу  данных  форм  также в нисходящем порядке.
Таким   образом,   база   данных  будет  выглядеть  следующим
образом: 

        SHAPE   A1, A2, A3, A4, A5, A6, A7, A8
                B1, B2, B3, B4, B5, B6, B7, B8
                C1, C2, C3, C4, C5, C6, C7, C8
                D1, D2, D3, D4, D5, D6, D7, D8
        SHAPE - форма

         Давайте  примем другой принцип, состоящий в том, что
при   изображении  фигурки  мы  будем  сначала  заносить  все
изображение в память экрана в соответствующую ячейку, а затем
уже  изменять  файл  атрибутов.  Мы,  поэтому,  будем хранить
информацию  об  атрибутах,  относящуюся  к изображению, после
данных о ней в экранной памяти. 
         В    отличие    от    изображения,   каждой   литере
соответствует байт данных об атрибуте. 
         Итак,для   обеспечения  данных  об  атрибуте  у  нас
имеется  4  байта  данных  об  атрибуте,  расположенных после
описанных   выше   32   байтов  данных  об  изображении  (для
изображения из 4 литер). 

                   Ввод изображения объекта

         Модуль  расположен  в байтах с 27055 по 28040, общая
длина - 986 байтов, контрольная сумма равна 79197. 

LABEL   LINE#    FROM(H)   TO(H)    FROM(D)   TO(D)  CHECKSUM
-------------------------------------------------------------
FRGSHP   120     69AFH     6A36H     27055    27190     18085
LBIKE    340     6A37H     6A76H     27191    27254      3647
LBATT    430     6A77H     6A7EH     27255    27262        28
RBIKE    460     6A7FH     6ABEH     27263    27326      3355
RBATT    560     6ABFH     6AC6H     27327    27334        28
LCAR     600     6AC7H     6B26H     27335    27430      5073
LCATT    730     6B27H     6B32H     27431    27442        36
RCAR     770     6B33H     6B92H     27443    27538      4902
RCATT    900     6B93H     6B9EH     27539    27550        12
LTRUCK   940     6B9FH     6C76H     27551    27766     22023
LTATT   1230     6C77H     6C91H     27767    27793        87
RTRUCK  1280     6C92H     6D69H     27794    28009     21834
RTATT   1570     6D6AH     6D84H     28010    28036        87
BLANK   1620     6D85H     6D88H     28037    28040         0

LABEL - метка;  
LINE# - номер строки;  
FROM - начало;  
TO - конец
CHECKSUM - контрольная сумма

Предлагается   имя  "SHAPOB"  (SHAPE  DATABASE  -база  данных
изображений)  Все  описанные объекты, за исключением лягушки,
можно сгруппировать в байты данных SHAPE, за которыми следуют
байты данных атрибутов. 
         Причина,  по которой база данных изображения лягушки
имеет  другой  формат, состоит в том, что мы приняли решение,
что  в  любой  конкретный  момент  времени  вся лягушка имеет
одинаковый цвет-з е л е н ы й, когда она жива, к р а с н ы й,
когда она умирает, ж е л т ы й , когда она попадает домой. 
         В этой игре мы используем ч е р н ы й (0) в качестве
цвета   бумаги,   за   исключением  границ  шоссе  и  верхней
информационной   строки,   где   в   качестве   цвета  бумаги
используется б е л ы й (7). 
         Для  объектов,  движущихся  только по шоссе, атрибут
бумаги  будет  равен  0, а цвет чернил - тот, который задан в
его базе данных. 
         Прежде, чем вводить базу данных изображений в память
и  записывать ее на кассету, предполагается, что вы понимаете
как в памяти представляются литеры. 
         Теперь  мы объясним как распечатываются программы на
ассемблере,  используя  в качестве примера изображение FROG1,
начинающееся со строки 160. В строке 160 вы видите 
 6987    6F   160 FROG1    DB    111,15,31,159,220,216,120,48
         0F  1F 9F DC D8 78 30
 6987  - адрес памяти в шестнадцатеричном формате;
 6F    - начало  восьми  байтов текущей команды базы данных в
         шестнадцатеричном     формате.     Шестнадцатеричные
         значения следующих семи байтов находятся в следующих
         строках с номерами от 160 до 170.т.е. 0FH, 1FH, 9FH,
         DFH, D8H, 78H, 30H. 
 160   - номер строки распечатки ассемблера.
 FROG1 - метка, только для нашего удобства.
 DB    - мнемоническое   обозначение.   Означает, что  дальше
         следует       последовательность      байтов.(Аналог
         предложения DATA в языке "Бейсик"). 
 111,15,31,159,22,0,216,120,48 - байты, загружаемые в память.

         Теперь давайте построим изображение FROG1 

            00      00000000      00000000     00
            01      00000001      10000000     80
            23      00100011      11000100     C4
            25      00100101      10100100     A4
            6F      01101111      11110110     F6
            4F      01001111      11110010     F2
            DF      11011111      11111011     F8
            FF      11111111      11111111     FF

            6F      01101111      11110110     F6
            0F      00001111      11110000     F0
            1F      00011111      11111000     F8
            9F      10011111      11111001     F9
            DC      11011100      00111011     38
            D8      11011000      00011011     18
            78      01111000      00011110     1E
            30      00110000      00001100     0C

         Помните: 
         1.  Сначала  мы  рисуем нижний ряд слева направо.  
         2. Затем мы рисуем следующий сверху ряд.  
         3.  Для каждой литеры мы рисуем восемь байтов сверху
             вниз.  
         4. Затем в самом конце мы заполняем атрибуты. 

FRGSHP  в  строке  120  оределяет один из четырех указателей,
задающих   четыре   изображения  лягушки.  Таким  образом,  в
программе мы сможем найти правильное изображение по заданному
направлению движения лягушки. 
DEFW  -  мнемоническое  обозначение, означающее, что мы хотим
определить  2-байтовое "NN". Сначала идет младший байт, затем
старший. 

Ввод базы данных изображений 
         Введите  с помощью программы HEXLOAD строки с 120 по
1590   из  распечатки  ассемблера.  Вводите  только  байты  в
шестнадцатеричном формате, как показано в столбце 2. 
         Не  забудьте  записать  и проверить текст программы,
прежде чем перейти к следующей части этого этапа. 

Разработка базы данных объектов 
         Мы решили, что по двум полосам шоссе будут регулярно
двигаться  шесть экипажей. Они случайным образом распределены
по   двум   полосам.   База  данных  объектов  будет  хранить
информацию о текущем состоянии движения транспорта. Например,
для  каждого  объекта  нам  нужно  знать:  наличие,  значение
счетчика  цикла  движения,  направление движения, частично он
находится  на  экране  или  нет, указатель позиции, указатель
базы  данных  изображений,  указатель  базы данных атрибутов,
количество  строк, занятых изображением, количество столбцов,
занятых изображением. 
         База  данных  несет  информацию  о  каждом объекте в
каждом цикле игры. 
         Первые  шесть  групп  баз  данных, занимающие строки
программы  с  1710  по  2040,  представляют  шесть  экипажей,
которые  должны быть на шоссе. Когда какой-либо экипаж уходит
с шоссе, случайным образом порождается другой экипаж. 
         Один  простой  способ  решения задачи состоит в том,
чтобы подготовить начальную информацию для каждого возможного
экипажа и запомнить ее в памяти. 
         Когда создается новый экипаж, мы просто обращаемся в
соответствующие  ячейки памяти и получаем базу данных. Тот же
самый  принцип  мы  применим  к полицейской машине и лягушке.
Поэтому,  когда  мы строим базу данных объектов, нам не нужно
строить   временную   базу   данных,   поскольку   она  будет
инициализирована программой. 

План памяти временной базы данных. 
Формат:   для   шести   существующих   экипажей,   лягушки  и
полицейской машины: 

               EXISTENCE       DEFB    1 BYTE
               CYCLE COUNT     DEFB    1 BYTE
               DIRECTION       DEFB    1 BYTE
               REAL/ABSTRACT   DEFB    1 BYTE
               POSITION        DEFW    2 BYTES
               SHAPE POINTER   DEFW    2 BYTES
               ATTRIBUTE       DEFW    2 BYTES
               ROW             DEFB    1 BYTE
               COLUMN          DEFB    1 BYTE

                       TOTAL  12 BYTES

EXISTENCE - существование;  
CYCLE COUNT - счетчик цикла;  
DIRECTION - направление;  
REAL/ABSTRACT - реальное/абстрактное;  
POSITION - позиция;  
SHAPE POINTER - указатель изображения;  
ROW - ряд;  
COLUMN -колонка. 

    LABEL      LINE#   FROM(H)    TO(H)   FROM(D)   TO(D)
    ------     -----   -------    -----   -------   -----
    OB1EXT     1710     6E25H     6E30H    28197    28208
    OB2EXT     1800     6E31H     6E3CH    28109    28220
    OB3EXT     1850     6E3DH     6E48H    28221    28232
    OB4EXT     1900     6E49H     6E54H    28233    28244
    OB5EXT     1950     6E55H     6E60H    28245    28256
    OB6EXT     2000     6E61H     6E6CH    28257    28268
    PCAREXT    2070     6E6DH     6E78H    28269    28280
    FRGEXT     2180     6E79H     6E80H    28281    28288

         Как  упомянуто  выше,  это  только временная рабочая
память.  Содержащаяся  в  ней  информация меняется в процессе
игры.  Есть  еще  две основные временные рабочие области. Они
используются  для  того,  чтобы хранить то, что находится под
лягушкой и полицейской машиной соответственно. 

    LABEL      LINE#    FROM(H)   TO(H)   FROM(D)   TO(D)
    ------     -----    -------   -----   -------   -----
    FRGSTR     1650     6D89H     6DACH    28041    28076
    PCSTR      1660     6DADH     6F24H    28077    28196

         Нам нет необходимости определять какие бы то ни было
из  этих  ячеек  - только учитывать их присутствие. Нам нужно
только построить следующую базу данных. 
         База    данных   объектов   организована   следующим
образом: 

   FRGDB       база данных лягушки
   DBINDEX     индекс остальных баз данных объектов
       RBDB    база данных правого мотоцикла
       LBDB    база данных левого мотоцикла
       RCDB    база данных правой автомашины
       LCDB    база данных левой автомашины
       RTDB    база данных правого грузовика
       LTDB    база данных левого грузовика
       LPCDB   база данных левой полицейской машины
       LPCATT  база данных атрибутов левой полицейской машины
       RPCDB   база данных правой полицейской машины
       RPCATT  база данных атрибутов правой полицейской машины

 LABEL     LINE#   FROM(H)   TO(H)   FROM(D)  TO(D)   CHECKSUM
 ------    -----   -------   -----   -------  -----   ---------
 FRGDB     2260     6E81H    6E88H    28289   28296       561
 DBINDEX   2320     6E89H    6E94H    28297   28308      1734
 RBDB      2400     6E95H    6EA0H    28309   28320       640
 LBDB      2470     6EA1H    6EACH    28321   28332       692
 RCDB      2540     6EADH    6EB8H    28333   28344       523
 LCDB      2610     6EB9H    6EC4H    28345   28356       760
 RTDB      2680     6EC5H    6ED0H    28357   28368       584
 LTDB      2750     6ED1H    6EDCH    28369   28380       809
 LPCDB     2820     6EDDH    6EE8H    28381   28392       955
 LPCATT    2890     6EE9H    6EF4H    28393   28404        30
 RPCDB     2930     6EF5H    6F00H    28405   28416       379
 RPCATT    3000     6F01H    6F0CH    28417   28428        30

         Модуль  занимает  байты  с 28289 по 28428, длина 140
байтов, контрольная сумма 7697. 
         Предлагается имя "OBJOB" (база данных объектов). 
         Мы  знаем, что у всех объектов, за исключением FROG,
базы данных состоят из 12 байтов. 
         Ниже приводятся значение и содержимое каждого байта.

*Существование (1 байт). 
         Устанавливается   равным   нулю,   когда  объект  не
существует;  
         Устанавливается  равным  N,  где  (N-1) - количество
циклов,  в  течение которых объект будет ожидать, пока ему не
будет  разрешено  двигаться.  
Значения  N  для: левого и правого мотоцикла 2 левой и правой
автомашины  3 левого и правого грузовика 6 полицейской машины
1  лягушки  8  Иными словами, полицейская машина перемещается
каждый цикл, мотоцикл - через цикл и т.д. 

*Счетчик циклов (1 байт) 
         Сначала  устанавливается  равным 1, так что он готов
сразу  на-  чать  движение и уменьшается на 1 в каждом цикле.
Когда  он до- стигает нуля, объекту позволяется переместиться
и  счетчик  бу-  дет  заново  инициализирован  с помощью того
значения, которое хранится в байте существования. 

*Направление (1байт). 
         Любое   движение  слева  направо  (т.е.  по  верхней
полосе) будет иметь значение направления равное нулю. 
         Любое движение справа налево (т.е. по нижней полосе)
будет иметь значение направления равное единице. 

*Флаг реального/абстрактного объекта (1 байт). 
         Определяет,  не  находится  ли  объект  частично  за
пределами эк- рана. 
         Всякое  движение  слева  направо будет начинаться со
значения, равного нулю (абстрактный объект). 
         При  движении  слева  направо  нуль будет заменен на
единицу  ког-  да  указатель  объекта становится равным 4820H
(реальный экран). 
         При  всяком движении справа налево вначале этот флаг
будет иметь значение равное единице (реальный объект). В этом
слу-  чае  указатель позиции объекта направлен на экран, т.е.
48DFH. 
         При перемещении движущегося справа налево объекта за
пределы  экрана,  т.е.  когда  указатель  позиции меняется от
48C0H   до   48BFH,   этот   флаг  с  реального  сменится  на
абстрактный. 

*Указатель позиции (2 байта). 
         Двухбайтовый  указатель,  хранящий текущее положение
объекта. 

*Указатель изображения (2 байта). 
         Двухбайтовый   указатель,   задающий   базу   данных
изображения объекта. 

*Указатель атрибута (2 байта). 
         Двухбайтовый   указатель,   задающий   базу   данных
атрибутов объекта. 

*Ряд (1 байт). 
         Хранит  количество  рядов,  занимаемых  изображением
объекта. 

*Колонка (1 байт). 
         Хранит количество занимаемых объектом колонок. В это
значение  включаются две колонки пробелов, по одной с каждого
конца объекта. Цель введения этих двух дополнительных колонок
состоит  в  том,  чтобы  избежать  слишком  тесного сближения
транспорта. 
         Теперь  вы  можете  ввести базу данных инициализации
объекта из распечатки, строки с 2270 по 3010. Для ввода этого
модуля  вы  можете  применить  программу кода EZ или HEXLOAD.
Если  вы  используете программу кода EZ, на забудьте записать
не только исходную распечатку, но и распечатку ДАМПа. 

                     Общая база данных. 

         Мы  до сих пор рассматривали базу данных в ячейках с
69AFH по 6F0CH (27055 - 28428). 
         Теперь мы собираемся построить остальную базу данных
и мы назовем ее "общей базой данных". 
         Она организована так, как показано ниже. 

               LINE     500   TO   630   SOUND
                        660   TO   690   SCORE MESSAGE
                        720   TO  1210   GENERAL

 LABEL   LINE#   FROM(H)   TO(H)   FROM(D)   TO(D)   CHECKSUM
 -----   -----   -------   -----   -------   -----   --------
  PCTON1   500     6F0DH    6F10H    28429    28432      282
  PCTON2   510     6F11H    6F14H    28433    28436      166
  HOMTON   540     6F15H    6F3CH    28437    28476     2565
  SCRMS1   660     6F30H    6F42H    28477    28482      540
  SCORE    670     6F43H    6F48H    28483    28488      290
  SCRMS2   680     6F49H    6F53H    28489    28499      732
  HISCR    690     6F54H    6F58H    28500    28504      243

SOUND - звуковой сигнал;  
SCORE MESSAGE - сообщение о счете. 

         Модуль  занимает байты с 28429 по 28504, общая длина
76 байт, контрольная сумма 4818. 
         Предлагается имя "GENDB" (общая база данных). 
         Вам  нужно ввести только строки с 500 по 690. Строки
с 720 по 1210, ячейки памяти с 6F59H по 6F82H (28505 - 28546)
-  все это переменные, используемые программой. Строки 1100 -
1150   -   команды   с  мнемоническим  обозначением  EQ.  Они
присваивают  значения  соответствующим  меткам и используются
ассемблером. Вам не нужно что-либо вводить. 

                          ЗАКЛЮЧЕНИЕ

         Итак, мы рассмотрели всю область базы данных: ячейки
памяти с 69AFH по 6F82H (27055 - 28546). 
         Просмотрите  все  построенные вами модули, их имена,
диапазон  памяти,  прежде  чем  переходить к следующему этапу
построения  программы  FREEWAY  FROG.  Вы должны были к этому
моменту разобрать три модуля: 

     NAME     FROM MEM     TO MEM     LENGTH     CHECKSUM
     ----     --------     ------     ------     --------
     SHPDB     27055       28040       986         79197
     OBJDB     28289       28428       140          7697
     GENDB     28429       28504        76          4818

         Обратите  внимание,  что  база данных занимает почти
1400 байтов. 
