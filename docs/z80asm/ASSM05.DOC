
         ФЛАГ  ОТРИЦАНИЯ:  этот  флаг  устанавливается,  если
последней   выполненной  командой  было  вычитание.  Так,  он
сбрасывается (=0) для INC и устанавливается (=1) для DEC. 

                   ПРЕДЛАГАЕМЫЕ УПРАЖНЕНИЯ

         С  помощью группы команд LD, INC и DEC сделайте так,
чтобы  в  результате  операции  URS  возвращались  нужные вам
числа. Это позволит вам освоиться с этими командами. 

                         В Ы В О Д Ы

         Мы  можем  увеличивать  или  уменьшать  содержимое в
любом  из  8-битовых  регистров,  в  любой  из 16-битовых пар
регистров или в любом из 16-битовых индексных регистров. 
         Мы  можем также увеличивать или уменьшать содержимое
ячеек  памяти,  адреса  которых заданы парой регистров HL или
индексными регистрами. 
         Увеличение   или   уменьшение  16-битовых  чисел  не
оказывает влияния ни на один из флагов. 
         Увеличение  или  уменьшение  8-битовых  чисел  как в
регистрах,   так   и  в  памяти,  влияет  на  все  флаги,  за
исключением флага переноса. 

    А Р И Ф М Е Т И Ч Е С К И Е   О П Е Р А Ц И И   Д Л Я
                     О Д Н О Й   Р У К И

         По  поводу  арифметических  операций  для одной руки
нужно  только  заметить,  что  все  операции  в  данной главе
относятся   только  к  8-битовым  числам  и  все  они  должны
выполняться с помощью привилегированной руки, регистра А. 
         Возникает     впечатление,     что    только    наша
привилегированная рука умеет складывать и вычитать. 
         Этот факт настолько органично вплетается в мнемонику
машинного   языка   Z80,   что   в   некоторых  мнемонических
обозначениях сокращение А просто опускается. 
         Например,  если  нужно  вычесть  В из А, естественно
было бы ожидать команды,подобной 

                           SUB A,B

на самом же деле мнемоническое обозначение имеет вид

                            SUB B


       КОМАНДЫ  АРИФМЕТИЧЕСКИХ ОПЕРАЦИЙ ДЛЯ ОДНОЙ РУКИ
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЄЇЇЇЇЇЄЇЇЇЇЇЄЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ 

    MNEMONIC    BYTES TIME          EFFECT  ON  FLAGS
                           ЇЇЇЇЇЄЇЇЇЇЄЇЇЇЇЇЄЇЇЇЇЇЇЇЇЄЇЇЇЇ
                      TAKEN
                             C    Z   PV    S    N    H
 єЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  ADD A,REGISTER  1     4    #    #    #    #    0    #
  ADD A,NUMBER    2     7    #    #    #    #    0    #
  ADD A,(HL)      1     7    #    #    #    #    0    #
  ADD A (IX + Д)  3    19    #    #    #    #    0    #
  ADD A,(IY + Д)  3    19    #    #    #    #    0    #
 єЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  ADC A,REGISTER  1     4    #    #    #    #    0    #
  ADC A,NUMBER    2     7    #    #    #    #    0    #
  ADC A,(HL)      1     7    #    #    #    #    0    #
  ADC A,(IX + Д)  3    19    #    #    #    #    0    #
  ADC A,(IY + Д)  3    19    #    #    #    #    0    #
 єЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  SUB A REGISTER  1     4    #    #    #    #    1    #
  SUB A,NUMBER    2     7    #    #    #    #    I    #
  SUB A,(HL)      1     7    #    #    #    #    1    #
  SUB A,(IX + Д)  3    19    #    #    #    #    1    #
  SUB A,(IY + Д)  3    19    #    #    #    #    1    #
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  SBC A,REGISTER  1     4    #    #    #    #    1    #
  SBC A,NUMBER    2     7    #    #    #    #    1    #
  SBC A,(HL)      1     7    #    #    #    #    1    #
  SBC A,(IX + Д)  3    19    #    #    #    #    1    #
  SBC A,(IY + Д)  3    19    #    #    #    #    1    #
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  CP REGISTER     1     4    #    #    #    #    1    #
  CP NUMBER       2     7    #    #    #    #    1    #
  CP (HL)         1     7    #    #    #    #    1    #
  CP (IX + Д)     3    19    #    #    #    #    1    #
  CP (IY + Д)     3    19    #    #    #    #    1    #
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

MNEMONIC - мнемоническое обозначение;
BYTES - байты; 
TIME TAKEN - время выполнения; 
EFFECT  ON  FLAGS  -  ВОЗДЕЙСТВИЕ  НА  ФЛАГИ; 
REGISTER - регистр; 
NUMBER -число. 

                     Обозначения флагов:

      #  показывает, что флаг изменен операцией;
      0  показывает, что флаг сбрасывается;
      1  показывает, что флаг устанавливается;
      -  показывает, что флаг остается неизменным.

         Вопреки    этим   ограничениям,   накладываемым   на
арифметические  команды  (они должны ограничиваться регистром
А),  язык  Z80 очень разносторонен в плане того, что мы можем
сложить     с     произвольным    числом,    отложенным    на
привилегированной руке: 

ADD A,R         сложить с А произвольный одинарный регистр; 
ADD A,N         сложить с А произвольное 8-битовое число; 
ADD A,(HL)      прибавить  8-битовое число, находящееся в 
                ящике, адрес которого задается (HL); 
ADD A,(IX + Д)  прибавить 8-битовое число,  находящееся  в 
                ящике, адрес которого задается (IX + Д); 
ADD A,(IY + Д)  прибавить 8-битовое число,  находящееся  в 
                ящике, адрес которого задается (IY + Д). 
         Вы   можете  оценить  чрезвычайно  широкий  диапазон
возможных  чисел,  которые  мы  можем  сложить с произвольным
числом,   хранимым   в   А:  любое  число,  любой  регистр  и
практически произвольный способ, который нам придет в голову,
определить ячейку памяти. Отсутствует только следующий: 

                          ADD A,(NN)

в котором мы определяем адрес в ходе выполнения программы. 
         В  результате  единственный  способ  получить  такую
команду - это написать: 

                           LD HL,NN
                           ADD A,(HL)

         Обратите также внимание, что регистр HL вновь играет
привилегированную  роль. Мы не можем задавать ячейки памяти с
помощью пар регистров BC или DC. 
         Другое  ограничение,  неявно  присутствующее во всех
этих  командах - неустранимое ограничение 8-битовыми числами,
которые  могут  содержать  только значения до 255, как мы уже
видели. 
         Например, такие команды: 

                   LD A,80H       ADD A,81H

дадут  в  результате  в  A  только  1, но флаг переноса будет
установлен, чтобы отметить, что результат не уместился. 
         Если  вас  смущает  шестнадцатеричная арифметика, то
хорошо  для практики преобразовать числа в десятичную систему
и проверить сложение. 
         Шестнадцатеричное сложение и вычитание такие же, как
и в обыкновенной арифметике: 

                          1 + 1 = 2
                          1 + 2 = 3

и т.д., но когда вы доходите до 1 + 9, получается

                          1 + 9 = A
                          1 + A = B

и т.д., а когда вы доходите до 1 + F, получается

                          1 + F = 10

         Это  происходит  потому,  что  перенос  происходит в
следующий  столбец, когда у вас получается число, превышающее
F, а не 9, как в десятичной арифметике. 
         Результат   нашей,  приведенной  выше  программы  на
машинном языке, поэтому будет таков: 

                         80
                      +  81
                      --------
                        101H   так как 8 + 8 = 16 ==> 10H

       ЧТО МОЖНО ПОДЕЛАТЬ С ЭТОЙ ОШИБКОЙ ПРИ ПЕРЕНОСЕ?

         Конструкторы  Z80 предоставили нам еще одну команду,
аналогичную  ADD,  но  принимающую  во  внимание  возможность
переполнения в флаге переноса. 
         Это  очень  полезная  команда:  ADC,  читающаяся как
"сложение с переносом" (ADD WITH CARRY). 
         Она  совершенно  совпадает с командой ADD, имеет тот
же   диапазон   чисел,  регистров  и  т.п.  ,  которые  можно
складывать  с  регистром  A, за исключением того, что перенос
так же складывается (если он установлен). 
         Это  дает  возможность складывать числа, превышающие
255, с помощью цепочки операций. 
         Например,  сложить  1000  (т.е.  03E8H) с 2000 (т.е.
07D0H) и запомнить результат в BC: 

      LD A,E8H     : младшие разряды первого числа
     ADD A,D0H     : младшие разряды второго числа
      LD C,A       : записать результат в C
      LD A,03H     : старшие разряды первого числа
     ADC A,07H     : старшие разряды второго числа
      LD B,A       : записать результат в B

После  первого  сложения  (E8 + D0) у нас флаг переноса будет
установлен, (поскольку результат был больше FF), а в регистре
A будет B8 (проверьте это самостоятельно). 
         Второе   сложение   (3  +  7)  даст  не  0AH  (=  10
десятичное),  как может показаться на первый взгляд, а 0BH (=
11 десятичное) из-за переноса. 
         Поэтому  конечный  результат будет равен 0888H=3000.
Такую   цепочку   можно   продолжить   и   обработать   число
произвольного  размера, а результат будет храниться в памяти,
а не в паре регистров. 

                    8-БИТОВОЕ   ВЫЧИТАНИЕ

         Оно  совершенно  такое же, как и 8-битовое сложение.
Имеется два набора команд: один дл обычного вычитания, другой
для вычитания с переносом: 

                   SUB S - вычесть S
                   SBC S - вычесть S с переносом.

Обозначение  S  предназначено для того же диапазона возможных
операндов, что и для команд сложения. 

              СРАВНЕНИЕ  ДВУХ  8-БИТОВЫХ  ЧИСЕЛ

         Давайте  отвлечемся  на минутку от машинного языка и
посмотрим,  что  же  мы на самом деле понимаем под сравнением
двух чисел. 
         Мы  знаем,  что  происходит,  когда два сравниваемых
числа  совпадают  - они "равны". Один из способов обозначения
этого  факта  в  арифметической форме - сказать, что разность
между двумя числами равна нулю. 
         Что  если  сравниваемое число превышает первое число
(сравнение  предполагает  отношение  между  двумя числами: мы
сравниваем  число  с  тем,  что  у  нас  уже было отложено на
пальцах)?  Тогда результат после вычитания нового числа будет
отрицательным. 
         Аналогично,   если   новое  число  было  меньше,  то
разность будет положительной. 
         Мы  можем с помощью этих понятий разработать систему
сравнения на машинном языке, все, что нам нужно - это флаги и
операция  вычитания. Предположим, нам нужно сравнить числа из
некоторого диапазона с числом, скажем, 5: 

               LD A,5         : имеющееся число
              SUB N           : сравниваемое число

тогда у нас получатся следующие результаты: 
 если N = 5   флаг нуля установлен, флаг переноса сброшен;
 если N < 5   флаг нуля сброшен, флаг переноса сброшен;
 если N > 5   флаг нуля сброшен, флаг переноса
              установлен. 
         Поэтому  ясно,  что  проверку на равенство дает флаг
нуля,  а проверку на превышение - флаг переноса. Проверкой на
"меньше" будет сброс обоих флагов. 
         Единственное  неудобство этого метода состоит в том,
что  содержимое  регистра  A  изменяется  в  результате  этой
операции. 
         К счастью, у нас есть операция CPS. По английски она
читается  COMPARE  (сравнить).  Обратите  внимание,  что  она
позволяет  сравнивать  только  то,  что  у  нас уже имеется в
регистре  A: диапазон возможных чисел для сравнения такой же,
как и для сложения. 
         Сравнение   совершенно  совпадает  с  вычитанием  за
исключением  того,  что  содержимое регистра A не изменяется.
Таким образом, результат сказывается только на флагах. 

                         В Ы В О Д Ы

         Восьмибитовые   арифметические   операции   для  Z80
ограничиваются: 
                          сложением;
                          вычитанием;
                          сравнением
и могут выполняться только с помощью регистра A. 
         При   этих  ограничениях,  однако,  имеется  широкий
диапазон режимов адресации. 
         Из-за присущих 8-битовым числам свойств мы все время
должны  тщательно следить за переполнением. Флаг переполнения
(так   же,  как  и  другие  флаги)  изменяется  в  результате
арифметических  операций.  Мы  можем  пользоваться  этим  как
предупреждением о возможном переполнении. 
         Дополнительные   команды  (сложение  с  переносом  и
вычитание с переносом) позволяют нам выполнять арифметические
операции цепочкой, чтобы обрабатывать переполнение. 

           Л О Г И Ч Е С К И Е    О П Е Р А Т О Р Ы

         Есть     три    операции,    которые    в    области
программирования  на  машинном  языке  (или языке ассемблера)
имеют  такое  же  значение,  как  и более широко используемые
сложение,   вычитание,   умножение   и   деление   в  обычной
арифметике. 
         Их  обычно  называют  булевскими операторами в честь
человека,  сформулировавшего  для  этих операций правила. Это
следующие операции: 

                             AND
                             OR
                             XOR

         Мы  уже  знакомы  с понятием операций, приложимых ко
всему  8-битовому  числу, но причина, по которой эти операции
имеют  такое  значение,  состоит  в  том, что они затрагивают
отдельные биты числа (или пальцы на руке ЦП). 
         Давайте рассмотрим одну из этих операц 

               0         0                   0
               1         0                   0
               0         1                   0
               1         1                   1

                BIT - бит, RESULT - результат

         Очевидно,  что результат операции AND состоит в том,
что  1  получается  только  в  том  случае,  если  A  и B оба
содержали 1. 
         На  машинном  языке, если вы выполняете AND для двух
чисел, то результат будет таким, как если бы вы выполняли AND
для каждого отдельного бита этих двух чисел. 
         Вы   можете   задать   себе   вопрос:"В   чем  смысл
операции?" 
         Операция  AND  очень  полезна тем, что позволяет нам
маскировать  байт так, что он изменяется так, чтобы содержать
только определенные биты. 
         Если,   например,  мы  хотим  ограничить  конкретную
переменную диапазоном 0 - 7, нам хочется вполне ясно указать,
что  информация должна содержаться только в битах 0 - 2. Если
бы  информация  содержалась в бите 3, то число было бы равно,
по крайней мере, 8. 

      Например,   0 0 0 0   0 1 0 1     =  5 
                 (-----------)
                 эти биты должны быть 0
         Поэтому,  если  мы  берем  некоторое число, значение
которого  нам  неизвестно, и совершаем над ним операцию AND с
7, то в результате получится число в диапазоне 0 - 7. 

     Например,          0 1 1 0   1 0 0 1   = 105
                        0 0 0 0   0 1 1 1   = 7 => маска
                        ------------------
Результат операции AND  0 0 0 0   0 0 0 1   = 1 => в диап.
                                                   0 - 7

                КОМАНДЫ  ЛОГИЧЕСКИХ  ОПЕРАЦИЙ

 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЄЇЇЇЇЇЄЇЇЇЇЇЄЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ 

                      TIME        EFFECT  ON  FLAGS
    MNEMONIC    BYTES      ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЄЇЇЇЇЇЇЇЇЇЄЇЇЇЇ
                      TAKEN
                             C    Z   PV    S    N    H
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  AND REGISTER    1     4    0    #    #    #    0    1
  AND NUMBER      2     7    0    #    #    #    0    1
  AND (HL)        1     7    0    #    #    #    0    1
  AND (IX + Д)    3    19    0    #    #    #    0    1
  AND (IY + Д)    3    19    0    #    #    #    0    1
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  OR REGISTER     1     4    0    #    #    #    0    0
  OR NUMBER       2     7    0    #    #    #    0    0
  OR (HL)         1     7    0    #    #    #    0    0
  OR (IX + Д)     3    19    0    #    #    #    0    0
  OR (IY + Д)     3    19    0    #    #    #    0    0
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

  XOR REGISTER    1     4    0    #    #    #    0    0
  XOR NUMBER      2     7    0    #    #    #    0    0
  XOR (HL)        1     7    0    #    #    #    0    0
  XOR (IX + Д)    3    19    0    #    #    #    0    0
  XOR (IY + Д)    3    19    0    #    #    #    0    0
 ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ ЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇЇ

MNEMONIC - мнемоническое обозначение; 
BYTES - байты; 
TIME TAKEN - время выполнения;  
EFFECT  ON  FLAGS -  воздействие  на  флаги;
REGISTER - регистр; 
NUMBER - число.

                     Обозначения флагов:

        # - означает, что флаг изменен операцией;
        0 - означает, что флаг сбрасывается;
        1 - означает, что флаг устанавливается;
        - - означает, что флаг не изменился

         Обратите  внимание,  что чип Z80 позволяет выполнять
операцию  AND  только  с  регистром  A.  Для регистра A можно
выполнить операцию AND с 8-битовым числом, любым из остальных
8-битовых регистров, (HL), (IX + ), (IY + ). 

    AND 7    обратите внимание, что поскольку действие
    AND E    определено только для регистра A, нет не-
    AND (HL) обходимости упоминать его в команде.

         Для других Булевских операций, OR и XOR, имеет место
тот  же  диапазон  возможностей  и  ограничение использования
регистра A. 
         Операция OR по смыслу аналогична операции AND: 

                 BIT A     BIT B    BIT A OR BIT B
                  0         0             0
                  0         1             1
                  1         0             1
                  1         1             1

         Очевидно, результат операции OR должен давать нам 1,
если A или B содержали 1. 
         Вновь   вы   можете   задать  вопрос,  в  чем  смысл
операции? 
         Операция  OR  также  весьма  полезна  тем,  что  она
позволяет  нам устанавливать любой бит числа, если, например,
нам  желательно  гарантировать,  что число будет нечетным, то
совершенно  очевидно, что нам нужно установить бит 0. Того же
результата можно добиться с помощью команды SET. 

                     LD A,NUMBER
                     OR  !       :MAKE NUMBER 000

NUMBER - число; MAKE NUMBER 000 - сделать число нечетным. 
         Приведенные  выше  две  строки  -  типичный фрагмент
распечатки на ассемблере. 
         Смысл  операции  XOR  (исключающее  или) также легко
понять, но ее реальное использование в программировании более
ограничено. 
         Результат  операции XOR равен 1 только в том случае,
если A или B, но не оба сразу, содержит 1. 
         Иными  словами, результат такой же, как для операции
OR  во  всех  случаях,  за  исключением  того,  когда и A и B
содержат 1. 

                          XOR => OR - AND
               BIT A     BIT B     BIT A  'XOR' BIT B
                0         0                 0
                1         0                 1
                0         1                 1
                1         1                 0

BIT  -бит;  BIT  A 'XOR' BIT B - результат выполнения XOR для
битов A и B. 
         Последнее,   что  нам  необходимо  рассмотреть,  это
результат воздействия этих операций на флаги. 
ФЛАГ  НУЛЯ          этот  флаг  будет установлен (=1), 
                    если результат равен нулю; 
ФЛАГ ЗНАКА          этот флаг будет установлен (=1), 
                    если бит 7 результата установлен; 
ФЛАГ ПЕРЕНОСА       флаг  будет  сброшен  (=0) 
                    после   AND,   OR,   XOR,  перенос  будет
                    сброшен; 
ФЛАГ ЧЕТНОСТИ       этот флаг будет установлен (=1), 
                    если в результате будет четное количество
                    единичных битов: 

                    0 1 1 0   1 1 1 0   => установлен
                    0 1 1 0   1 0 1 0   => сброшен
                    Обратите  внимание,  что  этот флаг также
                    дублирует флаг переполнения. 
ФЛАГ ПОЛОВИН-  оба флага сброшены (=0) после AND, OR, XOR.Эти
НОГО ПЕРЕНОСА  флаги полезны, если используется арифметика для
ФЛАГ ВЫЧИТАНИЯ двоично-кодированных десятичных чисел.

          ПРИМЕНЕНИЕ БУЛЕВСКИХ ОПЕРАЦИЙ НАД ФЛАГАМИ

         Есть   особый  случай  Булевских  операторов,  очень
удобный, случай, когда регистр A действует на самого себя. 

   AND A    A не меняется, флаг переноса сбрасывается 
    OR A    A не меняется, флаг переноса сбрасывается 
   XOR A    A устанавливается  равным   нулю, флаг  переноса
            сбрасывается 
         Эти  команды  широко  используются,  поскольку в них
нужен  всего  один  байт для выполнения того, что в противном
случае потребовало бы двух, например, LD A,0. 
         Флаг переноса часто приходится сбрасывать, например,
в  рабочем порядке перед применением арифметических операций,
таких как 

              ADC     сложение с переносом
              SBC     вычитание с переносом

и это можно легко сделать с помощью команды AND без изменения
какого то бы ни было регистра. 

                         В Ы В О Д Ы

         Есть  три  логических оператора, полезных в машинном
языке: 

                   AND
                    OR
                   XOR

Эти  команды действуют только на 8-битовые числа, причем одно
из этих чисел должно храниться в регистре A. 
         Обратите внимание, что смысл операции AND в машинном
языке отличается от его смысла в качестве команды "Бейсик". 
         Логические  операторы  проверяют отдельные биты двух
чисел  и  поэтому  полезны при маскировании чисел и установке
отдельных битов. 

                РАБОТА С ЧИСЛАМИ ДЛЯ ДВУХ РУК

         До  сих  пор  мы работали только с числами для одной
руки (8-битовыми), но мы говорили о том, что ЦП может также в
некоторых   случаях   обрабатывать   и  числа  для  двух  рук
(16-битовые). 
         Один   из  этих  случаев  мы  уже  упоминали  -  это
индексные  регистры.  На  этих  "ногах"  по  16 "пальцев" (16
битов) и могут обрабатывать только 16-битовые числа. 
         Кроме  того,  мы  знаем,  что применяя совместно две
руки,  мы  можем  иногда  запоминать  16-битовые  числа.  Эти
совместно  используемые  руки  мы называем парами регистров".
Это пары DC, DE и HL. 
         ЦП   обрабатывает   16-битовые   числа   во   многом
аналогично тому, как вы или я работаем с тяжелыми предметами:
нам  нужны  две  руки,  мы  не очень хорошо приспособлены для
работы  с  ними  и  способ  работы с ними у нас медленный и с
ограничениями. 
         Теперь    давайте   рассмотрим   различные   способы
адресации  (возможные видоизменения), имеющиеся для обработки
16-битовых чисел. 

            НЕПОСРЕДСТВЕННАЯ РАСШИРЕННАЯ АДРЕСАЦИЯ
                           LD RR,NN
                     (ИЛИ ДРУГИЕ КОМАНДЫ)

         Это  -  эквивалент  непосредственной  адресации  для
8-битовых  чисел. Просто непосредственная адресация расширена
таким  образом,  чтобы  применяться  для  передачи 16-битовых
данных. 
         В  общем  случае  команды, обрабатывающие 16-битовые
числа,   длиннее   и   медленнее,   чем  предназначенные  для
8-битовsх.     Например,    если    8-битовые    команды    с
непосредственной  адресацией  имеют  длину  2 байта (один для
команды и один для числа), то расширенная версия (т.е. для 16
битов) требует трех байтов. 
         Формат  для  расширенной  непосредственной адресации
имеет вид: 

              БАЙТ 1     КОМАНДА
              БАЙТ 2     N1  МЛАДШИЙ БАЙТ ЧИСЛА
              БАЙТ 3     N2  СТАРШИЙ БАЙТ ЧИСЛА

         Мы   используем   этот  тип  адресации  команды  для
определения  содержимого пары регистров, например, в качестве
указателя на ячейку памяти. 

                    РЕГИСТРОВАЯ  АДРЕСАЦИЯ

         Вы, наверное, помните, что регистровой адресацией мы
называем  такую адресацию команды, при которой обрабатываемое
значение хранится в одном из регистров. 
         То же самое остается верным для 16-битовых команд за
исключением  того,  что  в  наборе  команд  ЦП  таких  команд
немного.  Они в основном относятся к арифметическим операциям
и очень ограничены в плане допустимых комбинаций регистров. 

                    Например,   ADD HL,DC

         Мы  здесь вновь отметим предпочтение, оказываемое ЦП
паре регистров HL, именно здесь проходит "мускул" и некоторые
команды   можно   выполнить   только   с  помощью  этой  пары
регистров.Это  верно  для арифметических команд. Подробнее мы
на этом остановимся в одной из следующих глав. 

               КОСВЕННАЯ РЕГИСТРОВАЯ АДРЕСАЦИЯ

         Косвенной  регистровой  адресацией мы называем такую
адресацию команды, при которой требуемое значение находится в
памяти, а адрес ячейкии памяти хранится в паре регистров. 
         В  Z80  этот  тип  адресации, опять-таки, в основном
используется с помощью пары регистров HL. 

                     Например,   JP (HL).

                    РАСШИРЕННАЯ  АДРЕСАЦИЯ

         Расширенная  адресация  по смыслу близка расширенной
косвенной  регистровой  адресации  за  исключением  того, что
нужное  значение хранится не в паре регистров, а в паре ячеек
памяти. 

                    Например,  LD HL,(NN)

где NN должно быть задано на стадии программирования. 

                          УПРАЖНЕНИЯ

         С  помощью  редактора  машинного  языка  в  коде  EZ
введите следующие программы: 
         1. Непосредственная расширенная адресация: 

         010F00   LD BC,1 5  :загрузить значение 15 в BC
         C9       RET        :возврат

         Когда   выполняется   эта   программа,  вы  обратите
внимание  на то, что значение USR после возврата из программы
на машинном языке равно 15, в точности как мы задали. 
         Обратите  внимание,  насколько  ограничен  этот  тип
адресации: вы должны задать значение числа в программе. 
         2.Регистровая адресация. 
         Теперь  мы добавим к приведенной выше программе одну
строчку: 

         210040   LD HL, 4000H   :загрузить  16384
         010F00   LD BC,15       :загрузить 15 в BC
         09      ADD HL,BC       :сложить эти два числа
         C9      RET             :возврат

         Если  вы  выполните  эту  программу, у вас все равно
получится  тот  же  ответ, что и раньше, а именно 15. Почему?
Разве мы не прибавили 16384? 
         Ответ  таков:  да, прибавили, но все это произошло в
паре  регистров HL, так что мы ничего этого не увидели. Чтобы
увидеть, что же произошло, нам нужно добавить несколько строк
следующим образом: 
         3.Расширенная адресация 

         210040     LD HL,4000H
         010F00     LD BC,15
         09        ADD HL,BC
         22647D     LD (7D64H),HL :поместить HL в 32100 и 32101
         ED48647D   LD BC,(7D64H) :взять значение для BC из 32100
                                   и 32101
         C9         RET

         Этот  способ передачи информации из HL в BC на самом
деле  не  применяется  в  программировании, поскольку команды
PUSH и POP более эффективны. Но он показывает, что приходится
иногда   делать,   чтобы   преодолеть  ограниченный  характер
способов адресации ЦП Z80. 
         Вы  можете просмотреть ячейки памяти 32100 и 32101 с
помощью команды MEM, чтобы проверить также и эту программу. 

                ОБРАБОТКА ЧИСЕЛ НА ДВУХ РУКАХ

         В   предшествующих   главах   мы  видели,  насколько
проворным  может быть ЦП при обработке чисел на одной руке, и
мы   только   что   рассмотрели   способ,  которым  он  может
обрабатывать числа для двух рук. 
         Математические  способности  ЦП таковы, что он может
выполнять  очень  сложные  вычисления  над большими числами с
помощью  всего  одной  руки.  Зачем  же  тогда беспокоиться о
числах для двух рук? 
         Вам  встретятся  случаи,  когда  вы  обнаружите, что
невозможно  задать  все  на  свете  с  помощью  одних  только
8-битовых  чисел.  Если  бы  мы  были ограничены одним только
диапазоном  от  0 до 255 8-битовых чисел, то наша ЭВМ была бы
очень ограниченной. 
         Наиболее  ярким  примером  необходимости  16-битовых
чисел  служит  задание адреса ячейки памяти. Мы предполагали,
что   такие  действия  возможны,  когда  рассматривали  такие
команды, как LD A,(HL). 
         Медленный  способ  действия  состоял бы в том, чтобы
загружать  каждый отдельный регистр из пары регистров, как мы
делали  в  предшествующих  упражнениях.  К  счастью  для нас,
имеются (хоть их и немного) команды чипа Z80, позволяющие нам
обрабатывать  16-битовые  числа.  В этой главе мы будем иметь
дело  с  загрузкой  16-битовых  чисел, а в следующей главе мы
рассмотрим арифметические действия над 16-битовыми числами. 

          ЗАДАНИЕ АДРЕСОВ С ПОМОЩЬЮ 16-БИТОВЫХ ЧИСЕЛ

         Обратите,   пожалуйста,  внимание,  что  все  адреса
задаются  с  помощью  16-битовых  чисел. Вы просто не сможете
задать  адрес  с  помощью  всего 8 битов,даже если этот адрес
лежит  в  диапазоне  от  0 до 255. В соответствии со способом
работы  ЦП  это  не  будет  адресом, поскольку в нем нет двух
байтов  по  8  битов  каждый.  Мы  подразумевали  это,  когда
использовали сокращенную запись: 

                          LD A,(NN)

так  что  помните также, что 16-битовые числа хранятся в паре
регистров  так,  что первым идет старший байт (посмотрите еще
раз  главу  "Заглянем  в  ЦП".  Здесь  HL означает: H = HIGHT
(старший), L = LOW (младший)). 

              ХРАНЕНИЕ 16-БИТОВЫХ ЧИСЕЛ В ПАМЯТИ

         Есть  один  аспект  конструкции  Z80,  который очень
трудно объяснить или оправдать: при загрузке 16-битовых чисел
в  память используется обратный порядок по сравнению с парами
регистров. Младший бит в памяти всегда хранится первым. 
         Давайте рассмотрим ситуацию, в которой мы помещаем в
память содержимое HL : 

            до того         ячейка      содержимое
                            32000          00
             H   L          32001          00
            01  02          32002          00

         Предположим,  что  в  HL содержится десятичное число
258=0102H. Все ячейки памяти пусты. 

            после           ячейка     содержимое
                            32000          02
             H    L         32001          01
            01   02         32002          00

         Порядок  хранения  16-битовых  чисел  в  памяти (и в
распечатке  программы) таков, что младший бит всегда хранится
в начале. 
