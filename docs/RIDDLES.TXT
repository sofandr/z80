
                         ТАЙНИКИ ZX-SPECTRUM
                            (C) 1992 СОЛОН


                              АННОТАЦИЯ

   Мало кому  нравятся программы,  которые при первой ошибке в ответе,
либо при нажатии клавиши <BREAK> очищают  всю  память  компьютера,  не
оставляя после себя никакого следа, либо "зависают", вынуждая нажимать
<RESET>. Ситуация перестает быть забавной, когда мы имеем какую-нибудь
программу,  которую  хотим  приспособить  для нетипового оборудования,
например, Joystick,  или хотим заменить  в  программе  все  английские
тексты на русские, а программу не удается остановить.
   В этом  описании  будет  последовательна  дана  информация  о вашем
компьютере,  необходимая при  такого  рода  работе,  такая  как  карта
памяти,  способ  записи  в  память  отдельных  строк BASIC,  отдельные
системные переменные и т.п.  Затем мы рассмотрим считывания программ и
блоков данных "безопасным способом", т.е. так, чтобы они не стартовали
автоматически и можно было бы просмотреть их содержимое,  в  конце  мы
займемся  обезвреживанием  предохранителей,  написанных  на внутреннем
языке.  Постараемся проиллюстрировать все это конкретными примерами на
известных программах.  Надеемся,  что наши усилия не пропадут зря и Вы
тоже научитесь добираться без препятствий к любой программе.

   Дорогу осилит идущий!


                       1. РАСПРЕДЕЛЕНИЕ ПАМЯТИ.

   В принципе память поделена на две особые части:  ROM  (ПЗУ)  и  RAM
(ОЗУ).  ROM  занимает адреса с 0...16383,  а RAM адреса 16384...65535.
Содержимым ROM мы сейчас заниматься  не  будем,  но  зато  внимательно
рассмотрим память  RAM.  Она поделена на блоки,  выполняющие различные
функции в системе BASIC.

  ╔═══════════════════════╗ --- 0
  ║          ROM          ║
  ╟───────────────────────╢ --- 16384
  ║     DISPLAY FILE      ║
  ╟───────────────────────╢ --- 22528
  ║         ATTR          ║
  ╟───────────────────────╢ --- 23296
  ║    Буфер принтера     ║
  ╟───────────────────────╢ --- 23552
  ║ Системные переменные  ║
  ╟───────────────────────╢ --- 23734
  ║   Карта микродрайва   ║
  ╟───────────────────────╢ --- 23734 [23631] CHANS
  ║ Информация о каналах  ║
  ╟───────────────────────╢
  ║          #80          ║
  ╟───────────────────────╢ --- 23755 [23635] PROG
  ║ Область системы BASIC ║
  ╟───────────────────────╢ --- 65368 [23730] RAMTOR
  ║          #3E          ║
  ╟───────────────────────╢ --- 63368 [23675] UDG
  ║ Графика, определяемая ║
  ║     пользователем     ║
  ╚═══════════════════════╝ --- 65535 [23732] P-RAMT

   Рис.1  Распределение памяти.


                             DISPLAY FILE

   Область, в которой хранится информация о том, включены или погашены
последовательные точки экрана. Это занимает 6144 байт.

                                 ATTR

   Эти 768  байт  (с  адреса  23558) определяют цвета последовательных
полей экрана (8 x 8 точек).

                            БУФЕР ПРИНТЕРА

   Эта область (от 23296 до 23551) используется лишь во  время  работы
компьютера  с принтером.  Если не используются инструкции,  касающиеся
принтера (LLIST,  LPRINT,  COPY),  то его содержимое не меняется и его
можно использовать для других целей. Помните только, что использование
какой-либо из  указанных  инструкций,  даже  без  включения  принтера,
произведет в этой области изменения.

                         СИСТЕМНЫЕ ПЕРЕМЕННЫЕ

   Эти ячейки памяти используются системой для запоминания необходимых
для ее безошибочной работы данных,  таких как,  например,  адреса  так
называемых подвижных блоков памяти,  информация о выполнении программы
в BASIC, т.е. какая строка выполняется, к которой должен осуществиться
переход, появились  ли  какие-нибудь  ошибки  и  т.п.  В  этой области
находятся переменные,  содержащие  код  последней   нажатой   клавиши,
продолжительность "BEEP"  клавиатуры и еще много других.  Подробней мы
займемся ими позднее.
   Непосредственно за   системными   переменными,   которые  кончаются
адресом 23733, начинаются так называемые подвижные области памяти. Это
означает,  что  адреса  их  начал  и  концов,  а  также  длина,  могут
изменяться в зависимости от того,  подключены ли какие-нибудь  внешние
устройства,  какова  длина  программы  на БЕЙСИКе,  сколько образуется
переменных.
   На рис.1  и  рис.2  число  за  стрелкой означает адрес указываемого
блока.  Если адрес перемещается,  то сначала указано значение, которое
присваивается  после  включения компьютера (или выполнения RESET),  но
без подключения внешних устройств,  а затем имя системной  переменной,
содержащей  этот  адрес.  В  квадратных  скобках  указан  адрес  самой
системной переменной, которая обычно состоит из двух байт.

                          КАРТА МИКРОДРАЙВА

   Если к вашему компьютеру подключен ZX  интерфейс  1,  то  с  адреса
23734  до  адреса на единицу меньше,  чем содержимое переменной CHANS,
находится карта микродрайва -  область,  используемая  как  буфер  для
трансляции данных,  как  набор  добавочных системных переменных и т.п.
Если интерфейс не подключен,  то эта область попросту не существует  -
переменная CHANS  содержит  адрес  23734.  Она определяет начало блока
памяти, в котором содержатся данные о существующих каналах.

                         ИНФОРМАЦИЯ О КАНАЛАХ

   Необходима для безошибочного  выполнения  инструкций  PRINT,  LIST,
INPUT  и им подобных.  В последней ячейке этой области находится число
#80 (128), определяющее конец этого блока (это т. н. указатель конца).

                           ОБЛАСТЬ БЕЙСИКА

   Эта область памяти содержит текст введенной программы  на  БЕЙСИКе.
Адрес начала хранится  в переменной PROG.  Сразу  за текстом программы
(с адреса,  указываемого переменной VARG) находится область в  которой
интерпретатор размещает   переменные,   создаваемые   программой.  Она
заканчивается указателем конца.  Затем, начиная с адреса содержащегося
в  переменной   E-LINE  находится   область,  используемая   во  время
редактирования строка БЕЙСИКа,  а также ввода  директив  с  клавиатуры
(т.е. когда  в  нижней  части  мигает курсор и мы вводим инструкцию на
БЕЙСИКе). В конце этой области находятся два байта  с  содержимым:  13
("ENTER") и  128  (конец  области).  Сразу  после,  начиная  с адреса,
указываемого системной переменной WORKSP,  находится подобная область,
но завершающаяся   знаком   "ENTER",   за   буфером   INPUT   (который
автоматически удаляется после выполнения  этой  инструкции)  находится
"текущее рабочее пространство" - место памяти,  используемое для самых
различных целей.  Туда, между прочим, помещаются заголовки считанных с
лент программ.  Туда  считывается  программа,  размещаемая  в памяти с
помощью MERGE,  прежде  чем  будет  присоединена  к  уже  существующей
программе. Эта   область   используется   тогда,  когда  требуется  на
определенное время немного свободной памяти, но не только на временное
пользование.
   Однако, системе  БЕЙСИКа  принадлежит  область  памяти  до  ячейки,
указываемой  системной  переменной  RAMTOR.  По этому адресу находится
число #3E (62),  которое  устанавливает  конец  используемой  БЕЙСИКом
области.   Двигаясь   по   памяти  "вниз",  мы  сталкиваемся  с  одним
неиспользуемым байтом (это байт является младшим байтом  двухбайтового
числа, старший байт которого всегда равен 256), необходимым для верной
инструкции RETURN.  Если во время ее выполнения стек GOSUB  будет  уже
пусто, то  это  число  сыграет  роль его продолжения.  Но поскольку он
больше, чем 15872 (62*256), а строки БЕЙСИКа не имеют такой нумерации,
то это  будет  восприниматься  как ошибка и сигнализировать сообщением
"RETURN without GOSUB".  Сразу после этого байта (двигаясь  "вниз"  по
памяти) начинается  "стек GOSUB".  В него заносятся номера программных
строк из которых были выполнены инструкции  перехода  к  подпрограмме,
чтобы интерпретатор  знал  точно,  куда  должна  вернуться  инструкция
"RETURN". Если интерпретатор не находился  в  программе,  вызванной  с
помощью GOSUB, то этот стек попросту не существует - в нем не записано
ни одного значения.  Ниже находится "машинный  стек",  непосредственно
используемый микропроцессором.  Оба этих стека откладываются в сторону
уменьшения памяти.
   Специальную роль  играет  системная  переменная  ERRSP.  Процедура,
обрабатывающая ошибку БЕЙСИКа (вызывается командой процессора RST  8),
помещает значение этой переменной в регистр SP, после чего выполняется
RET, считывая таким путем последний записанный в стек адрес (во  время
выполнения программы он равен обычно 4867). Под этим адресом находится
процедура выводящая сообщение об ошибке.

  ╔════════════════════════╗ --- 23735 [23635] PROG
  ║  Программа на БЕЙСИКе  ║
  ╟────────────────────────╢ ---  * *  [23627] VARS
  ║   Переменные БЕЙСИКа   ║
  ╟────────────────────────╢
  ║          #80           ║
  ╟────────────────────────╢ ---  * *  [23641] E-LINE
  ║ Область редактирования ║
  ║         строки         ║
  ╟────────────────────────╢
  ║          #0D           ║
  ╟────────────────────────╢
  ║          #80           ║
  ╟────────────────────────╢ ---  * *  [23649] WORKSP
  ║      Буфер INPUT       ║
  ╟────────────────────────╢
  ║          #0D           ║
  ╟────────────────────────╢
  ║    Текущая область     ║
  ╟────────────────────────╢ ---  * *  [23651] STKBOT
  ║   Стек калькулятора    ║
  ╟────────────────────────╢ ---  * *  [23653] STKEND
  ║        Свободно        ║
  ╟────────────────────────╢ --- Значение в регистровой паре SP
  ║     Машинный стек      ║
  ╟────────────────────────╢ ---  * *  [23613] ERRSP
  ║       Стек GOSUB       ║
  ╟────────────────────────╢
  ║         1 байт         ║
  ╚════════════════════════╝ --- 65367 [23730] RAMTOR

   Рис.2  Область памяти системы BASIC.


                 ГРАФИКА, ОПРЕДЕЛЯЕМАЯ ПОЛЬЗОВАТЕЛЕМ

   168 байт,  зарезервированных для определения знаков UDG  (их  можно
ликвидировать, например, с помощью CLEAR 65535, адрес последней ячейки
памяти (обычно равной 65535) запоминается в  переменной  P-RAMT.  Если
часть  памяти  повреждена,  то эта переменная содержит адрес последней
исправной ячейки.


         2. СТРУКТУРА ЗАГОЛОВКОВ. ОТМЕНА АВТОСТАРТА ПРОГРАММ.

   Помните, что  практически  каждая  программа  имеет  хотя  бы  одну
процедуру - загрузчик,  написанную на БЕЙСИКе,  а если  не  имеет,  то
вообще не защищена.
   Начнем со способа записи на магнитную ленту программ  -  припомним,
что видно и слышно во время считывания какой-либо программы: в течение
1-2 секунд на экране видны широкие красно-синие полосы, а также слышен
длительный звук.   Это   так  называемый  "пилот",  который  позволяет
компьютеру синхронизироваться  с  сигналом  ленты,  которую  он  будет
считывать. Потом     на    момент    появляются    тонкие    мерцающие
желто-фиолетовые полоски,  свидетельствующие  о  том,  что   компьютер
считывает в  память  информацию.  Её  17  байт  -  это  так называемый
заголовок. Появляется надпись  "Bytes:",  "Program:",  "Number array:"
или "Character  array:",  потом после секундного перерыва,  начинается
второй пилот (более короткий),  а после  него  считывается  собственно
программа.
   Займемся теперь заголовками,  так как в  них  содержатся  важнейшие
данные о считываемых программах.
   Заголовок содержит 17 байт. Пронумеруем их от 0 до 16 (см. рис.3).
   Нулевой байт означает тип блока. Он равен:
   0 - если это программа на БЕЙСИКе;
   1 - если это числовой массив;
   2 - если это символьный массив;
   3 - если это блок машинного кода.
   Следующие 10 байт - это имя считываемого блока, т.е. текст, который
появляется после загрузки заголовка за надписью:  "Program:", "Bytes:"
и т.д.
   Байты 11  и  12  содержат двухбайтовое число (первый байт младший),
определяющее длину блока,  к которому относится  данный  заголовок.  В
зависимости  от считываемого блока,  байты с 13 по 16 интерпретируются
по разному. Начнем с заголовка программ, написанных на БЕЙСИКе.
   Байты 13 и 14 содержат номер строки старта программы, если она была
записана с помощью SAVE "..." LINE NR.  Если программа  была  записана
без операции  LINE  и  после считывания не стартует автоматически,  то
значение этого числа больше 32767.  Одним  из  способов  нейтрализации
защиты самостартующих  программ  на  БЕЙСИКе  является замена этих 2-х
байтов на число большее 32767.
   Байты 15 и 16 содержат число, определяющее длину самой программы на
БЕЙСИКе, т.к.  SAVE "..." или SAVE "..." LINE записывает программу  со
всеми переменными,   т.е.   содержимое  памяти  от  байта,  указанного
системной переменной PROG,  до байта, определяемого переменной E-LINE.
Если от всей длины блока (байты 11 и 12) отнимем это число,  то узнаем
сколько байтов в этом блоке занимают переменные БЕЙСИКа. Это все, если
речь идет о заголовках программ на БЕЙСИКе.
   В заголовках  машинного  кода  ("BYTES")   байты   15   и   16   не
используются, зато 13 и 14 составляют двухбайтовое число, определяющее
по какому адресу надо считать следующий за заголовком блок.
   В заголовках  массивов их этих 4-х байтов используется только 14-ый
байт, который представляет имя считываемого массива.  Он записан также
как имена всех переменных БЕЙСИКа (в области от VARS до E-LINE),  т.е.
три самых старших бита означают тип переменной (здесь это числовой или
знаковый массив), а 5 младших битов - имя переменной.

  ╔═════════╤═══════════╤══════════════════════════════════════════╗
  ║  0      │ Тип блока │ 0 - Program (программа);                 ║
  ║         │           │ 1 - Number array (числовой массив);      ║
  ║         │           │ 2 - Character array (символьный массив); ║
  ║         │           │ 3 - Bytes (машинные коды).               ║
  ╟─────────┼───────────┴──────────────────────────────────────────╢
  ║  1 - 10 │ Имя                                                  ║
  ╟─────────┼───────────┬──────────────────────────────────────────╢
  ║ 11 - 12 │ Длина     │ Сколько байт необходимо считать с ленты. ║
  ╟─────────┼───────────┼──────────────────────────────────────────╢
  ║ 13 - 14 │ Старт     │ Program: Адрес загрузки блока;           ║
  ║         │           │ Array:   Номер строки старта программы;  ║
  ║         │           │ Bytes:   Байт 14 - имя переменной;       ║
  ║         │           │          Байт 15 - значения не имеет.    ║
  ╟─────────┼───────────┼──────────────────────────────────────────╢
  ║ 15 - 16 │ Программа │ Program: Длина программы на Бейсике      ║
  ║         │           │          (без переменных);               ║
  ║         │           │ Bytes:   Не используется;                ║
  ║         │           │ Array:   Не используется.                ║
  ╚═════════╧═══════════╧══════════════════════════════════════════╝

   Рис.3  Таблица значений байтов заголовка.

   На Листинге  1  представлена  программа,   реализующая   процедуру,
делающую возможным чтение заголовков программы.  Внимательно проверьте
количество пробелов  в  строках  с  инструкциями  DATA,  запустите  её
командой  RUN  и  подождите минутку.  На экране появится информация об
адресах начала и конца процедуры,  а также о её длине,  которая должна
составлять  284  байта.  Если  не  так,  то  проверьте  все  ли строки
программы введены без ошибок.  Если все правильно,  то на вашей  ленте
окажется  процедура "ЧТЕНИЕ ЗАГОЛОВКОВ",  благодаря которой вы сможете
прочесть каждый заголовок.  После записи на ленту, её можно удалить из
памяти. Процедура   "ЧТЕНИЕ   ЗАГОЛОВКОВ"  будет  работать  правильно,
независимого от того по  какому  адресу  она  будет  загружена.  Можно
считать её: LOAD "имя блока кодов" CODE адрес, а затем запустить (даже
многократно) с помощью: RANDOMIZE USR адрес.
   После запуска  процедура считывает по адресу 23296 (буфер принтера)
первый встреченный  ею  заголовок.  Если  из-за  подключенных  внешних
устройств этот адрес вас не устраивает,  можно сменить его,  заменив в
строке 200  Листинга  1  число  #005B  шестнадцатиричным  адресом,  по
которому вы  хотели  бы  считать  заголовок (две первые цифры являются
младшим байтом  этого  адреса).  Чтобы  после  этой  замены   избежать
проверки контрольной  суммы в этой строке,  в конце текста,  взятого в
кавычки вместо пробела и 4-х цифр контрольной  суммы  нужно  поместить
литеру "S" с четырьмя ведущими пробелами.
   После считывания заголовка процедура считывает  заключенную  в  нем
информацию и возвращается в БЕЙСИК, но считанного блока не уничтожает,
следовательно, если желаете посмотреть его дополнительно, то можно это
сделать  использую функцию PEEK.
   Однако чтения заголовка мало,  чтобы взломать блоки,  записанные на
ленте. Необходимо знать,  что еще надо сделать с этими блоками,  чтобы
разместить их в памяти, не позволяя при этом начать работу.
    В случае блоков типа "BYTES" достаточно,  обычно, загрузить их под
принудительный адрес выше RAMTOR (т.е. выше ячейки памяти, указываемой
переменной RAMTOR), например: CLEAR 29999: LOAD "" CODE 30000.
   Этот метод работает,  если считываемый блок не очень длинный (может
быть  максимально  до  40K).  Более  длинные  блоки  могут  просто  не
разместиться в памяти - тогда необходимо  их  разделить  на  несколько
коротких частей.  Скоро  мы  узнаем как это сделать.  Также и в случае
массивов их загрузка не вызывает затруднений  -  достаточно  применить
обычную в таких ситуациях инструкцию LOAD "" DATA ...
   Хуже выглядит  считывание   программ   не   БЕЙСИКе.   Они   обычно
записываются с  помощью  SAVE  "..." LINE ..,а в самом начале строка с
которой должны  выполняться  инструкции,  закрывающие   программу   от
останова. Простейшим решением является загрузка программы не с помощью
LOAD "",  а с  помощью  MERGE  "",  но  этот  способ  не  всегда  дает
результат. Из  этой  безнадежной  ситуации есть два выхода:  подменить
заголовок программы или использовать  предоставленную  ниже  программу
"LOAD/MERGE". Первый  способ  основан  на  замене записанного на ленте
заголовка программы  на  такой  же,  но  не   вызывающий   самозапуска
программы. Можно  с  этой  целью  использовать  программу "COPY-COPY",
считать, заменить  параметр  СТАРТ  на  число  большее   32767   (т.е.
выполнить, например,  LET  1=32768,  если корректируемый таким образом
заголовок был считан как первый набор). Модифицированный таким образом
заголовок записываем где-нибудь на ленте.  Убираем из памяти программу
"COPY-COPY" и вводим LOAD "". Считываем только что сделанный заголовок
и после   его  окончания  останавливаем  ленту.  Теперь  в  магнитофон
вставляем кассету с программой  -  так,  чтобы  считать  только  текст
программы без ее заголовка.
   Другой способ выгоднее.  Вводим в память (с клавиатуры  или  ленты)
программу "LOAD/MERGE",  размещенную на Листинге 2.  После запуска она
начинает ждать первую  программу  на  БЕЙСИКе,  которая  находится  на
ленте, считывает  ее  совершенно  также как инструкция LOAD,  но после
загрузки не позволяет программе запуститься,  выводит сообщение "0 OK"
с информацией   с   какой   строки  считанная  программа  должна  была
стартовать.

                          ЛИСТИНГИ ПРОГРАММ:

   Листинг 1. Программа чтения заголовков.

   10 CLEAR 59999: LET POCZ=60000
   20 LET ADR=POCZ
   30 RESTORE: READ A,B,C,D,E,F
   40 DATA 10,11,12,13,14,15
   50 LET NR=200: RESTORE NR
   60 LET S=0: READ A$: IF A$="." THEN GOTO 130
   70 FOR N=1 TO LEN A$-5 STEP 2
   80 LET LET W=16*VAL A$(N)+A$(N+1)
   90 POKE ADR,W: LET ADR=ADR+1: LET S=S+W
  100 NEXT N
  110 IF VAL A$(N)<>S THEN PRINT "OSN.W STROK ";NR: STOP
  120 LET NR=NR+1: GOTO 60
  130 PRINT "VSE DANNYE HOROSHO"''"NACHALO: ";POCZ'
      "KONEC: ";ADR-1'"DLINA: ";ADR-POCZ
  140 SAVE "CZYTACZ" CODE POCZ,ADR-POCZ
  150 REM DANNYE
  200 DATA "21920009E5DD21005BDDE51111  1246"
  210 DATA "00AF37CD5605DDE130F23E02CD  1531"
  220 DATA "011611C009DD7E00CD0A0CDDE5  1265"
  230 DATA "D113010A00CD3C202A7B5CD1E5  1231"
  240 DATA "D5ED537B5C010900CD3C20DD46  1346"
  250 DATA "0CDD4EDBCD2B2DCDE32DE1DD7E  1872"
  260 DATA "00DD460EDD4E0DC5A7202BEB01  1292"
  270 DATA "1900CD3C20D5DD4610DD4E0FCD  1361"
  280 DATA "2B2DCDE32DD1C178E6C0206EC5  1848"
  290 DATA "011300CD3C20C1CD2B2DCDE32D  1280"
  300 DATA "185EFE03203601700009EB0111   836"
  310 DATA "0018E60D449C75676F9D9B2073  1281"
  320 DATA "616D65676F2070726F6772616D  1313"
  330 DATA "75200D4175747F737461727420  1161"
  340 DATA "2D206C696E69120D2EE1BB0181  1239"
  350 DATA "0009EB010900CD3C20C13E1FA0   997"
  360 DATA "F660D7DD7E003D28033E24D73E  1383"
  370 DATA "28D73E29D7E1227B5C3E0DD7C9  1538"
  380 DATA "04081C2020201C000010181030   268"
  390 DATA "100C0008103840380478000D41   430"
  400 DATA "64726573209C61646F77616E69  1357"
  410 DATA "61200D5461626C69636120       862"
  420 DATA "."


   Листинг 2. Программа LOAD/MERGE.

   10 REM LOAD/MERGE TS&RD 1987
   20 FOR N=60000 TO 60025: READ A: POKE N,A: NEXT N
   30 RANDOMIZE USR 60000
   40 DATA 1,34,0,247,213,221,225,253,54,58,1,221,54,1,225,
           205,29,7,42,66,92,34,69,92,207,255


   Листинг 3. Программа LOAD/MERGE (ассемблер).

   ORG 60000
   LD BC,34
   RST 48
   PUSH DE
   POP IX
   LD (IY+58),1
   LD (IX+1),255
   CALL 1821
   LD HL,(23618)
   LD (23621),HL
   RST 8
   DEFB 255


                    3. ЗАЩИТА ПРОГРАММ НА БЕЙСИКЕ.

   Прочитанная программа,  как правило, не должна выглядеть нормально.
Например,  в  программе есть строка с номером 0 или строки упорядочены
по убыванию номеров.  Нельзя вызвать EDIT ни для какой  строки,  видно
подозрительную  инструкцию RANDOMIZE USR 0 или просто ничего не видно,
т.к.  программа не позволяет листать себя.  Если в программе,  куда вы
вламываетесь,  вы увидели что-то необычное,  то лучше просматривать ее
другим способом,  несколько отличающимся от обычного -  не  с  помощью
LIST,  а непосредственно,  используя функцию PEEK,  однако, сначала мы
должны узнать каким образом  размещен  в  памяти  текст  программы  на
БЕЙСИКе.  Программа  складывается  из  последовательных  строк и так и
хранится в памяти.
   Отдельная строчка программы выглядит так: (см.рис.4)

    MSB      LSB   LSB              MSB
  ┌──────────────┬──────────────────────┬──────────────┬───────┐
  │   2 байта    │       2 байта        │      ...     │  #0D  │
  └──────────────┴──────────────────────┴──────────────┴───────┘
    Номер строки   Длина строки + ENTER   Текст строки   ENTER

   Рис.4  Структура строки БЕЙСИКа.

   Она занимает не менее 6 (т.к. текст пустым быть не может) байт. Два
первых означают ее номер.  Но он записан наоборот,  в отличие от  всех
обычных 2-байтовых чисел, хранимых в памяти (MSB - старший байт, LSB -
младший байт).
   Следующие 2   байта   -  это  длина  строки,  т.е.  число  символов
содержащихся в строке вместе с завершающим ее знаком "ENTER" (#0D). За
этими байтами находится текст строки, заканчиваемый "ENTER".
   Если введем, к примеру, такую строку:
   10 REM BASIC
   и запишем ее, нажав клавишу <ENTER>, то она будет записана в память
как последовательность байт: (см.рис.5)

  ╔══╤══╦══╤══╦═══╤══╤══╤══╤══╤══╦══╗
  ║ 0│10║ 7│ 0║243│66│65│83│73│67║13║
  ╟──┴──╫──┴──╫───┼──┼──┼──┼──┼──╫──╢
  ║ <10>║ <7> ║REM│ B│ A│ S│ I│ C║  ║
  ╚═════╩═════╩═══╧══╧══╧══╧══╧══╩══╝

   Рис.5  Пример записи символов в строке БЕЙСИКа.

   Параметр "Длина  строки"  касается только ее текста,  следовательно
хотя строка занимает в памяти 11 байт,  этот параметр указывает только
на 7 байт: 6 байт текста и 1 байт "ENTER", заканчивающий строку.
   Вам, наверное, уже понятно на чем основан часто применяемый трюк со
строкой,  имеющей  нулевой номер.  Достаточно в первые 2 байта занести
число 0 (с помощью POKE), чтобы эта строка стала нулевой строкой. Если
мы хотим  изменить  номер  первой  строки  в программе (а к интерфейсу
никакая быстрая память не подключена,  т.к.  в этом случае  изменяется
адрес начала БЕЙСИКа), то достаточно написать:
   POKE 23755,X: POKE 23756,Y
   и строка получит номер 256*X+Y.  Не зависимо от его значения строка
останется в памяти там, где была. Если введем:
   10 REM LINE 10
   20 REM LINE 20
   POKE 23755,0: POKE 23756,30
   то первой строке в  программе  будет  присвоен  номер  30,  но  она
останется в памяти как первая, а на экране мы получим вид:
   30 REM LINE 10
   20 REM LINE 20
   следовательно, чтобы начать  разблокировать  программу,  в  которой
имеются нулевые строки или строки,  упорядоченные по убыванию номеров,
следует найти  адрес  каждой  строки  и  в  их  поле  "НОМЕР   СТРОКИ"
последовательно размещать   к  примеру:  10,  20...  В  памяти  строки
располагаются одна за другой, следовательно с обнаружением их начал вы
не будете  иметь  трудностей.  Если  X  указывает  адрес  какой-нибудь
программной строки, то следующий адрес равен:
   X+PEEK (X+2)+256*PEEK (X+3)+4
   т.е. к адресу строки добавляется длина ее текста,  увеличенная на 4
байта, т.к.  именно столько занимают параметры "НОМЕР СТРОКИ" и "ДЛИНА
СТРОКИ".
   Такой способ  нахождения  строк  не действует,  к сожалению,  когда
применяется другой способ защиты - фальшивая длина строки.  Он основан
на  том,  что  в поле "ДЛИНА СТРОКИ" вместо настоящего значения дается
очень большое число - порядка 65 тысяч.  Этот способ применяется очень
часто,  т.к.  обычно делает невозможным считывание программы с помощью
MERGE (т.е.  без самостарта). Делается это потому, что MERGE загружает
программу в  область WORKSPACE,  а затем интерпретатор анализирует всю
считанную программу строка за строкой: последовательно проверяет номер
каждой из  них,  а затем размещает ее в соответствующем месте области,
предназначенной для текста  программы  на  БЕЙСИКе.  Для  этой  строки
необходимо там подготовить соответствующее количество сободных байтов,
"раздвигая" уже существующий  текст  программы.  Если  в  поле  "ДЛИНА
СТРОКИ" стоит очень большое число, то интерпретатор старается выделить
именно столько байтов пространства в области  текстов  программы,  что
завершится сообщением  "OUT  OF MEMORY" или просто зависанием системы.
Чтобы прочесть такую  программу  не  вызывая  ее  самозапуск,  следует
применить соответствующую отмычку,  например, такую как представленная
на листигах 2 и 3 программа "LOAD/MERGE".  Дополнительным эффектом  от
применения фальшивой  длины  является  невозможность  в  корректировки
такой строки путем занесения ее в поле.  Это требует слишком  большого
количества памяти,  следовательно  кончается  только предупредительным
сигналом.
   Если программа  защищена таким способом,  то адреса очередных строк
приходиться искать в ручную или догадываться,  где  находятся,  помня,
что  каждая строка заканчивается знаком "ENTER" (но не каждое число 13
означает "ENTER").  Чтобы посмотреть  программу  на  БЕЙСИКе,  введите
такую строку:
   FOR N=23755 TO PEEK 23627+256*PEEK 23628:
   PRINT N;" ";PEEK N;CHR$ PEEK N AND PEEK 31:
   NEXT N
   Она последовательно  высветит:  адрес,  содержимое  ячейки  с  этим
адресом, а  также  символ,  имеющий  этот  код,  если  это  только  не
управляющий символ (т.е. с кодом от 0 до 31).
   После смены  нумерации  строк  и  изменения  их  длины,   следующим
способом защиты программ являются управляющие символы,  не позволяющие
последовательно просматривать программу, хотя и не только это.
   Вернемся к первому примеру (рис.5).  Текст строки складывается из 7
символов - ключевого слова REM (все  ключевые  слова  -  инструкции  и
функции, а  также  знаки  <=,  >=  и  <>  имеют  однобайтовые  коды из
диапазона 165...255. Если вы их не знаете, то введите:
   FOR N=165 TO 255: PRINT N,CHR$ N: NEXT N
   и ознакомьтесь),  а также пяти литер и символа "ENTER".  Так бывает
всегда,  если в строке находится инструкция REM - все знаки, введенные
с клавиатуры после этой  инструкции,  будут  размещены  в  памяти  без
малейших изменений.  Иначе выглядит ситуация, когда в строке находятся
инструкции,  требующие числовых  параметров  (обычно  так  и  бывает).
Введем, к примеру, строку:
   10 PLOT 10,9
   и посмотрим,  каким  образом  на  запишется  в  память (лучше вводя
переменную выше строки N=23755 TO...).  Выглядит она так, как показано
на рисунке 6.

  ╔══╤══╦══╤══╦════╤══╤══╤══╤═╤═╤══╤═╤═╤══╤══╤══╤═╤═╤═╤═╤═╦══╗
  ║ 0│10║18│ 0║ 246│49│48│14│0│0│10│0│0│44│57│14│0│0│9│0│0║13║
  ╟──┴──╫──┴──╫────┼──┼──┼──┴─┴─┴──┴─┴─┼──┼──┼──┴─┴─┴─┴─┴─╫──╢
  ║ <10>║ <18>║PLOT│ 1│ 0│     <10>    │ ,│ 9│     <9>    ║  ║
  ╚═════╩═════╩════╧══╧══╧═════════════╧══╧══╧════════════╩══╝

   Рис.6  Пример записи чисел в строке БЕЙСИКа.

   Как видно,  текст был модифицирован - после последней цифры каждого
числа, выступающего в тексте строки как параметр, интерпретатор сделал
6  байтов  пространства  и  поместил там символ с кодом 14,  а также 5
байтов, в которых записано значение этого числа, но способом, понятным
интерпретатору.   Это   убыстряет,  определенным  образом,  выполнение
программ на БЕЙСИКе,  т.к. во время выполнения интерпретатор не должен
каждый раз   переводить  числа  из  алфавитно-цифрового  представления
(последовательности цифр) на пятибайтовое представление, пригодное для
вычислений. Готовое  значение  выбирается из памяти из-за управляющего
символа CHR$ 14.  Эта  странная  запись  дает  большие  возможности  в
БЕЙСИКе в   деле   затруднения   доступа   к   программам.  Во  многих
программах-загрузчиках (Loader) присутствует такая строка:
   0 RANDOMIZE USR 0: REM...
   На первый взгляд эта программа после  запуска  должна  стереть  всю
память, но так, однако, не происходит.
   После более внимательного просмотра (с помощью PEEK  -  строка  FOR
N=23755...) оказывается, после USR 0 и символа CHR$ 14 совсем нет пяти
нулей (именно так выглядит в пятибайтовой записи число  0).  Если  это
целое число, то в пятибайтовой записи оно выглядит:
   байт 1     - 0;
   байт 2     - 0 (для +) и 255 (для -);
   байт 3 и 4 - последовательно младший и старший;
   байт 5     - 0.
   К примеру 0,0,218,92,0,  это равнозначно числу 23770. Функция USR 0
не осуществляется, и тогда идет переход по адресу 23770, а это как раз
адрес байта после инструкции REM в нашем примере. Там обычно находится
программа-загрузчик, написанная на машинном языке.


                  4. "ЗАЩИТНЫЕ" УПРАВЛЯЮЩИЕ СИМВОЛЫ.

   В этом  и  последующем  разделах  мы  познакомимся  с  управляющими
символами.  Четыре  из  них  касаются изменения места вывода,  шесть -
смены атрибутов.

                       CHR$ 6 - "COMMA CONTROL"

   Этот символ  (управляющая  запятая)  действует  также  ка  запятая,
отделяющая тексты  в инструкции PRINT,  т.е.  выводит столько пробелов
(но всегда не менее одного), чтобы оказаться в колонке 0 или 16:
   PRINT "1","2"
   а также
   PRINT "1"+CHR$ 6+"2"
   имеют идентичное значение.

                 CHR$ 8 - "BACKSPACE" (пробел назад)

   Высвечивание этого символа вызывает сдвиг  позиции  ввода  на  одну
позицию влево,  следовательно, с его помощью можно закрывать некоторые
позиции на листинге, печатая на их месте другой текст, если, например,
в памяти находятся знаки:
   LET A=USR 0: REM <<<<<<<<<<<<<<<<
   LOAD "": ...
   (< обозначает CHR$ 8),  то инструкция LOAD "" и  последующий  текст
закроет инструкцию LET A=USR 0:  REM ... Хотя на листинге теперь видна
только инструкция  LOAD  "",  но  дальнейшая   часть   программы   уже
загружается не ею,  а машинной программой, запускаемой инструкцией USR
(что очевидно,  не должно осуществлять  переход  к  адресу  0).  Такая
защита, например, применяется в загрузчике программы BETA BASIC 1.0.

                         CHR$ 22 - "AT CTRL"

   Этот символ  (AT управляющий) позволяет переносить позиции вывода в
любое место экрана также, как AT в инструкции PRINT. После этого знака
должны появиться два байта, определяющие номер строки и номер колонки,
в которой должен быть расположен следующий знак:
   PRINT AT 10,7,"!"
   равнозначно
   PRINT CHR$ 22; CHR$ 10; CHR$ 7;"!".
   Чтобы убедиться  как  с  помощью  этого  символа  делать   листинги
программ невидимыми, введите, например:
   10 RANDOMIZE USR 30000: REM YOU CAN SEE NOTHING!
   После инструкции REM введите три пробела,  а после восклицательного
знака две управляющие запятые.  Их можно  получить  непосредственно  с
клавиатуры,  нажимая  последовательно  клавиши  <EXTEND MODE> (или два
<SHIFT>'а вместе),  чтобы получить курсор "E",  а  затем  клавишу  "6"
(курсор  сменит  цвет  на  желтый)  и  <DELETE>  (курсор  перескочит к
ближайшей половине экрана).  После ввода этой строки замените три этих
пробела  на знак AT 0,0 с помощью команд POKE 23774,22:  POKE 23775,0:
POKE 23776,0.
   Теперь просмотрим  программу.  На  экране  не  появится  текст всей
строки - ее начальная часть будет закрыта надписью,  находящейся после
инструкции REM  и  знака  AT  CTRL.  Такие  же трудности возникают при
переносе строки в зону редактирования (по клавише <EDIT>).
   Координаты, заданные  в  символе  AT  CTRL  должны находится в поле
экрана, т.к.  номер строки не может быть больше 21, а номер колонки не
больше 31.  Задание  больших  значений  в  случае использования команд
PRINT или LIST вызывает сообщение "OUT OF SCREEN" и отмену дальнейшего
вывода, если  же  листинг  получен  нажатием  <ENTER>  (автоматический
листинг) - также наступит  прекращение  дальнейшего  вывода,  а  кроме
того, в  нижней  части  экрана появится мигающий знак вопроса - сигнал
ошибки. Следовательно,  это  способ   защиты   от   просмотра   текста
практически каждой программы.

                         CHR$ 23 - "TAB CTRL"

   После этого  символа  (горизонтальная табуляция) следует два байта,
определяющие номер колонки,  в которую переносится позиция вывода. Они
трактуются  как  одно  двухбайтовое  число  (первый  байт  - младший).
Поскольку колонок только 32,  то число берется по модулю 32,  т.е. три
старших бита младшего байта игнорируются. Второй существенной стороной
является то,  что TAB переносит позицию вывода с  помощью  пробелов  -
также как   и   управляющая   запятая,  и  следовательно,  может  быть
использован для закрывания уже находящихся на экране текстов.


                     5. СИМВОЛЫ СМЕНЫ АТРИБУТОВ.

   Эту группу   управляющих   символов  составляют  символы,  меняющие
атрибуты:
   CHR$ 16 - INK CTRL
   CHR$ 17 - PAPER CTRL
   CHR$ 18 - FLASH CTRL
   CHR$ 19 - BRIGHT CTRL
   CHR$ 20 - INVERSE CTRL
   CHR$ 21 - OVER CTRL
   После каждого  из этих символов обязателен один байт,  уточняющий о
каком атрибуте идет речь,  после символов INK и PAPER это  могут  быть
числа 0...9,  после FLASH и BRIGHT 0, 1, 8 после INVERSE и OVER 0 и 1.
Задание других  значений  вызывает  сообщение:  "INVALID  COLOUR"   и,
естественно, прерывание просмотра программы.
   Высвечивая программу,  защищенную  управляющими  символами  цветов,
принимаем  для  себя следующую последовательность действий.  Например,
если просматривая текст программы мы встречаем код знака  PAPER  CTRL,
то заносим в его второй байт значение 0, если INK CTRL - значение 7, в
остальные управляющие  цветами  символы  -  значение  0.  Кроме  того,
удаляем  все  знаки BACK SPACE (CHR$ 8) путем их замены пробелами т.е.
(CHR$ 32).  Также ликвидируем знаки AT CTRL - заменяем с помощью  POKE
три  байта символа на пробелы.  После такой корректуры программу можно
уже листать без всяких сложностей.
   Если вы   хотите   взломать   программу  -  загрузчик,  то  его  не
обязательно и в принципе не надо  очищать  -  важно  узнать,  что  эта
программа делает,   каким  образом  загружает  в  память  и  запускает
следующие блоки,  а не стараться,  чтобы она  делала  "ЛАДНО"  и  была
написана прозрачно.  Это  тем более важно,  пока не узнаете программу,
лучше не  делать  в  ней  никаких  изменений  -  одна  ловушка   может
проверяться другой,  поэтому  наилучший  способ раскалывания программы
это анализ ее работы шаг за  шагом,  считывая  последовательные  байты
памяти:
   FOR N=23755 TO PEEK 23627+256*PEEK 23628:  PRINT N;"";PEEK N;  CHR$
PEEK N AND PEEK>31: NEXT N
   Помните о правильной интерпретации очередных  байтов:  сначала  два
байта номера  строки,  потом  два  байта  содержания ее длины (которая
может быть фальшивой),  затем  текст:  инструкция  БЕЙСИКа,  потом  ее
параметры. За  каждым  числом  записывается  CHR$  14  и  пять байтов?
содержащих значение этого числа за параметрами - двоеточие и следующая
инструкция или ENTER и новая строка программы.
   Это было бы все,  если речь идет об управляющих символах,  но  есть
одна   вещь,   которую   требуется   объяснить,   чтобы  вы  не  имели
неприятностей с чтением БЕЙСИКа.  Речь  идет  об  инструкции  DEF  FN.
Введите, а затем внимательно просмотрите такую строку:
   10 DEF FN A(A,B$,C)=A+C
   Кажется, что она должна занимать в памяти 19 байт (номер строки, ее
длина,  ENTER,  а  также  14  введенных  символов),  но  это  не  так.
Интерпретатор  после каждого параметра функции поместил знак CHR$ 14 и
дорезервировал зачем-то следом еще пять байт. Введите:
   PRINT FN A(1,"125",2)
   и снова просмотрите содержимое памяти с адреса 23755. После первого
параметра в определении функции далее находится CHR$ 14, но после него
последовательно расположились:  0,  0,  1,  0,  0, что в памяти байтов
записи обозначает 1.  Также после третьего параметра функции находится
CHR$ 14  и  байты,  содержащие  число  2.  После  параметра  В$  также
находится  значение  использованного  параметра:  CHR$ 14 и пять байт,
которые последовательно содержат:  первый для нас не  имеет  значения,
второй и третий содержит адрес, по которому находится цепочка символов
"125"  (вызов  функции   был   осуществлен   в   директивном   режиме,
следовательно  этот  адрес  относится  к области редактирования строки
БЕЙСИКа),  а байты  4-5  это  длина  цепочки  -  в  нашем  случае  она
составляет три знака.
   Помните при этом,  читая БЕЙСИК с помощью РЕЕК,  а не LIST,  иногда
случается,   что   именно   в   этих   байтах,  зарезервированных  для
действительных  аргументов  функции,  скрыты  проверки,   определяющие
работоспособность  программы или даже машинная программа,  загружающая
последующие блоки (например BETA BASIC 1.0).
   В конце  немного  о  программах-загрузчиках.  Их  задачей  является
считывание и запись всех блоков,  составляющих программу.  Обычно  они
это  делают  способом,  максимально затрудняющим понимание их работы -
так, чтобы запуск программы другим способом, а не через загрузчик (или
на практике взлом программы) был не возможен. Посмотрим на загрузчики,
применяемые в большинстве  продукции  фирмы  ULTIMATE  (например  ATIC
ATAC, KNIGHT LORE, PENTAGRAM, NIGHT SHADE и т.д.). Выглядят они так:
   0 BORDER 0:  PAPER 0: INK 0: CLS: PRINT #0,"LOADING": FOR N=0 TO 20
STEP 4:  BEEP 2,N:  NEXT N: LOAD "" CODE: PRINT AT 19,0: LOAD "" CODE:
PRINT AT 19,0:  LOAD "" CODE:  PRINT AT 19,0:  LOAD "" CODE: RANDOMIZE
USR 24064
   После такого  загрузчика  на ленте находятся пять следующих блоков:
экран,  закодированный блок программы, а за ним три коротеньких блока,
защищающих   программу:   однобайтовый  код  инструкции  JP  (HL),  из
нескольких байтов (это процедура,  которая декодирует всю программу) и
последний  двухбайтовый загружаемый по адресу 23627,  или в переменную
FRAMES.  Значение этой переменной увеличивается на один  через  каждые
1/50 секунд.  В машинной программе, запущенной с помощью RANDOMIZE USR
24064,  ее значение проверяется и если отличается от того каким должно
быть   (что   означает,  что  где-то  после  загрузки  программа  была
остановлена на какое-то время), наступает обнуление памяти компьютера.
Взлом программ этого типа весьма прост. Достаточно загрузить все блоки
за  исключением  последнего,  а  после  просмотра  программы  или   же
проведения  в  ней  определенных  изменений (например,  вписание РОКЕ)
достаточно  лишь  ввести:  LOAD  ""  CODE:  RANDOMIZE  USR  24064  (но
обязательно  в  одной строке,  разделяя инструкции двоеточием),  чтобы
запустить игру.
   Отдельной работой  является  декодирование  программы,  или  запуск
процедур,  декодирующих так,  чтобы она вернулась в БЕЙСИК. У учителя,
знающего  ассемблер,  это  не должно вызывать звтруднений,  однако,  с
точки зрения на  распространенность  этого  типа  защиты,  особенно  в
пользовательских  программах  (например ART STUDIO или THE LAST WORD),
мы еще вернемся к этой теме.


                        6. ЗАЩИТА ЗАГРУЗЧИКОВ.

   Все игры имею хорошо защищенную программу,  написанную на  БЕЙСИКе,
т.к.  это  важнейший  (с  точки зрения защиты) элемент всей программы.
Ведь с БЕЙСИКа начинается считывание всей программы. Если бейсиковский
загрузчик защищен слабо, то взлом всей программы значительно облегчен.
Примером этого являются загрузчики фирмы  ULTIMATE,  представленные  в
предыдущем разделе.   Одним   из  способов  снятия  защиты  загрузчика
является считывание его с  помощью  программы  "LOAD/MERGE"  (смотрите
раздел 2).  Однако, иногда лучше поместить этот загрузчик не в память,
предназначенную для БЕЙСИКа,  а выше RAMTOR, чтобы можно было спокойно
рассматривать его не опасаясь возможности случайных изменений в нем.
   Для этого имеется очень действенный метод - считывание программы на
БЕЙСИКе как  блока  машинного  кода  под удобный для нас адрес.  Чтобы
этого добиться нужно знать длину программы, которую мы хотим считывать
(можете использовать  процедуру  "CZYTACZ"  из раздела 2),  хотя можно
обойтись и без длины. Кроме того требуется немного свободного места на
магнитной ленте.  Этот  способ  основывается не обмане инструкции LOAD
путем подмены заголовков.
   На свободном  месте  магнитной  ленты  записывается  кодовый блок с
помощью SAVE "BAS" CODE 30000, 750, если мы знаем, что длина программы
составляет 750  байт.  Если  мы  ее  не  знаем - подаем соответственно
большее значение,  даже порядка  нескольких  десятков  килобайт,  хотя
программа может иметь всего 100 байт длины. На ленте записываем только
и после  этого  прерываем  запись  нажатием  клавиши  <BREAK>.  Теперь
устанавливаем ленту  точно  перед  записанным  заголовком,  а  ленту с
программой - сразу  после  заголовка  программы,  но  перед  требуемым
блоком данных. Вводим:
   CLEAR 29999: LOAD "" CODE
   или
   CLEAR 29999: LOAD "" CODE 30000
   и считываем заголовок.
   Сразу после его  считывания  мы  нажимаем  <СТОП>  на  магнитофоне,
заменяем кассету и вновь нажимаем <ПУСК> (все это время компьютер ждал
блока данных).  Теперь считывается программа на БЕЙСИКе,  но под адрес
30000  -  выше  RAMTOR.  Если  мы  задали в заголовке завышенную длину
программы, то считывание кончается сообщением "Tape loading error", но
это  не  мешает  -  теперь уже любым способом можно смотреть считанную
программу на БЕЙСИКе.  Кроме этого метода существует и второй,  но для
того,   чтобы   им  пользоваться,  обязательно  знание  АССЕМБЛЕРа,  а
пользоваться стоит,  т.к.  он дает  большие  возможности  в  раскрытии
программ, а знание ее позволяет расшифровывать работу загрузчика.
   Очень часто (особенно  в  новейших  программах)  встречаются  блоки
программ, записанные  и считываемые в память компьютера без заголовка.
Это достаточно оригинальная мера защиты обычно отпугивает  начинающих,
но раскрытие  такой  программы  вовсе  не является трудным.  Вся тайна
основана на  хранящихся  в  ROM  процедур,  используемых   с   помощью
инструкций LOAD, SAVE, VERIFY, MERGE.
   Под адресом   #0556   (1366)   находится   процедура    LOAD-BYTES,
считывающая с  магнитофона блок данных,  или пилота и следующую за ним
информацию. При этом будет  не  важно  будет  ли  это  заголовок,  или
требуемый блок данных, который следует поместить где-то в памяти.
   Начнем же  с  начала.  Каждая  защищенная  программа  начинается  с
загрузчика, написанного  на БЕЙСИКе.  Программа,  применяющая загрузку
без заголовков (с помощью процедуры  1266  или  другой),  должна  быть
написана на   машинном   коде,  как  каждая  процедура,  обслуживающая
магнитофон. Чаще всего эта  программа  помещается  в  одной  из  строк
БЕЙСИКа. Например,  после  инструкции  REM,  или  в области переменных
БЕЙСИКа. После считывания загрузчик на БЕЙСИКе запускается и выполняет
инструкцию RANDOMIZE  USR  ...,  инициируя  тем  самым работу машинной
программы. Процедура  LOAD-BYTES   требует   соответствующих   входных
параметров. Они передаются в соответствующие регистры микропроцессора.
Так в регистре IX  задаем  адрес,  под  который  хотим  прочесть  блок
данных, а  в  паре  DE - длину этого блока.  В буфер помещаем 0,  если
хотим считать заголовок и  255  если  это  блок  данных.  Кроме  того,
указатель переноса  (CARRY)  устанавливаем в 1,  т.к.  иначе процедура
1366 вместо  LOAD  выполнила  бы  функцию  VERIFY.  Ниже  дан   пример
процедуры, загружающейся с ленты без заголовка:
           LD IX,16384         ; Адрес считывания
           LD DE,6912          ; Длина блока
           LD A,255            ; Блок данных
           SCF                 ; Установка CARRY
           CALL 1366           ; Вызов LOAD-BYTES
           RET                 ; Выход из подпрограммы
   Процедура 1366 в случае  ошибки  считывания  не  выводит  сообщение
"Type loading  error".  Но  существует  еще  одна  процедура загрузки,
которая это делает:
    2050   CALL 1366           ; Считывание блока данных
    2053   RET C               ; Возврат, если не было ошибки
    2054   RST 8               ; Иначе RST 8 с сообщением
    2055   DEFB 26             ; "Tape loading error"
   После возврата   из  процедуры  1366  указатель  переноса  содержит
информацию о правильности считывания блока.  Если он  удален,  то  это
означает, что   наступила   ошибка.  Некоторые  загрузчики  используют
процедуру 2050, а не 1366.
   Иногда загрузчики  не пользуются ни той,  ни другой процедурами,  а
заменяют их собственными,  но они,  однако очень похожи  на  процедуру
1366 или  даже  являются ее переделкой,  благодаря которой,  например,
блоки загружаются в нижнюю часть памяти - с больших адресов  к  нижним
или загрузка   идет   с  другой  скоростью.  Такую  программу  следует
анализировать с  помощью  дизассемблера  (например,  MONS),  сравнивая
некоторые ее фрагменты с тем, что находится в ROM.
   Сейчас мы объясним как использовать процедуру из ROM для считывания
БЕЙСИКа по  любому адресу,  а не в область,  предназначенную для него:
сначала с помощью "CZYTAZC"  прочитаем  заголовок  программы,  которую
хотим вскрыть, и запомним ее длину (т.е. длину всего блока - программу
вместе с переменными). Затем вводим соответствующую программу, которая
прочтет БЕЙСИК под адрес, который мы установим (выше RAMTOR):
           LD IX,АДРЕС
           LD DE,ДЛИНА
           LD A,255
           SCF
           JP 2050
   Также, как и при подмене заголовка, мы не знаем длину программы, то
можем задать  завышенное  значение,   но   тогда   чтение   завершится
сообщением "Type loading error".  Но считывание ассемблера каждый раз,
чтобы вывести программу,  приведенную выше, может вызвать раздражение.
Следовательно, лучше  создавать  эту  программу  с  уровня  БЕЙСИКа  с
помощью POKE:
    10 INPUT "АДРЕС ЧТЕНИЯ BASIC? ";A
    20 RANDOMIZE A: CLEAR A-1
    30 LET A=PEEK 23670: LET B=PEEK 23671
    40 LET ADR=256*B+A
    50 INPUT "ДЛИНА BASIC? ";C
    60 RANDOMIZE C: LET C=PEEK 23670
    70 LET D=PEEK 23671
    80 FOR N=ADR TO ADR+11
    90 READ X: POKE N,X
   100 NEXT N
   110 DATA 221,33,A,B,17,C,D,62,255,195,2,8
   120 RANDOMIZE USR ADR
   Устанавливаем ленту  с  обрабатываемой программой за ее заголовком.
Затем запускаем программу,  приведенную выше, вводим данные и включаем
магнитофон. Результат  аналогичен  тому,  который получаем при подмене
заголовков, но первым же видимым достоинством этого  способа  является
то, что мы не создаем беспорядок на кассетах.
   В завершение стоит вспомнить еще об одной процедуре,  размещенной в
ROM под  адресом  1218.  Это процедура SAVE-BYTES обратная LOAD-BYTES,
т.е. записывающая на  ленту  блок  с  данными  параметрами:  перед  ее
выполнением в  регистре  IX  размещаем  адрес  с  которого  начинается
запись, DE содержит  длину  записываемого  блока.  В  буфере  помечаем
должен ли  это быть заголовок (0) или блок программы (255).  Состояние
указателя CARRY значения не имеет.


                 7. ИСПОЛЬЗОВАНИЕ СИСТЕМНЫХ ПРОЦЕДУР.

   В предыдущем разделе были представлены процедуры из ROM: SAVE-BYTES
и LOAD-BYTES.  Здесь рассказывается как использовать эти процедуры для
защиты программ.  Займемся блоками машинного кода, которые запускаются
удивительным образом.  Первым  таким   способом   является   прикрытие
загрузчика блоком,  который им загружается.  Такая защита,  к примеру,
применяется в игре "THREE WEEKS IN  THE  PARADISE".  Проследим  способ
чтения этой программы так, чтобы она не стартовала автоматически.
   Начнем, как   обычно,   с   БЕЙСИКа.   Оказывается,    практически,
единственно важной инструкцией является RANDOMIZE USR ...  Лучше всего
восстанавливать процедуру,  начиная с  адреса  запуска  RANDOMIZE  USR
(PEEK 23627+256*PEEK  23628).  Т.е.  в  нашем  случае  с адреса 24130.
Подобные процедуры   используют   известную   нам   процедуру    1366,
считывающую блоки  без  заголовка.  Так  и в этом случае,  но перед ее
вызовом с помощью команды LDIR, процедура загрузки переносит сама себя
в конец памяти под адрес 63116 и преходит туда по команде JP:
   24130   DI                  ; Запрет прерывания
   24131   LD SP,0             ; LD SP,65535
   24134   LD HL,(23627)       ; В HL адрес на 28
   24137   LD DE,28            ; большее чем значение
   24140   ADD HL,DE           ; переменной VARS
   24141   LD DE,63116         ; В DE адрес, а в
   24144   LD BC,196           ; BC длина блока.
   24147   LDIR                ; Перемещение блока под новый адрес.
   24149   JP 63116            ; Продолжение выполнения программы
                               ; с другого адреса.
   63116   LD IX,16384         ; Подготовка загрузки
   63120   LD DE,6912          ; картинки на экран
   63123   LD A,255            ; с помощью процедуры
   63125   SCF                 ; LOAD-BYTES из ROM.
   63126   CALL 1366           ;
   63129   LD IX,26490         ; Параметры главного
   63133   LD DE,38582         ; блока программы,
   63136   LD,255              ; который считываясь
   63138   SCF                 ; затирает процедуру
   63139   CALL 1366           ; загрузки блока.
   63142   JP NZ,+79           ; После возврата из
   63144   CP A                ; процедуры 1366 здесь
   63145   CALL 65191          ; уже находится другая
   63148   JP NC,-2            ; программа.
   Наш способ запуска считанной программы требует  пояснения.  Как  вы
знаете, каждая  инструкция  CALL  заносит  в  машинный  стек адрес,  с
которого начинает работать программа после выхода из  подпрограммы.  В
этом загрузчике  после  выполнения  второй инструкции CALL 1366 в стек
заносится адрес команды,  а за CALL,  т.е.  63142 и процедура загрузки
самым обычным  способом  затирает  сама себя,  т.к.  считывает байты с
магнитофона в ту область памяти,  где она была размещена. Существенное
значение имеет способ запуска считанной программы:  процедура, которая
находилась там,  была замещена считанной программой, но микропроцессор
этого не замечает - он возвращается по адресу с которого выполнил CALL
1366, не обращая внимания,  что там находится  уже  совершенно  другая
программа. Это схематично представлено на рисунке 7.

         Программа-загрузчик            Загружаемая программа
           ┌────────────┐                   ┌────────────┐
           │ LD A,255   │       63136       │ (254)      │
           │            │       63137       │ (254)      │
           │ SCF        │       63138       │ ( 75)      │
           │ CALL 1366  │       63149       │ (254)      │
           │            │       63140       │ (255)      │
           │            │       63141       │ (255)      │
           │ JP NS,+79  ├─────> 63142       │ DI         │
           │            │       63143 ─────>│ LD CP,0    │
           │ CP A       │       63144       │ ...        │
           │ CALL 65191 │       63145       │ ...        │
           └────────────┘                   └────────────┘

   Рис.7  Схема замены кода программы во время загрузки.

   С левой стороны показано содержимое памяти до считывания программы,
а с левой - после.
   Возникает вопрос,  как  распознать  защиту  такого  типа  и  как ее
ликвидировать. Начнем с БЕЙСИКа,  считываем загрузчик (в ассемблере) и
определяем адрес  окончания считанных блоков (добавляя к адресу начала
регистр IX длина/регистр DE).  Если  какой-либо  из  блоков  накрывает
процедуру загрузки,  то  это  означает,  что  программа  считывается и
загружается именно таким образом.
   Дальше все просто. Достаточно, опираясь на данные о блоках (адрес и
длину),  написать коротенькую процедуру,  загружающую интересующий нас
блок  кода или подготовить соответствующий заголовок,  затем с помощью
CLEAR ADR установить  соответствующим  образом  машинный  стек  (чтобы
машинная программа не уничтожила стек) и,  наконец, считать программу.
После выполнения в них необходимых изменений записываем ее  на  ленту,
но  таким  же образом,  каким был записан оригинал (длина блока должна
совпадать прежде всего!).  Если этот блок был без заголовка (а  так  и
есть в нашем случае), то записываем его обычным SAVE "..." CODE..., но
опуская заголовок,  т.е.  включаем магнитофон только в перерыве  между
заголовком  и  блоком кода.  Также можно пробовать запускать считанный
блок перехода на требуемый адрес командой RANDOMIZE USR...,  но это не
всегда  может  получиться.  В  игре "THREE WEEKS IN THE PARADISE" этим
адресом будет 63142 и,  как  вы  сами  можете  убедиться,  этот  метод
срабатывает.
   Другим интересным способом способом запуска блоков  машинного  кода
является считывание программы в область машинного стека. Этим способом
можно запускать блоки машинного кода, загружая их просто через LOAD ""
CODE. Этот метод показан схематично на рисунке 8.

                               Машинный Стек
                               ┌───────────┐
                 65356         │           │
                 65357         │     ...   │
                 Per SP ─────> │    1343   │
                 65359         │           │
                 65360         │    2053   │
                 65361         │         ╔═╧═══════╗
                 65362         │    7030 ║  65535  ║
                 65363         │         ║         ║
                 65364         │    4867 ║      ?  ║
                 65365         │         ║         ║
                 65366         │       ? ║      ?  ║
                 RAMTOR ─────> │      62 ║     62  ║
                 65368         │         ║  LD IX  ║
                 65369         │         ║    ...  ║
                 65370         │         ║  LD DE  ║
                               └─────────╢    ...  ║
                                         ╚═════════╝

   Рис.8  Схема автозапуска блока кодов.

   Указатель стека  (регистр  SP)  принимает  показанное  на рисунке 8
состояние в процессе выполнения процедуры 1366 (вызванную  из  БЕЙСИКа
через  LOAD  ""  CODE).  Способ запуска программы весьма прост.  Адрес
считывания блока рассчитан так,  что блок считывается на машинный стек
именно  с того места,  в котором находится (записанный интерпретатором
БЕЙСИКа) адрес возврата из инструкции LOAD ""  CODE  (он  тогда  равен
значению   системной   переменной  ERRSP-2)  или  прямо  из  процедуры
LOAD-BYTES  (равный  ERRSP-6).  Тогда  два  первых   байта   программы
обозначают адрес ее запуска. Этот способ очень похож на предыдущий, за
исключением того,  что там подменялась процедура загрузки,  а здесь  -
адрес  считывания  блока  кодов,  микропроцессор  считывает содержимое
стека и переходит по прочитанному адресу (который только что  появился
в  памяти).  По  этому  адресу  в программе находится начало процедуры
загрузки ее последующих блоков. Это видно на рисунке 8.
   Метод обхода  такой защиты также весьма прост,  достаточно заменить
RAMTOR на соответственно  низкое  значение,  а  затем  прочитать  блок
кодов,   который   благодаря  этому  не  запуститься.  Ситуация  может
осложниться,  если блок очень длинный (что случается очень  редко,  но
встречается) - тогда мы должны поступить также, как и с каждым длинным
блоком, но помнить с какого адреса он запускается.
   Займемся теперь  расчленением  блоков  с  длиной превышающей 42 Кб.
Взлом блоков этого типа основан на разделении их на  такие  фрагменты,
чтобы в памяти еще осталось место для MONSа или другого дизассемблера,
исправления этих фрагментов,  а затем их склеивания в одно целое  либо
написание новой   процедуры   загрузки.  Обычно  достаточно  разделить
длинный блок на две части. Чтобы получить первую  используем процедуру
1366, но с другими параметрами (не с теми, которых требует разделенный
на части блок).  Ранее из процедуры загрузки или если такой нет, то из
заголовка этого  блока  получаем  ее  длину  и адрес загрузки.  Просто
задаем адрес, по которому хотим разместить блок (выше RAMTOR), а также
длину, примерно  16  Кб  (несмотря  на  то,  что блок этот значительно
длинее). Считываем теперь этот блок через CALL 1366 или CALL 2050,  но
во втором случае сообщение "Tape loading error",  которое появится, ни
даст нам никакой информации о верности считывания  -  загружаем  часть
блока и,  следовательно,  без контрольного байта,  который находится в
конце. Считанную таким образом первую часть блока записываем на  ленту
и сразу же приступаем ко второй части.  Ее считывать труднее,  но тоже
возможно несмотря на ограничения по  памяти.  Достаточно  использовать
тот факт,  что  в  SPECTRUM  существуют  16  Кб ROM,  запись в которую
невозможна. Например,  вызывая  процедуру  1366  с  адресом  равным  0
изначальные 16  Кб  будут  просто  потеряны,  а в память RAM считаются
только следующие 32 Кб или меньше  (в  зависимости  от  длины  блока).
Считываемый блок займет в памяти RAM адрес с 16384 и дальше, заходя на
системные переменные и оставляя без изменения лишь  те  байты,  адреса
которых больше длины блока. Поэтому необходимо специально позаботить о
том, чтобы машинный стек,  а также написанную нами процедуру  загрузки
разместить в  конце  памяти.  Надо  также  помнить о том,  что система
БЕЙСИКа будет уничтожена и записать  сразу  считанный  блок  на  ленту
можно только  процедурой,  написанной  на  ассемблере.  Кроме  того  в
промежутках времени между считыванием фрагмента блока  и  его  записью
нельзя разблокировать прерывания, т.к. они изменяют содержимое ячеек с
адресами 23552-23560,  а также 23672-23673,  а там находится считанный
блок. Чтобы   выполнить   это  последнее  условие  войдем  в  середину
процедуры 1366,  благодаря  чему  после  считывания  блока  не   будет
выполнена процедура 1343. Именно она еще и разблокирует прерывания.
   С помощью CLEAR 64999 переносим машинный стек,  а  с  адреса  65000
помещаем процедуру загрузки:
           ORG 65000           ;
           LD IX,0             ; Адрес считывания.
           LD DE,ДЛИНА         ; Длина блока.
           LD A,255            ; Подготовка к считыванию
           SCF                 ; блока.
           INC D               ; Таким способом
           EX AF,AF            ; заменяем начало
           DEC D               ; процедуры 1366,
           DI                  ; а затем входим
           LD A,15             ; в ее середину.
           OUT (254),A         ;
           CAL 1378            ;
           LA A,0              ; Черная рамка
           JR C,OK             ; будет означать
           LD A,7              ; верное считывание
   OK      OUT (254),A         ; белая - ошибочное.
   CZEKAJ  LD A,191            ; Ожидаем нажатие
           IN A,(254)          ; <ENTER>.
           RRA                 ;
           JR C,CZEKAJ         ;
           LD IX,16384         ; Запись считанного
           LD DE,ДЛИНА-16383   ; блока на
           LD A,255            ; ленту,
           CALL 1218           ; а также
           LD HL,64999         ; инициализация
           JR 4633             ; системы БЕЙСИКа.
   Вместо того,  чтобы  считывать  ассемблер  и вводить эту программу,
можно запустить программу на БЕЙСИКе, представленную на листинге 4.

   Листинг 4. Программа чтения-записи второй части длинного блока.

    10 CLEAR 64999
    20 INPUT "DLINA BLOKA?"; DL: RANDOMIZE DL:
       LET X=PEEK 23670: LET Y=PEEK 23671: LET S=0
    30 FOR N=65000 TO 65054: READ A: LET S=S+A:
       POKE N,A: NEXT N
    40 IF S<>5254+2*(X+Y)-64 THEN PRINT "OSIBKA V DANNYH": STOP
    50 PRINT "VSE DANNYE OK => VKLUCHI MAGNITIFON"
    60 RANDOMIZE USR 65000
    70 DATA 221,33,0,0,17,X,Y,62,2,55,55,20,8,21,243,62,
            15,211,254
    80 DATA 205,98,5,62,0,56,2,62,7,211,254,62,191,219,
            254,31,56
    90 DATA 249,221,33,0,0,17,X,Y-64,62,255,205,194,4,33,
            231,253,202,25,18

   Как выглядит  разделение блока?  Устанавливаем ленту на блоке кода,
который желаем разделить.  Если он имел заголовок,  то  его  опускаем.
Запускаем процедуру и включаем магнитофон. Не пугайтесь, когда увидите
в определенный момент,  что программа  считывается  на  экран,  так  и
должно быть.   После   загрузки   блока  цвет  рамки  сигнализирует  о
правильности считывания:  если рамка черная,  то все в  порядке,  если
белая, то  была  ошибка.  Тогда вставляем в магнитофон другую кассету,
включаем запись и нажимаем  <ENTER>.  Программа  запишется  на  ленту,
потом процедура вернется в БЕЙСИК,  инициализируя систему с сообщением
"(C) 1982 Sinclair Research Ltd.",  но не очищая память  (уничтожается
только область от начала экрана до,  примерно,  24000 адреса).  Теперь
подготавливая заголовок или  записывая  коротенькую  процедуру,  можно
прочесть полученный блок под любой адрес.
   Когда вы найдете то,  что искали и  захотите  запустить  измененную
программу, то  придется  немного  помучиться  и  "склеить" разделенную
программу или  написать  для  нее  новую  процедуру   загрузки.   Если
программа заполняла  полностью  48  Кб  памяти  RAM,  то возможен лишь
второй метод.
   Если надо соединить блоки - достаточно написать процедуру,  похожую
на разделяющую,  но такую,  которая считывает первый  блок  под  адрес
16384, второй - сразу за ним, а затем запишет их вместе как один блок.
   В этом разделе был  описан  способ  запуска  машинного  кода  путем
считывания в  область  машинного  стека.  Чтобы  такой  блок запустить
достаточно ввести инструкцию LOAD "" CODE, которая запустит его. Чтобы
убедиться в этом на практике введите программу с листинга 5.

   Листинг 5. Пример автозапуска машинной программы.

    10 CLEAR 65361: LET S=0
    20 FOR N=65362 TO 65395: READ A:
       POKE N,A: LET S=S+A: NEXT N
    30 IF S<>3437 THEN PRINT "OSIBKA V STROKE DATA": STOP
    40 SAVE "BEEP" CODE 65362,34
    50 DATA 88,255,3,19,0,62,221,2,29,6,8,197,17,30,0,33,
            0,8,43,124,18
    60 DATA 181,3,33,0,8,43,124,18,1,32,251,193,16,235,
            221,225,201

   Она запишет  на  ленте короткий блок машинного кода,  который будет
запускаться самостоятельно. После записи этого блока освободите память
с помощью  RANDOMIZE  USR  0  или  <RESET>  (по возможности переставте
RAMTOR на нормальное значение с помощью CLEAR 65367) и загрузите его с
помощью LOAD "" CODE.  Цель этого блока проинформировать о том, что он
запустился -  он  делает  это  несколькими  звуковыми  сигналами.   Вы
услышите их  сразу  после  считывания  программы,  как  только с рамки
исчезнут красно-желтые полосы.


         8. ДЕКОДИРОВАНИЕ ЗАКОДИРОВАННЫХ БЛОКОВ ТИПА "BYTES".

   Что означает,  что  программа или блок закодированы?  Кодирование -
это род весьма простого шифра, делающего невозможной правильную работу
программы. Для  ее  запуска служит специальная декодирующая процедура,
которая находится в той же программе,  а также,  что самое важное,  не
закодированная. Так   для  чего  же  служит  кодирование?  Это  просто
очередное затруднение доступа к тексту программы после  того  как  все
предшествующие предохранители   взломаны   и   программа  считана  без
самозапуска. В этом случае  в  памяти  лежит  "полуфабрикат",  который
только после    переработки    декодирующей    процедурой   становится
программой. Кодирование может быть основано на инверсии всех байтов  в
программе. Хорошим   примером  является  программа  "ART  STUDIO".  Ее
бейсиковая часть  практически  не  защищена  никак,  но  главный  блок
программы ("STUDIO-MC"  CODE  26000,30672)  частично закодирован.  Что
делать, чтобы раскодировать "ART STUDIO"?  По адресу  26000  находится
инструкция JP  26024,  которая  осуществляет  переход  к  декодирующей
процедуре. Вот ее текст:
   26024   21 C1 65    LD HL,26049       ; Запись адреса
   26027   E5          PUSH HL           ; 26049 в стек.
   26028   21 C1 65    LD HL,26049       ; Адрес начала.
   26031   11 47 6C    LD DE,27719       ; Адрес конца.
   26034   7E          LD A,(HL)         ; Выбор байта из
   26035   D6 22       SUB 34            ; памяти,
   26037   07          RLCA              ; перекодирование его
   26038   EE CC       XOR #CC           ; с помощью SUB, RLCA,
   26040   77          LD (HL),A         ; XOR и запись.
   26041   23          INC HL            ; Следующий адрес.
   26042   B7          OR A              ; Проверка признака
   26043   ED 52       SBC HL,DE         ; конца, возврат
   26045   19          ADD HL,DE         ; в цикл или выход
   26046   20 F2       JP NZ,26034       ; по адресу, записанному
   26048   C9          RET               ; в стеке.
   Сначала процедура помещает в стек адрес  26049.  Теперь  начинается
декодирование: в  регистр  HL  заново  загружается  адрес  26049 - как
начало декодируемого  блока,  в  DE  -  27719,  как  адрес  последнего
закодированного блока.  Затем  в  цикле  декодируются  последовательно
байты - инструкции SUB 34,  RLCA,  XOR #CC являются ключом,  с помощью
которого расшифровывается  эта часть программы.  Наконец,  проверяется
условие достижения  адреса  27719.  Выполняется  инструкция  RET,   но
последним записанным  в  стек  является не адрес возврата в БЕЙСИК,  а
записанный в начале с помощью PUSH HL адрес 26049 или адрес только что
раскодированного блока, следовательно происходит его запуск.
   Обратим внимание, какие инструкции осуществляют дешифрацию, никакая
из них не теряет ни одного бита.  Вычитание производится по модулю 256
и для двух разных  входных  данных.  Результаты  тоже  различны.  RLCA
заменяет значения  битов  7,  6,  3  и  2 на противоположные.  Другими
инструкциями, имеющими те же самые свойства являются,  например,  ADD,
INC, DEC, RRCA, NEG, CPL но не OR или AND.
   Как раскодировать этот блок без самозапуска? Проще всего введя:
   POKE 26027,0 (код инструкции NOP)
   Тем самым ликвидировать инструкцию PUSH HL (RET в  конце  программы
переведет в  БЕЙСИК)  и  выполнить  RANDOMIZE USR 26000.  Стоит однако
помнить о том,  что декодирующая процедура  может  проверяться  другим
фрагментом программы. Вот дальнейшая часть программы "ART STUDIO":
   26283   67          LD H,A            ; В A уже находится
   26284   6F          LD L,A            ; значение 0.
   26285   E5          PUSH HL           ; Запись его в стек
   26286   3A A8 65    LD A,(26024)      ; и проверка
   26289   FE 21       CP #21            ; содержимого ячеек
   26291   C0          RET NZ            ; с адресами
   26292   2A A9 65    LD HL,(26025)     ; 26024...26027
   26295   B7          OR A              ; и если оно другое,
   26296   11 C1 65    LD DE,(26049)     ; то стирание
   26299   ED 52       SBC HL,DE         ; памяти с помощью
   26301   C0          RET NZ            ; RET NZ
   26302   3A AB 65    LD A,(26027)      ; (под адрес 0).
   26305   FE E5       CP #E5            ; Если все нормально,
   26307   C0          RET NZ            ; то снятие адреса 0
   26308   E1          POP NZ            ; и нормальный
   26309   C9          RET               ; выход.
   Этот фрагмент   проверяет:   наверняка  ли  декодирующая  процедура
запустила программу,  и если нет,  то с помощью RET NZ стирает  память
(т.к. в стеке записан адрес 0).
   Что делать в этом случае? Можно ликвидировать и эти меры защиты, но
в некоторых  программах  это не поможет.  Тогда остается другой выход:
снова закодировать программу,  т.е. сделать обратное, чем декодирующая
процедура. В нашем случае следовало бы выполнить:
           XOR #CC
           RRCA
           ADD 34
   В "ART   STUDIO"  неизвестно  для  чего  была  помещена  кодирующая
программа. Она находится под адресом 26003 и выглядит так:
   26003   21 C1 65    LD HL,26049       ; Адрес начала.
   26006   11 47 6C    LD DE,27719       ; Адрес конца.
   26009   7E          LD A,(HL)         ; Выборка байта из
   26010   EE CC       XOR #CC           ; памяти, кодирование
   26012   0F          RRCA              ; его с помощью XOR,
   26013   C6 22       ADD 34            ; RRCA, ADD и его
   26015   77          LD (HL),A         ; запись.
   26016   23          INC HL            ; Следующий адрес.
   26017   B7          OR A              ; Проверка окончания.
   26018   ED 52       SBC HL,DE         ; Переход в цикл
   26020   19          ADD HL,DE         ; или возврат
   26021   20 F2       JR NZ,26009       ; в БЕЙСИК.
   Как видно,  она  построена аналогично декодирующей процедуре.  Если
таковой нет,  то  ее  можно  быстро  и  просто  написать   на   основе
декодирующей процедуры (например, ATIC ATAC, NIGHT SHADE, THE WORLD).
   При защите    программ    применяют    также    малоизвестные     и
неопубликованные в  фирменных  каталогах  команды микропроцессора Z80.
Благодаря их применению  программа  становится  мало  читаемой,  да  и
просмотр ее дизассемблером затруднен.
   Наиболее часто встречаемыми неопубликованными инструкциями являются
команды, оперирующие  с  половинками  индексных  регистров  IX  и IY в
группе команд,  которым не предшествует никакой иной префикс (т.е. CBh
и EDh).  Основываются  они  на  префиксации кодом DDh или FDh команды,
касающейся регистра H или L.  В  этом  случае  вместо  этого  регистра
появляется соответствующая  половина  индексного  регистра.  Через  HX
обозначается старшая часть регистра HX, через IX - младшая. Аналогично
HY и IY. Вот пример:

  ╔═══════╤═════════╦═══════════╤═══════════╦═══════════╤═══════════╗
  ║  КОД  │ КОМАНДА ║    КОД    │  КОМАНДА  ║    КОД    │  КОМАНДА  ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║    24 │ INC HL  ║     DD 24 │ INC HX    ║     FD 24 │ INC HY    ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║    2D │ DEC L   ║     DD 2D │ DEC HX    ║     FD 2D │ DEC HY    ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║    4C │ LD C,H  ║     DD 4C │ LD C,HX   ║     FD 4C │ LD C,HY   ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║    64 │ LD H,H  ║     DD 64 │ LD HX,HX  ║     FD 64 │ LD HY,HY  ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║ 26 01 │ LD H,1  ║  DD 26 01 │ LD HX,1   ║  FD 26 01 │ LD HY,1   ║
  ╟───────┼─────────╫───────────┼───────────╫───────────┼───────────╢
  ║    B5 │ OR L    ║     DD B5 │ OR IX     ║     FD B5 │ OR IY     ║
  ╚═══════╧═════════╩═══════════╧═══════════╩═══════════╧═══════════╝

   Рис.9  Таблица некоторых неопубликованных команд Z80.

   Это верно для всех команд однобайтовых пересылок между регистрами и
восьмибитовых операций AND,  OR, ADD, ADC, SUB, BC, CP - выполняемых в
аккумуляторе.
   Префикс FDh или DDh относится  ко  всем  регистрам  H,  L  или  HL,
присутствующим в   команде,   следовательно,  в  одной  инструкции  не
возможно использование ячейки адресованной как (HL),  регистра  HL,  H
или L  одновременно  с  HX,  HY,  IX,  IY  (в  дальнейшем  ограничимся
регистром IX, но все это относится также и к регистру IY), например:
   66  LD H,(HL)       DD66nn  LD HX,(IX+nn)
   75  LD (HL),L       DD75nn  LD (IX+nn),IX
   65  LD H,D          DD65    LD HL,IX
   Несколько иначе представляется ротация ячейки, адресуемой индексным
регистром, т.е.  инструкцией начинающейся кодом DD CB. Инструкция типа
RR (IX+nn) и ей подобные подробно описаны во всех доступных материалах
о микропроцессоре  Z80,  но  мало   кто  знает   об  инструкциях  типа
RR (IX+nn),REG  и  им  подобным,  где  REG  обозначает  любой  регистр
микропроцессора. Они  основаны  на  префиксировании  кодом DDh или FDh
инструкции   типа   RR REG,  также   обстоит   дело   с   инструкциями
SET N,(IX+nn),REG,  а  также  RES  N,(IX+nn),REG (но для BIT уже нет).
Выполнение такой инструкции основано на выполнении нормальной  команды
RR (IX+nn)  (или подобной),  SET N,(IX+nn) или RES N,(IX+nn),  а затем
пересылки результата как в ячейку (IX+nn),  так  и  в  соответствующий
внутренний регистр микропроцессора, например:
   CB 13               RLE
   DD CB 01 13         RL (IX+1),E
   DD CB 01 16         RL (IX+1)
   DD 5E 01            LD E,(IX+1)
   В конце рассмотрения инструкции этого типа следует  вспомнить,  что
команд EX DE,IX или EX DE,IY нет.  Префиксирование команды EX DE,HL не
дает никаких результатов.  Также префиксирование команд,  коды которых
начинаются с  EDh,  а также тех,  в которых не присутствует ни один из
регистров H, L или пары HL (например, LD B,H; RRCA и т.д.).
   Очередной любопытной   командой   является   SLI  (Shift  Left  and
Increment),  выполнение которой аналогично SLA  с  той  разницей,  что
самый младший   бит  устанавливается  в  1.  Признаки  устанавливаются
идентично SLA и другим сдвигам:
   CC 37               SLI A
   CB 36               SLI (HL)
   DD CB nn 36         SLI (IX+nn)
   DD CB nn 57 0C      SLI (IX+nn),A
   Временами некоторые   проблемы   вызывают   построение   флажкового
регистра, особенно тогда,  когда он используется достаточно нетипично,
например:
                       PUSH AF
                       POP BC
                       RL C
                       JP NC,...
   Его вид представлен на рисунке 10.

  ╔═════╤═════╤═════╤═════╤═════╤═════╤═════╤═════╗
  ║  7  │  6  │  5  │  4  │  3  │  2  │  1  │  0  ║
  ╟─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────╢
  ║  S  │  Z  │  F5 │  H  │  F3 │ P/V │  N  │  C  ║
  ╚═════╧═════╧═════╧═════╧═════╧═════╧═════╧═════╝

   Рис.10  Состояние флажкового регистра.

   Дополнительной особенностью регистра F является то,  что биты 3 и 5
(обозначенные как  F3  и  F5)  точно  отражают состояние восьмибитовой
арифмитической или  логической  операции  INC  REG,(C)  и  IN   F,(C),
например:
                       XOR A             ; Запись значения 0.
                       ADD A,15          ; Результат: 00001111.
                                         ; Указатели будут: F5=0; F3=1.
   Последняя (кто поручится, что их больше нет?) тайна Z80 это регистр
обновления памяти P. А точнее то, что когда после очередного машинного
цикла микропроцессора инкрементируется значение этого регистра, то его
старший бит остается неизменным,  следовательно может быть использован
для хранения любой,  естественно однобитной,  информации.  Важно также
то,  что инструкция LD A,P с помощью которой может быть  получена  эта
информация,  устанавливает  также  указатель  S и,  следовательно,  не
требуется дополнительная инструкция, проверяющая значение этого бита.


                              ЗАКЛЮЧЕНИЕ

   В конце  несколько  коротких,  но  часто приемлемых мер защиты.  Их
ликвидация основывается  обычно  на   действиях   обратным   защитным.
Например, переменная  DFSZ  (23659)  определяет  число  строк в нижней
части экрана,  требуемое для вывода сообщения об ошибке или для  ввода
данных. Во время работы программы это значение равно 2,  но достаточно
занести туда 0,  чтобы программа зависла при попытке ее останова (т.к.
выводится сообщение   для   которого  нет  места).  Если  в  программе
находится инструкция INPUT или CLS, то она имеет подобный результат.
   Распространенным способом  защиты является также изменение значений
переменной BORDCR (23624),  которая определяет цвет рамки и  атрибутов
нижней части экрана. Значение отдельных битов следующие:
   7 бит         - FLASH
   6 бит         - BRIGHT
   5,4,3 биты    - BORDER
   2,1,0 биты    - INK
   Способ защиты основывается на том,  что цвет чернил тот  же  самый,
что и у рамки,  следовательно, при остановке программы можно подумать,
что она зависла (т.к.  не видно сообщений).  Разблокировать  программу
можно вписав BORDER 0 (или другой цвет).
   Очередным способом  защиты  является  изменение  переменной   ERRSP
(23613-23614) или  дна  машинного  стека (эта переменная указывает дно
стека), где обычно находится  адрес  процедуры  обрабатывающей  ошибки
языка BASIC (вызываемой с помощью RST 8). Уменьшение значения ERRSP на
2 вызывает защиту  программы  от  <BREAK>  и  любой  другой  ошибки  -
программа заново запускается с того места, где произошла ошибка. Смена
содержимого дна машинного стека или другая замена значений ERRSP может
вызывать зависание программы или даже рестарт компьютера.
   Известным способом защиты является также занесение значения  больше
9999 в ячейки памяти, обозначающие номер строки БЕЙСИКа (первый байт -
старший). Если он размещается в границах 10000-16383,  а  на  листинге
это выглядит,  например,  0000  (вместо  10000)  и  строки  невозможно
вызвать на редактирование <EDIT>, если же превышает 16384 - дальнейшая
часть программы  считается  не  существующей.
   Можно также   встретить   защиту,   основывающуюся   на   занесении
минимальных значений  (то есть 1) в переменные REPDEL (23561) и REPPER
(23562), что затрудняет работу с компьютером,  но  для  ее  ликвидации
требуется лишь  быстрая  реакция  (запишите  с помощью POKE нормальные
значения: 35 и 5).
   Стоит вспомнить  еще  о переменной NMIADD,  которая не используется
из-за ошибки в ROM.  Она  должна  была  содержать  адрес  обслуживания
прерывания NMI (всегда понимаемого).  Ошибка в том, что микропроцессор
переходит туда лишь тогда, когда адрес равен 0. Если, однако, добавить
к SPECTRUM соответствующую приставку,  путь к задержке любой программы
был бы открыт.

   Счастливой разборки программ!


Retyped by Sergey Lukyanenko. Autumn 2000.
FidoNet: 2:5028/52.521
E-Mail: metamorfus@mail.ru
