
         же 30 и 40  в системную переменную CHANS записывается начальный
         адрес области информации о каналах, находящейся в ПЗУ.

              Весьма полезной, особенно  для создателей обучающих  прог-
         рамм, может быть следующая процедура, которая несколько  меняет
         действие команды PRINT. При использовании этой процедуры по ко-
         манде PRINT  информация на  экран будет  выводиться с временной
         паузой между отдельными символами и с генерацией короткого зву-
         кового сигнала после  вывода каждого символа.  Причем величиной
         паузы можно регулировать  какой-то обучающий момент  программы,
         например в программах, развивающих чтение или скорочтение.  Эф-
         фект имитации телетайпа, кроме того, вносит разнообразие в  ра-
         боту программы  (вспомните, например,  игровую программу  Black
         Hawk).

                  10    BEEP     EQU 949
                  20    CURCHL   EQU 63633
                  30    TIME     EQU 65300
                  40             ORG 65301
                  50    PRINT    DEFW 2548
                  60    START    PUSH AF
                  70             LD A,I
                  80             JR PO,NOPAUSE
+                                  - 206 -

                  90             LD A,(TIME)
                 100             LD B,A
                 110    PAUSE    HALT
                 120             DJNZ,PAUSE
                 130    NOPAUSE  POP AF
                 140             CP 33
                 150             JR C,NOBEEP
                 160             PUSH AF
                 170             PUSH IX
                 180             LD DE,50
                 190             LD HL,100
                 200             CALL BEEP
                 210             POP IX
                 220             POP AF
                 230    NOBEEP   LD HL,(PRINT)
                 240             CALL 111,
                 250             LD HL,(CURCHL)
                 260             LD BC,START
                 270             LD E,(HL)
                 280             LD (HL),C
                 290             INC HL
                 300             LD D,(HL)
                 310             LD (HL),B
                 320             LD A,B
                 330             CP D
                 340             JR NZ,CHNG
                 350             LD A,C
                 360             CP E
                 370             RET Z
                 380             LD (PRINT),DE
                 390             RET

              Запуск этой процедуры  может показаться несколько  необыч-
         ным.  Для  ее  вызова  не  надо  давать ни традиционную команду
         RANDOMIZE USR, ни похожие на нее PRINT USR, RESTORE USR и  т.п.
         Для того, чтобы эта процедура выполнялась, достаточно  записать
         в  области  информации  о  каналах  в  ячейках,  отведенных для
         хранения  адреса  вызова  процедуры,  обслуживающей  канал "S",
+                                  - 207 -

         адрес начала этой процедуры. Стандартно там записан адрес 2548,
         а мы с помощью POKE запишем туда адрес 65303.
                              POKE 23739, 23
                              POKE 23740,255
              Теперь по  команде процессора  RST 10H  (вывод символа  на
         экран)   будет вызываться  не процедура  ПЗУ, а  созданная нами
         процедура  из  адреса  65303.  Временная пауза между выводимыми
         символами  задается  путем  записи   с  помощью  команды   POKE
         соответствующего числа от 1 до 10 в ячейку 65300.
              Пояснения к процедуре:
              В строках 50...80 выполняется проверка на разрешение пре-
         рываний.  Если прерывания запрещены, то выполняется переход на
         метку NOPAUSE, иначе программа может зависнуть на команде HALT
         в строке 110.
              В  строках  90...120  организуется  цикл,  длина  которого
         берется из ячейки 65300 и устанавливается в регистре A, а затем
         B. В этом цикле находится команда HALT, которая и  обеспечивает
         необходимую задержку по времени при печати символов.
              В строках 130...150 проверяется код вводимого символа. Ес-
         ли его код менее 33, то это не печатаемый символ, а управляющий
         код  или пробел и при  его выдаче не надо давать звуковой  сиг-
         нал. Поэтому выполняется переход к NOBEEP, обходя выдачу звуко-
         вого сигнала.
              Поскольку  обработка   управляющих  кодов   происходит   с
         использованием других процедур, то прямой вызов CALL 2548 может
         привести  к  ошибке  или  потере  управляющего  кода.   Поэтому
         выполняется  CALL  111.  По  адресу  111 в ПЗУ записана команда
         JP(HL). Таким образом мы реализуем несуществующую в  АССЕМБЛЕРе
         процессора  Z-80  команду  CALL  (HL)  и  выполняем  переход по
         адресу, записанному в регистровой паре HL (строка 230).
              Внутри процедур обработки управляющих кодов имеются коман-
         ды, которые меняют содержимое байтов области информации о кана-
         лах. Поэтому в строках 250...310 выполняется проверка  записан-
         ного для  канала "S"  адреса процедуры  вывода и восстановление
         адреса 65303, а затем восстановление, при необходимости,  пере-
         менной PRINT (строки 320...390).
              Данная процедура прекрасно работает только до момента, по-
         ка не будет выполнена команда CLS. Эта команда  восстанавливает
+                                 - 208 -

         в  области  информации  о  каналах  стандартные адреса процедур
         вывода.  Чтобы вернуть прежнее действие команде PRINT,  необхо-
         димо опять же с помощью команды POKE записать в ячейки 23739/40
         адрес  65303.  И  так  поступать  после  каждой команды CLS или
         нажатия клавиши ENTER.
              Естественно, это не совсем удобно, поэтому  лучшим решени-
         ем будет открытие нового пользовательского канала, адреса  про-
         цедур ввода-вывода  которого будут  оставаться незыблемыми  все
         время, пока включен  компьютер. Для этого  необходимо расширить
         область информации о  каналах на 5  байтов, в которых  записать
         адреса соответствующих процедур ввода и вывода и имя нового ка-
         нала. Выполняется это с помощью процедуры ПЗУ MAKE_ROOM,  нахо-
         дящейся по  адресу 5717  (1655H). При  этом перед  вызовом этой
         процедуры в регистровую  пару HL необходимо  записать начальный
         адрес резервируемой области, а в регистровую пару BC - количес-
         тво  байтов.  При  использовании  этой  процедуры автоматически
         изменяются системные переменные, определяющие адреса  отдельных
         блоков БЕЙСИК-области. Ниже представлена программа, позволяющая
         создать нужный нам канал:

                  10 FOR n=23296 TO 23304: READ a: POKE n,a: NEXT n
                  20 DATA 1,5,0,33,202,92,195,85,22
                  30 RANDOMIZE USR 23296
                  40 RESTORE 60
                  50 FOR n=23754 TO 23758: READ b: POKE n,b: NEXT n
                  60 DATA 23,255,196,21,83
                  70 STOP
              После  выполнения  этой  программы  Вам  остается   только
         подключить  новый  канал  к  потоку_2  командой  POKE 23578,21.
         Теперь  можно  не  заботиться  о  необходимости  восстановления
         адреса созданной процедуры в области данных о каналах.

              6. ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ ПО ПРОСМОТРУ МАШИННОГО

                      КОДА ФИРМЕННЫХ ИГРОВЫХ ПРОГРАММ.

              Приведенные в предыдущей главе примеры, конечно могут  по-
         мочь в приобретении практических навыков программирования в ма-
+                                  - 209 -

         шинных кодах, но в рамках одной книги, сколь бы объемной она ни
         была, невозможно охватить все приемы, используемые лучшими про-
         граммистами мира. К тому же, техника программирования не  стоит
         на месте и непрерывно развивается. Огромный материал для анали-
         за Вам могут предоставить готовые игровые программы, и мы гото-
         вы в этой главе открыть некоторые приемы, которые позволят  Вам
         сохранить массу времени при работе.
              Сразу оговоримся, что рекомендации, которые мы здесь  при-
         ведем, не  являются строго  однозначными и  окончательными. Это
         только путеводитель. Возникли они как результат наших поисков и
         экспериментов, может быть Вы найдете другие, лучшие. Во  всяком
         случае, с набором  опыта Вы будете  расширять и набор  приемов.
         Может быть, Вы сами сможете поделиться своими приемами с нашими
         читателями.
              Предположим, что Вы взяли игровую программу  (незащищенную
         от  просмотра)  и  с  помощью,  допустим, программы-копировщика
         выделили из нее машинокодовый блок. У разных программ он бывает
         разным, но допустим его размер примерно 40К.
              Что будет, если Вы захотите только просмотреть его, напри-
         мер с помощью программы ДИСАССЕМБЛЕРа, скажем MONITOR или MONS.
         Если каждому байту Вы уделите хотя бы по 3 секунды своего  вни-
         мания, то на  просмотр всего блока  у Вас уйдет  более 30 часов
         напряженнейшей работы.  В то же время, есть приемы, которые по-
         зволяют в течение 30...40 минут вчерне разобраться с  устройст-
         вом программы и дальнейшую работу производить более целенаправ-
         ленно.
              Самое лучшее, что можно сделать - это распечатать код про-
         граммы на принтере. Уже за то время, пока он будет  печататься,
         Вы сможете во многом разобраться. На худой конец напишите  про-
         грамму, которая будет распечатывать текст Вашего блока на экра-
         не.  Главное требование, чтобы печать производилась в следующем
         формате строки:  адрес, а  за ним  восемь байтов.  Очень важно,
         чтобы их было именно  восемь, это поможет при  беглом просмотре
         кода многое открыть.
              Давайте рассмотрим варианты того, что Вы при этом можете
         увидеть.
              1. Если  в тексте  относительно часто  встречаются коды CD
         (CALL NN) и FE (CP  N), то есть большая вероятность,  что перед
+                                  - 210 -

         Вами главный логический  блок программы, осуществляющий  увязку
         всех структур в единое целое. Он обычно невелик (до 1К) и может
         быть запрятан глубоко в тело программы.
              Пример фрагмента программы "BOMB JACK".
              49952   F6  E6  CD  38  EC  CD  10  ED
              49960   CD  A0  ED  CD  EB  D7  CD  5B
              49968   CC  CD  8F  D9  CD  A8  D6  3A
              2. Если перед Вами сравнительно однородные значения кодов,
         но все же относительно чаще появляются коды 20, 21, 22, 2А, 32,
         3А, 3Е, С9, то здесь  скорее всего исполняемый машинный код,  а
         именно - рабочие процедуры программы.
              Пример фрагмента:
              55656   С8  С9  11  00  40  06  BF  ED
              55664   53  E1  FD  21  E3  FD  14  7A
              55672   E6  07  20  12  7B  C6  20  5F
              3. Если  в выводимых  строках явно  преобладают близкие по
         значению коды, лежащие  в диапазоне от  30 до 7А,  то с большой
         вероятностью можно сказать, что в этих областях памяти хранятся
         тексты сообщений, запросов к пользователю, экранных меню и т.п.
              Пример фрагмента.
              61616   6E  20  77  69  74  68  20  74
              61624   68  65  20  42  65  73  74  10
              61632   03  10  42  6F  6D  62  65  72
              4. Если в какой-то области памяти Вам встречаются  относи-
         тельно частые  повторения нулей,  то логично  предположить, что
         эта область занята графикой, но это предположение следует серь-
         езно проверять. Дело в том, что как правило, графические  изоб-
         ражения хранятся  в программах  в компрессированном  виде, т.е.
         многократные повторения одинаковых байтов из них удалены.  Вер-
         нее другое предположение, что эта область предназначается прог-
         раммой для хранения  программных переменных и,  поскольку прог-
         рамма еще  не начинала  свою работу,  то эта  зарезервированная
         память заполнена пока нулями.
              Возможен, конечно, вариант,  что программист при  стыковке
         всех блоков программы в единое целое просто оставил эту область
         в качестве "мусора".


+                                  - 211 -

              Пример фрагмента:
              63968   27  00  00  00  00  00  0A  00
              63976   0A  00  10  27  00  00  00  00
              63984   00  0A  00  0A  00  10  27  00
              5. Участки, занятые графикой (экранами), отыскать  неслож-
         но. Как  правило, они  занимают очень  обширные области  памяти
         (многие килобайты). Поскольку алгоритм, которым компрессируются
         и декомпрессируются изображения, Вам неизвестен, то здесь  воз-
         можны варианты.
              5.1. Если экран  компрессирован по принципу  замены группы
         повторяющихся байтов на их величину и количество повторений,  а
         как правило,  так оно  и есть,  то эти  области сразу  видны по
         "контрасту" следующих  друг за  другом байтов,  причем еще  раз
         отметим: эти области должны быть обширны.
              Фрагмент:
              34888   F8  02  F8  03  00  FF  01  FC
              34896   03  78  00  EF  FC  01  FE  00
              34904   10  C6  87  30  CF  00  39  00
              34912   FF  00  FF  00  FF  00  FF  00
              5.2.  Бывает,  что  экраны  хранятся в виде табулированных
         стрингов, т.е. в строго заданном формате (скажем в стринге дли-
         ной 256 байтов каждый бит несет информацию о том, какой символ,
         где и как должен помещаться на экран). Это бывает в  программах
         с многочисленными экранами  и псевдографикой.   Например, MANIC
         MINER, JET SET WILLY. В  этом случае Вам поможет тот  факт, что
         распечатку Вы ведете по восемь кодов в строке. Возникает ситуа-
         ция, когда при просмотре  строк по вертикали Вы  можете уловить
         закономерности повторения одинаковых байтов.
              По этому же принципу можно  уловить и области, где в  про-
         граммах размещаются графические изображения спрайтов (движущих-
         ся объектов, персонажей и т.п.)
              Фрагмент программы:
              49424   78  87  38  78  38  38  78  38
              49432   30  08  78  81  38  04  78  81
              49440   38  05  78  81  38  04  78  81
              49448   38  08  78  81  38  04  78  81
              6. Распечатка по восемь кодов в одну строку может Вам  по-
         мочь определить еще одну важную область в программе - где  про-
+                                  - 212 -

         грамма  хранит  шаблоны  для  нестандартного генератора шрифта.
         Часто перед Вами стоит  задача переделать шрифт в  программе на
         русский. Если программа использует стандартный шрифт  "Спектру-
         ма", то Вам достаточно где-то загрузить русский шрифт и  помес-
         тить указание на него в системные переменные (мы об этом писали
         в нашей книге "Большие возможности Вашего Спектрума"). Если  же
         программа применяет свой нестандартный генератор шрифта, то это
         ничего не даст, т.к. она все равно выставит системную  перемен-
         ную CHARS  так, чтобы  она указывала  на программный  генератор
         шрифта. Поэтому Ваша задача  - отыскать, где в  программе нахо-
         дятся шаблоны символов шрифта и переделать их.
              При распечатке по восемь кодов в строке, Вы явно увидите в
         одной  из  позиций  столбец  нулей, когда будут распечатываться
         шаблоны. Пример фрагмента программы:

              ................00......................
              36984   20  00  00  3С  6E  CE  D6  E6
              36992   EC  78  00  3C  7E  18  18  18
              37000   3C  6E  00  3C  7E  06  0C  10
              37008   3E  7C  00  3E  7C  08  1C  06
              ................00.....................

              Вы, наверное,  догадались, почему  так происходит.  Дело в
         том, что шаблон символа записывается восемью байтами, по одному
         байту на каждую строку  шаблона сверху вниз. Поскольку  верхняя
         строка почти всегда пустая (чтобы обеспечить минимальный интер-
         вал между строчками при печати), то каждый восьмой байт  оказы-
         вается нулевым.
              Дополнительным указанием на то, что здесь хранятся шаблоны
         символов, служит тот факт, что все байты в приведенном фрагмен-
         те - четные.  И это тоже  не случайно. Чтобы  между буквами при
         печати был минимальный зазор, надо, чтобы правый крайний  стол-
         бец шаблона был пустым. А правой позиции каждой строки  шаблона
         соответствует нулевой бит. Если  в байте нулевой бит  выключен,
         то число четное, а если включен, то нечетное.
              Итак, пользуясь нашими рекомендациями, Вы уже примерно че-
         рез полчаса сможете грубо проанализировать структуру Вашей про-
         граммы. Конечно,  программы друг  на друга  не похожи. Конечно,
+                                  - 213 -

         эти рекомендации  являются относительно  условными, но  если Вы
         будете вести систематический  целенаправленный поиск, а  не ты-
         каться куда  попало, то  уже через  два-три дня  работы сможете
         выработать для себя свои  критерии, свои методы и  свои приемы.
         Наша же задача  - дать первичную  информацию и сэкономить  Ваше
         время.
              Обратите внимание на то, что все, о чем мы здесь говорили,
         относится к  незащищенным блокам  машинокодовых программ.  Если
         блок защищен от просмотра,  то сначала внимательно читайте  за-
         грузчик, там на каждом шагу могут быть подвохи, обманы,  ложные
         коды.
              Например, если в БЕЙСИКе Вы встретите запись:
              LET a = 15: GO TO a
         - это совсем  не значит, что  здесь выполняется переход  к 15-й
         строке. Вас,  может быть,  обманывают. Дело  в том,  что формат
         БЕЙСИК-строки  таков,  что  сначала  число  записывается в виде
         стринга,  а  затем  в  пятибайтной  форме.  Если Вы просмотрите
         БЕЙСИК-строку байт  за байтом  командой PEEK,  то увидите,  что
         каждое число, кроме номеров  строк, повторено дважды. Так  вот,
         первая запись говорит  о том, что  будет показано на  экране, а
         вторая (интегральная) -  что реально будет  исполнено. Конечно,
         нормально эти записи  соответствуют друг другу,  но программист
         легко мог сделать,  что на экране  изображается 15, а  в расчет
         идет что  угодно другое.  Не уловив  такого ложного  перехода в
         БЕЙСИК-строке, Вы  потеряете нить  и попадете  в подготовленную
         ловушку.
              Итак, все надо проверять, в том числе и БЕЙСИК-строки, же-
         лательно с помощью ДИСАССЕМБЛЕРа.
              Все вышеприведенные  фрагменты мы  взяли из  широкораспро-
         страненной программы BOMB JACK.  Мы даже указывали адреса,  где
         что содержится. Но не  спешите заглядывать в машинный  код этой
         программы. Вы ничего подобного там не увидите. Тот код, который
         содержится на ленте,  не соответствует тому,  который работает.
         Те  адреса,  куда  загружается  эта программа, не соответствуют
         тем, в которых она находится во время работы. Нестандартный за-
         грузчик (он же, кстати, выдает на бордюр красивые цветные поло-
         сы при загрузке) выполняет раскодирование информации, поступаю-
         щей от магнитофона  и переброску всей  программы в новое  место
+                                  - 214 -

         после окончания загрузки. Защита не самая серьезная, но  доста-
         точная, чтобы испортить настроение начинающему.
              Приведенные выше фрагменты взяты нами после того, как  все
         ступени предохранения были сняты.
              Разобравшись грубо со структурой программы, Вы можете  на-
         чать ее анализировать. Отыщите  главный логический блок. В  нем
         Вы найдете массу обращений к подпрограммам:
              ..........
              CALL  NN
              CALL  NN
              CALL  NN
              ..........
              Применяя  дисассемблирующую  программу,  поставьте  вместо
         CALL NN точку прерывания (BREAK POINT) и стартуйте  проверяемую
         программу прямо  из дисассемблера  (JP ADDR).  Программа начнет
         работать,  дойдет  до  точки  прерывания, остановится и вызовет
         дисассемблер. Снимите эту точку прерывания и поставьте другую в
         следующем CALL. Опять  стартуйте проверяемую программу.  Теперь
         она пройдет немного дальше, а Вы поймете, что делала та  проце-
         дура, которую  Вы перед  этим отключали.  Продолжайте в  том же
         духе. Уже через два-три часа Вы будете знать назначение  основ-
         ных процедурных блоков исследуемой программы и сможете  присту-
         пить к их детальному анализу.
              Как правило, Вы начинаете разбор готовой програмы с какой-
         то конкретной целью. В  зависимости от того, какова  Ваша цель,
         Вы можете применять какие-либо иные тактические приемы.
              Если Вы хотите модернизировать программу потому, что коли-
         чество попыток на ее прохождение Вам недостаточно, то Вы можете
         применять такую стратегию.
              Допустим, Вам дано всего четыре попытки. Очевидно,  где-то
         в программе есть переменная, и ей отведен адрес, в котором хра-
         нится количество оставшихся попыток. Найти этот адрес -  задача
         непростая, но ведь как-то в начале работы там было  установлено
         число 4. С большой  вероятностью можно полагать, что  оно уста-
         навливалось сначала в аккумуляторе, а потом пересылалось в  ад-
         рес. Если это так, то где-то в программе должна быть команда LD
         A,4 (машинный код 3E04). Напишите несложную программу на БЕЙСИ-
         Ке, которая просмотрит всю  память исследуемой программы и  вы-
+                                  - 215 -

         даст Вам адреса, в которых  она встретила сочетание кодов 3E  и
         04. Поверьте,  их будет  очень немного.  Теперь с  помощью POKE
         дайте в найденный адрес вместо 04 скажем 05 или 25. Посмотрите,
         что получилось. Если Вы  работаете с дисассемблером, то  он уже
         имеет команды на поиск заданного стринга и вся задача упрощает-
         ся.
              Если Вы ставите перед собой задачу адаптации программы на
         русский язык, то Вам надо прежде всего две вещи:
              - найти, где в программе находится шрифт;
              - найти, где в программе находятся тексты сообщений, меню
         и т.п.
              Шрифт можно  искать по  какому-либо символу,  например, по
         восклицательному знаку. Поскольку как бы шрифт ни  изображался,
         восклицательный знак в  основной своей части  представляет вер-
         тикальную палочку, то в  записи его шаблона должны  присутство-
         вать подряд по крайней мере три одинаковых байта.
              Напишите  программу  на  поиск  по  памяти трех одинаковых
         байтов, отличных от нуля, запустите ее и проверьте те места, на
         которые она Вам укажет.
              Программу на поиск текстов сообщений также несложно  напи-
         сать.  Логика  ее  работы  может  быть такой. Найти все случаи,
         когда подряд следуют пять  байтов, каждый из которых  больше 40
         (28 HEX), но меньше 122 (7A HEX).
              Задач перед Вами может стоять сколько угодно - от  желания
         постичь премудрости  машинного программирования  до организации
         опроса по внешнему порту монетоприемника с целью выяснения  пи-
         кантного вопроса  "А не  забыл ли  заигравшийся клиент опустить
         очередные двадцать копеек?", и все, конечно, осветить невозмож-
         но. Думайте, ставьте тесты, анализируйте результаты и, насколь-
         ко возможно, автоматизируйте свою работу. Поручайте  компьютеру
         самому производить поиски, сравнения, ставить эксперименты.
              Мы не  даем тексты  несложных поисковых  программ, так как
         полагаем, что Вы легко их  напишете сами, но на всякий  случай,
         если у Вас нет  под рукой удобного ДИСАССЕМБЛЕРа,  даем листинг
         программы шестнадцатиричного вывода по восемь кодов в строке.



+                                  - 216 -

                                   HEXOUT
                                   ~~~~~~
         10 INPUT "begin",beg
         20 INPUT "end",end
         30 DIM a$(8,3),DIM d(8)
         40 FOR i=beg TO end STEP 8
         50 LET b$=""
         60 FOR k=1 TO 8
         70 LET d(k) = PEEK(i+k-1)
         80 GO SUB
         90 LET b$=b$+a$(k)
         100 NEXT k
         110 GO SUB 1000
         120 PRINT w$;b$
         130 PRINT
         140 NEXT i
         500 LET h=INT(D(k)/16)
         510 LET l=d(k)-h*16
         520 LET h$=CHR$(h+48+7*(h>9))
         530 LET l$=CHR$(l+48+7*(l>9))
         540 LET a$(k)=h$+l$+"_"
         550 RETURN
         1000 LET a1=INT(i/16/16/16)
         1010 LET rez=i-a1*16*16*16
         1020 LET a2=INT(rez/16/16)
         1030 LET rez=rez-a2*16*16
         1040 LET a3=INT(rez/16)
         1050 LET a4=rez-a3*16
         1060 LET m$=CHR$(a1+48+7*(a1>9))
         1060 LET m$=CHR$(a1+48+7*(a1>9))
         1070 LET n$=CHR$(a2+48+7*(a1>9))
         1080 LET p$=CHR$(a3+48+7*(a1>9))
         1090 LET q$=CHR$(a4+48+7*(a1>9))
         1100 LET w$=a$ + n$ + p$ + q$ + "__"
         1110 RETURN



+                                  - 217 -

         7. ОБЗОР ТИПИЧНЫХ ОШИБОК, ВОЗНИКАЮЩИХ ПРИ ПРОГРАММИРОВАНИИ
                              В МАШИННЫХ КОДАХ.

                             Классификация ошибок.
                             ~~~~~~~~~~~~~~~~~~~~~
         1. Перестановка операндов.
         2. Неправильное использование флагов.
         3. Путаница в использовании регистров и регистровых пар.
         4. Путаница в работе с адресами и с данными.
         5. Неправильная обработка массивов.
         6. Неучет косвенных эффектов.
         7. Неправильное задание начальных условий.
         8. Ошибки, связанные с неправильной организацией программ.

                         7.1. Перестановка операндов.
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Здесь наиболее характерны три типа ошибок. Чтобы  избежать
         их, надо твердо помнить три правила.
              1. В командах копирования регистров, например LD D,reg со-
         держимое регистра REG  копируется в регистр  D, а не  наоборот.
         Это одна из самых частых ошибок при программировании в машинных
         кодах.
              2. Часто забывают, что 16-битные данные хранятся в  памяти
         в следующем  порядке: сначала  младший байт,  а потом  старший.
         Особенно часто ошибка возникает в операциях загрузки  регистров
         и в операциях между стеком и регистровыми парами.
              3. Команда сравнения CP во время работы вычитает свой опе-
         ранд из  аккумулятора, а  не наоборот.  Флаги выставляются так,
         как будто было выполнено вычитание A-N.

                   7.2. Неправильное использование флагов.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              1. Команды загрузки регистров LD не влияют на флаги. Чтобы
         установить флаги для последующей проверки, надо применять  опе-
         рации AND, DEC, INC, OR, XOR.
              2. Часто путают состояние флага нуля (Z). Если после  опе-
         рации сравнения операнды оказываются равными, т.е. разность ме-
         жду ними равна нулю,  то флаг включается, т.е.  устанавливается
+                                  - 218 -

         1.  Возникает мнемонический  конфуз "если результат операции  -
         ноль, то  флаг нуля  - не  ноль". Это  приводит к неправильному
         применению JR NZ, N и JR Z,N.
              3. В операциях сравнения  CP флаг С указывает,  какой опе-
         ранд больше.  Если аккумулятор  больше, то  флаг выключен, если
         больше операнд, то включен, но если они равны, то флаг выключа-
         ется. Получается, что  по этому флагу  проверяется альтернатива
         для аккумулятора: БОЛЬШЕ ИЛИ РАВЕН/МЕНЬШЕ.
              А если Вам  надо проверить альтернативу  БОЛЬШЕ/МЕНЬШЕ ИЛИ
         РАВЕН? Тогда перед операцией сравнения Вы должны добавить  еди-
         ницу к операнду или вычесть единицу из аккумулятора.
              4. Программисты хорошо помнят, что в арифметических опера-
         циях с 16-разрядными  регистрами DEC и  INC не влияют  на флаги
         вообще, а ADD влияет только на флаг переноса, но забывают,  что
         ADC и SBC влияют на все флаги.

               7.3. Путаница с регистрами и регистровыми парами.
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Здесь  ошибки  возникают,  когда  пытаются  применить  для
         8-разрядных операндов команды, предназначенные для 16-разрядных
         и наоборот. К счастью, ошибки этой группы возникают только  при
         программировании в ассемблирующей программе, а она при компиля-
         ции сама найдет эти ошибки и укажет на них. Тем не менее,  надо
         помнить несколько простых правил и руководствоваться ими:
              ADC, ADD,  DEC, INC,  LD, SBC  могут использоваться  как с
         8-битными операндами, так  и с 16-битными  регистровыми парами,
         причем ADD, DEC, INC и LD могут также применяться и в работе  с
         индексными регистрами.
              AND, OR, SUB, XOR применимы только к 8-битным операндам.
              EX, POP, PUSH - применимы только к 16-битным операндам.
              Часто  пользуются  косвенной  адресацией через регистровую
         пару HL.  Например, LD  A,(HL); LD  B,(HL)... и  т.п. Но иногда
         делают  и  вполне  законную,  но  не  очень корректную операцию
         LD L,(HL), после которой нарушается содержимое HL. То же  отно-
         сится и к операции LD H,(HL).



+                                  - 219 -

                   7.4. Путаница в работе с адресами и данными.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Это самая распространенная  ошибка при программировании  в
         машинных кодах или на языке АССЕМБЛЕРа. Так, LD при  выполнении
         копирования данных из регистра в память или из памяти в регистр
         всегда  требует  указания  адреса.  Этот  адрес должен стоять в
         скобках. Короче говоря, все, что не стоит в скобках,  АССЕМБЛЕР
         воспринимает  как  данные,  а  все,  что  стоит в скобках - как
         адреса. Если Вы забудете  поставить скобки, то результат  может
         быть совершенно непредсказуемым.
              Часто возникает следующая ошибка. Допустим, Вы имеете  на-
         бор процедур для выполнения каких-либо операций. Допустим, где-
         то в памяти Вами организована таблица адресов входа в эти  про-
         цедуры. Правильная последовательность действий при этом такова:
         взять адрес  из таблицы,  поместив, допустим  в HL,  - здесь он
         фигурирует  как  данные;  а  далее  стартовать процедуру с того
         адреса, на который  указывает HL -  здесь он уже  выступает как
         адрес. На практике же часто пытаются стартовать процедуру пере-
         ходом в  таблицу, где  содержится настоящий  адрес старта.  Это
         адрес старта, но  это не место  старта. Место старта  находится
         там, куда указывает адрес старта.
              Запомните также простое правило: DJNZ, JP, JR и CALL всег-
         да требуют после себя  указания адреса (или величины  смещения,
         что в принципе одно и то же).

                   7.5. Неправильная обработка массивов.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Наиболее типичными ошибками здесь являются:
                 - выполнение лишнего цикла вычислений;
                 - недовыполнение цикла вычислений.
              Обратите серьезное внимание  на широкоизвестный факт,  что
         если  массив  начинается  с  адреса  BASE  и кончается в адресе
         BASE+N, то этот массив имеет N+1 элемент. В этом и кроется  ос-
         новная причина ошибок. Забывают использовать либо первый,  либо
         последний элемент. С  другой стороны, если  Ваш массив имеет  N
         элементов, то  он должен  закончиться в  адресе BASE+N-1. Часто
         же продолжают вычисления  до адреса BASE+N, т.е. "прихватывают"
         лишний элемент.
+                                  - 220 -

                   7.6. Неучет косвенных эффектов.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Вот список косвенных  эффектов, которые необходимо  учиты-
         вать при программировании. Невнимание к этим особенностям  при-
         водит к ошибкам.
              1.  Все  логические  операции  кроме  CPL  сбрасывают флаг
         CARRY.
              2. В операциях LD  rp,(ADDR); LD (ADDR),rp; LD  xy,(ADDR);
         LD (ADDR),xy участвует не  только указанный адрес, но  и адрес,
         следующий за ним.
              3. Операции POP, PUSH, CALL, RET, RET, RETN, RST влияют на
         указатель стека.
              4. Операции CALL и RST засылают адрес на стек.
              5. Операция DJNZ относится не к аккумулятору, как большин-
         ство других операций, имя регистра в которых не указывается,  а
         к регистру B.
              6. Команды блочного поиска, сравнения, перемещения  байтов
         оказывают косвенное влияние  на содержимое регистровых  пар BC,
         DE, HL.
              7. В  командах LDD,  LDI, CPD,  CPDR, CPI,  CPIR флаг  P/O
         используется не по назначению, а служит для указания на то, что
         счетчик байтов в BC уменьшился до нуля.
              8. Команды ротации в  BCD-арифметике RRD, RLD вовлекают  в
         ротацию содержимое регистра HL.

                   7.7. Неправильное задание начальных условий.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              1. Не думайте, что если Вы не используете какие-либо ячей-
         ки памяти, то там должен быть 0. В начале работы программы, при
         инициализации желательно выставлять  в рабочей области  ОЗУ на-
         чальные значения.
              2. При начале работы программы установите в регистрах и во
         флагах начальные значения, чтобы избежать неопределенностей.
              3. Прежде, чем давать команду косвенной адресации,  потру-
         дитесь выставить адрес  в регистре, через  который производится
         адресация. Не полагайтесь на то, что он уже давно там есть.


+                                  - 221 -

            7.8. Ошибки, связанные с неправильной организацией программ.
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              1. Иногда программисты  забывают сохранить результат.  Вы-
         полнив расчеты и получив в итоге результат в аккумуляторе,  тут
         же засылают в аккумулятор новые данные для других вычислений.
              2. Внимательно смотрите за всеми ветвлениями в  программе.
         Бывает, что управление передается процедурам инициализации про-
         граммы, хотя это вовсе и не нужно.
              3.  В  сложных  программах  нередко оказывается запутанным
         порядок  исполнения  процедур.  Если  Вы  плохо  разбираетесь в
         структуре  собственной  программы,  может  произойти исполнение
         блоков, которые исполнять не надо. Не забывайте ставить  вокруг
         них обходные пути.

