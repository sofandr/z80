
         00...7F к числу из диапазона 80...FF или при вычитании - наобо-
         рот. Одним словом, он включается, если по правилам дополнитель-
         ной двоичной арифметики возникает смена знака содержимого акку-
         мулятора, неважно в какую сторону.
              Точно установить какие операции влияют на этот флаг как на
         флаг четности, какие как  на флаг переполнения, а  какие вообще
         не влияют, Вы можете по таблицам нашего "Справочника...".



+                                  - 57 -

                          5.10. ОПЕРАЦИИ В ЦИКЛЕ

              Очень часто  в программах  бывает нужным  повторить какой-
         либо блок  вычислений N  раз. В  БЕЙСИКе для  этих целей служит
         оператор цикла:
                     FOR i = 1 TO N
                     ..............
                     NEXT i
              Все, что находится между операторами FOR и NEXT будет пов-
         торено N раз. При этом параметр i, называемый параметром цикла,
         будет с каждым проходом  увеличиваться на единицу и,  когда до-
         стигнет N, выполнение цикла  будет прервано и работа  программы
         продолжится с оператора, следующего за NEXT.
              В машинных кодах для этой цели служит мощная команда  DJNZ
         S. Эта команда относится к регистру B процессора. Когда процес-
         сор встречает эту команду,  он уменьшает на единицу  содержимое
         регистра B, проверяет его на ноль, и, если ноль пока не достиг-
         нут, выполняет переход на S байтов. Величина смещения S  задана
         в двоичной дополнительной форме  и переход может быть  как впе-
         ред, так и назад, но чаще, конечно, назад. Вычисления  повторя-
         ются до тех пор, пока не будет достигнут 0 в регистре B.
              Мнемоника - DJNZ S;    Код - 10 S.
              Поясним это на примере.
              Вы уже знаете, что когда процессор встречает команду  NOP,
         он ничего не делает, т.е. просто выдерживается пауза. Продолжи-
         тельность ее - 4 тактовых цикла. Длительность такта зависит  от
         частоты задающего  кварца Вашего  компьютера и  может несколько
         меняться от  машины к  машине. Но,  поскольку она  примерно 3,5
         МГц,  то  продолжительность  одного  цикла - доли микросекунды.
         Предположим, что Вы хотите, чтобы процессор выдержал паузу при-
         мерно 200 тактовых циклов. Вы можете, конечно, поместить подряд
         50 команд NOP, но это очень грубо и, к тому же, наносит большой
         ущерб количеству свободной оперативной памяти.
              Воспользуемся возможностью организации цикла вычислений и
         многократным повторением команды NOP. По таблицам  "Справочни-
         ка..." можно найти, что время выполнения команды DJNZ занимает
         13 тактовых циклов, если в регистре S не 0 и 8 циклов, если 0.
              Всего, чтобы пауза длилась примерно 200 тактов, надо пов-
+                                 - 58 -

         торить команду NOP 12 раз:
                  12*4 + 11*13 + 1*8 = 48 + 143 + 8 = 199
              Тогда процедура будет выглядеть так:

              Мнемоника       Код              Комментарий.
               LD B,12         06      Загрузка в регистр B числа 12
                               0C      0C HEX = 12 DEC
               NOP             00      Пауза
               DJNZ 253        10      Уменьшить содержимое регистра B
                                       на  единицу
                               FD      и переход назад на 3 байта.

                      5.11. КОМАНДЫ РАБОТЫ СО СТЕКОМ

              Эти команды  позволяют программисту  копировать содержимое
         регистровых пар на стек и, наоборот, вызывать их оттуда в  про-
         цессор. Таким  образом, за  один прием  пересылаются сразу  два
         байта, т.е. двухбайтное  число (как правило,  это адрес, но  не
         всегда). Кроме того, в этой же группе есть команды, которые по-
         зволяют  производить  обмен  содержимого  некоторых   регистров
         процессора.
              Рассмотрим в этой группе три подгруппы команд.

                   5.11.1. Команды сохранения данных на стеке.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Эти команды начинаются с мнемоники PUSH, которой  подходит
         несколько несерьезный русский эквивалент ЗАТОЛКНУТЬ (в  дальний
         ящик). Итак, они применяются, когда надо временно сохранить  до
         дальнейшей потребности содержимое регистровых пар.
              Мнемоника       Код        Мнемоника         Код
               PUSH AF         F5         PUSH HL           E5
               PUSH BC         C5         PUSH DE           D5
               PUSH IX       DD E5        PUSH IY          FD E5
              Сначала на стек переносится старший байт, а затем младший.
         После операции PUSH указатель стека (регистр SP) уменьшается на
         две единицы. Уменьшается потому, что стек "растет" сверху вниз.
         Мы об этом уже говорили.

+                                  - 59 -

                     5.11.2. Команды вызова данных со стека.
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              По этим командам производится снятие данных со стека и за-
         грузка их в необходимый регистр. Следует подчеркнуть, что  дан-
         ные, находящиеся на стеке,  ни к какому регистру  не привязаны.
         Независимо от того, из какого регистра они были выгружены,  за-
         гружать их можно  в любой другой  регистр и вообще  нет никакой
         физической возможности узнать из какого регистра эти данные вы-
         гружались. Если это важно, программист сам должен за этим  сле-
         дить.
              Мнемоника команд, вызывающих  данные со стека,  начинается
         со слова POP ("ВЫТОЛКНУТЬ").
              Мнемоника       Код        Мнемоника         Код
               POP AF          F1         POP HL            E1
               POP BC          C1         POP DE            D1
               POP IX        DD E1        POP IY          FD E1

                   5.11.3. Команды обмена со стеком.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Этих команд три. Они начинаются с мнемоник EX (EXCHANGE  -
         ОБМЕНИВАТЬ) и служат для того, чтобы отправить на стек содержи-
         мое регистровой  пары, а  содержимое вершины  стека отправить в
         эту регистровую пару. То  же самое можно сделать  и использовав
         еще один регистр в качестве временного места хранения, но  при-
         менением команд обмена это делается проще.
                    Мнемоника            Код
                    EX (SP),HL            E3
                    EX (SP),IX          DD E3
                    EX (SP),IY          FD E3

                   5.11.4. Замечания к операциям со стеком.
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              Стек процессора - машинный стек. Его не следует путать  со
         стеком GO SUB, который организуется при работе в БЕЙСИКе и слу-
         жит для запоминания номера  строки, из которой вызывалась  под-
         программа, Его также не следует путать со стеком  калькулятора.
         "Спектрум" имеет калькулятор, который управляется  процедурами,
         размещенными в ПЗУ, и может использоваться при программировании
+                                  - 60 -

         в  машинных  кодах.  С  ним  мы познакомимся довольно глубоко в
         разделе 5.13.
              Машинный стек служит не  только для того, чтобы  обеспечи-
         вать программисту удобное место для временного хранения данных.
         Его основное назначение - хранить адреса, из которых вызываются
         подпрограммы. Это нужно для  того, чтобы по завершении  подпро-
         граммы процессор знал, куда ему надо вернуться для  продолжения
         вычислений. В связи с этим, при работе со стеком, от Вас требу-
         ется определенная внимательность.
              Если Вы находитесь в  подпрограмме, то все, что  Вы помес-
         тите на стек, должно быть снято оттуда до того, как  произойдет
         выход из подпрограммы в вызывающую программу. С другой стороны,
         поскольку выход выполняется по адресу, находящемуся в двух бай-
         тах вершины стека, Вы  можете искусно управлять логикой  работы
         программы, манипулируя числами, находящимися на вершине  стека,
         в частности, так организуются сложные вычисления в программах.

                         5.12. ВЫЗОВ ПОДПРОГРАММ

              В БЕЙСИКе подпрограммы  вызывались с помощью  оператора GO
         SUB, а возврат после исполнения подпрограммы выполнялся  коман-
         дой RETURN.
              В машинных кодах  им эквивалентны команды  CALL - ВЫЗОВ  и
         RET - ВОЗВРАТ.

                         5.12.1. Команды вызова.
                         ~~~~~~~~~~~~~~~~~~~~~~~
              Вызов может быть безусловным или сопровождаться каким-либо
         условием, связанным  с проверкой  состояния флагов  регистра F.
         Всего имеется 9 команд для вызова подпрограмм.

               Мнемоника       Код         Комментарий
                CALL NN       CD NN    Это безусловный вызов процедуры,
                                       находящейся по адресу NN.
                CALL C,NN     DC NN    Вызов подпрограммы, если флаг
                                       переноса включен.
                CALL NC,NN    D4 NN    Вызов подпрограммы, если флаг
                                       переноса выключен.
+                                  - 61 -

               Мнемоника       Код         Комментарий
                CALL Z,NN     CC NN    Вызов подпрограммы, если флаг
                                       нуля включен.
                CALL NZ,NN    C4 NN    Вызов подпрограммы, если флаг
                                       нуля выключен.
                CALL N,NN     FC NN    Вызов подпрограммы, если флаг
                                       знака включен.
                CALL P,NN     F4 NN    Вызов подпрограммы, если флаг
                                       знака выключен.
                CALL PE,NN    EC NN    Вызов подпрограммы, если флаг
                                       переполнения/четности включен.
                CALL PO,NN    E4 NN    Вызов подпрограммы, если флаг
                                       переполнения/четности выключен.

                       5.12.2. Возврат из подпрограммы.
                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

              Этих команд тоже 9. Они начинаются с мнемоники RET.  Когда
         процессор встречает такую команду, он снимает два верхних числа
         с машинного стека  и отправляет их  в программный счетчик  (ре-
         гистр PC). Имейте в  виду, что восстановленный адрес  из машин-
         ного стека может быть и  не тем, который был туда  отправлен по
         команде CALL. Вы могли его и изменить как намеренно, так и  не-
         намеренно.
           Мнемоника       Код         Комментарий
            RET             C9      Безусловный возврат в вызывающую
                                    программу.
            RET C           D8      Возврат, если флаг переноса включен.
            RET NC          D0      Возврат, если флаг "C" выключен.
            RET Z           C8      Возврат, если флаг нуля включен.
            RET NZ          C0      Возврат, если флаг нуля выключен
            RET M           F8      Возврат, если флаг знака включен.
            RET P           F0      Возврат, если флаг знака выключен.
            RET PE          E8      Возврат, если флаг переполнения/
                                    четности включен.
            RET PO          E0      Возврат, если флаг переполнения/
                                    четкости выключен.

+                                 - 62 -

                      5.13. КОМАНДЫ ОБРАЩЕНИЯ К ПЗУ

              Разработчики процессора Z-80  предусмотрели в нем  возмож-
         ность легкого  и быстрого  вызова наиболее  часто употребляемых
         подпрограмм, если  они размещены  в нижних  областях памяти.  У
         "Спектрума" в нижних областях находится ПЗУ и эти команды  поз-
         воляют к нему обращаться без использования конструкции CALL NN.
         Эти команды  начинаются с  мнемоники RST  (RESTART -  ПОВТОРНЫЙ
         СТАРТ). В этой подгруппе 8  команд. Каждая из них обращается  к
         ПЗУ и стартует процедуру, расположенную по адресу, указанному в
         команде.
                Мнемоника       Код        Эквивалент
                 RST 0          C7         CALL 0000
                 RST 8          CF         CALL 0008
                 RST 10         D7         CALL 0010
                 RST 18         DF         CALL 0018
                 RST 20         E7         CALL 0020
                 RST 28         EF         CALL 0020
                 RST 30         F7         CALL 0030
                 RST 38         FF         CALL 0038
              Некоторыее из  этих процедур  используются интерпретатором
         БЕЙСИКа и при работе в машинных кодах необходимость в них прак-
         тически не  возникает. Другие  же используются  чрезвычайно ак-
         тивно, без них трудно обойтись.

                            5.13.1. Команда RST 0.
                            ~~~~~~~~~~~~~~~~~~~~~~
              По этой команде происходит запуск процедуры  инициализации
         компьютера. Эффект от действия этой команды такой же, как и  от
         выключения и повторного включения питания. Из БЕЙСИКа этот  ре-
         зультат достигается командой RANDOMIZE USR 0.

                           5.13.2. Команда RST 8.
                          ~~~~~~~~~~~~~~~~~~~~~~
              Это старт процедуры обработки ошибки. В результате ее  ра-
         боты в системную переменную  ERR NR засылается код  ошибки. Ма-
         шинный стек очищается.

+                                  - 63 -

                           5.13.3. Команда RST 10.
                           ~~~~~~~~~~~~~~~~~~~~~~~
              Это точка  входа системной  программы, выполняющей  печать
         символов на экране или на принтере, но она может применяться  и
         для печати токенов ключевых  слов, цветовых элементов, а  также
         управляющих символов, например AT, TAB.
              В ПЗУ "Спектрума" имеются и более мощные средства, способ-
         ные выполнить печать сразу целых  строк, но они в своей  работе
         обязательно используют команду RST 10.
              Выбор, куда выполнять  печать - на  экран или на  принтер,
         зависит  от  того,  какой  канал  открыт в данный момент. Канал
         может открываться  из БЕЙСИКа  командой OPEN$  или из машинного
         кода путем вызова соответствующей процедуры из ПЗУ.
              Более подробно  на примерах  мы рассмотрим  работу команды
         RST 10 во  второй части -  "Практикум...". Весьма подробно  эта
         команда рассмотрена вместе с соответствующими процедурами ПЗУ в
         нашей книге "Элементарная графика".

                          5.13.4. Команда RST 18.
                          ~~~~~~~~~~~~~~~~~~~~~~~
              Процедура,  находящаяся  по  этому  адресу,  выполняет при
         работе интерпретатора прем очередного интерпретируемого  симво-
         ла, находящегося в системной переменной CHADD и проверку его на
         то, является ли он печатным или нет (управляющим кодом,  цвето-
         вым кодом и т.п.).

                          5.13.5. Команда RST 20.
                          ~~~~~~~~~~~~~~~~~~~~~~~
              Эта процедура выполняет последовательный просмотр символов
         вплоть до конца БЕЙСИК-строки. Так же, как и RST 18,  использу-
         ется в интерпретаторе БЕЙСИКа.

                           5.13.6. Команда RST 28.
                           ~~~~~~~~~~~~~~~~~~~~~~~
              Инициализирует внутренний калькулятор компьютера. Это точ-
         ка входа  обширного пакета  программ. Поскольку  в повседневной
         работе программисту не  обойтись без выполнения  математических
         расчетов, а  работа калькулятора  "Спектрума" в  машинных кодах
+                                  - 64 -

         чрезвычайно слабо освещена, мы здесь даем подробнейшие указания
         по работе с ним, несмотря  на то, что эта информация  относится
         скорее к ПЗУ, а не к процессору.
              Итак, встроенный калькулятор "Спектрума" дает Вам  возмож-
         ность выполнения сложных  математических вычислений без  выхода
         из машинных кодов. Более того, можно сказать, что он  позволяет
         Вам выполнять многое такое, что в БЕЙСИКе просто невозможно.
              Очевидным недостатком процессора Z-80 является то, что его
         система команд не позволяет выполнять математические и  арифме-
         тические операции более сложные,  чем сложение и вычитание  не-
         больших целых чисел.  Хотя те, кто  работает со "Спектрумом"  в
         машинных кодах,  могут воспользоваться  процедурой ПЗУ,  разме-
         щенной по адресу 30A9  и предназначенной для перемножения  двух
         небольших целых чисел. Вызывается она CALL A9 30. Первый сомно-
         житель должен находиться в регистровой паре HL, второй - в  ре-
         гистровой паре DE. Результат помещается в регистровую пару  HL.
         Во время  работы этой  процедуры не  портится содержимое других
         регистров, кроме регистра A. Если при выходе из этой  процедуры
         результат оказывается слишком большим, включается флаг переноса
         (флаг C регистра F).
              Даже если принять во внимание наличие этой процедуры, как
         быть с делением, с операциями над дробями, квадратными корнями,
         тригонометрическими функциями и т.п.?
              Фактически такая ограниченность  машинных кодов связана  с
         тем, что нормально регистры процессора предназначены для работы
         с малыми целыми числами от 0  до 255. Вы не можете разделить  1
         на 2  потому, что  нет регистра,  который мог  бы хранить число
         0.5.  Калькулятор же обходит все эти проблемы за счет того, что
         работает с числами, записанными не в двухбайтной, а в пятибайт-
         ной форме, что позволяет выражать не только целые, но и  дейст-
         вительные числа.
              Такая форма представления действительных и целых чисел на-
         зывается ИНТЕГРАЛЬНОЙ. Кстати, при работе в БЕЙСИКе все  числа,
         которые участвуют в Вашей программе, кроме номеров строк,  тоже
         представлены в интегральной форме. Проверьте это. Введите стро-
         ку 10 LET AAA=10*20, а  теперь посмотрите, как она вписалась  в
         память: FOR I=23755 TO 23781: PRINT I, PEEK I: NEXT I .
              Давайте рассмотрим, как  эти числа представляются  в пяти-
+                                  - 65 -

         байтной форме.

                            ПОЛОЖИТЕЛЬНЫЕ ЦЕЛЫЕ ЧИСЛА.
              Они могут принимать значения от 0 до 65535. В принципе для
         их записи хватило бы и двух байтов. Если старший байт мы  назо-
         вем hh, а младший - ll, то в пятибайтной форме такое число  за-
         пишется:
                                 00 00 ll hh 00
              Как видите, опять младший байт стоит впереди старшего.

                               ОТРИЦАТЕЛЬНЫЕ ЧИСЛА.
              Они могут принимать значения от -1 до -65535. При этом  -1
         выглядит как FFFF; -2  как FFFE и т.д. В пятибайтной форме  они
         записываются:
                                 00 FF ll hh 00

                              ДЕЙСТВИТЕЛЬНЫЕ ЧИСЛА.
              "Спектрум" в состоянии работать с действительными  числами
         из диапазона от  -1.7014118*10^38  до  +1.7014118*10^38. Числа,
         выходящие за пределы этого диапазона, недоступны для компьютера
         и вызывают сообщение об ошибке:
                  6   Number too big    (6   Число слишком велико)
              В  пятибайтной  (интегральной)  форме  такие большие числа
         хранятся в  экспоненциальном представлении.  В старшем  (пятом)
         байте хранится экспонента  числа, увеличенная на  128, а в  ос-
         тальных четырех байтах - мантисса. Причем старший бит четверто-
         го байта указывает  на знак мантиссы.  Если он включен  - число
         отрицательное, если же выключен - положительное.
                          Байт  4
               ╔═════════╦═╤═╤══════╦══════════╦══════════╦═══════════╗
               ║ Байт 5  ║ │ │......║ Байт 3   ║ Байт  2  ║ Байт  1   ║
               ╚════╤════╩╤╧╤╧══════╩══════════╩══════════╩══════════╤╝
                    │     │ └───────────────────┬────────────────────┘
          Экспонента + 128│                  Мантисса
                    Знак мантиссы
              Для тех, кто не помнит, что такое экспоненциальная  форма,
         кратко поясним.
              Предположим, что Вам надо записать какое-то очень  большое
+                                 - 66 -

         число. Если Вы  будете его делить  раз за разом  на два до  тех
         пор, пока оно не станет по абсолютной величине меньше  единицы,
         то сколько раз Вам пришлось его делить - это и есть экспонента,
         а то, что осталось после последнего деления - мантисса. Обрати-
         те внимание на то, что мантисса всегда больше 0,5, но меньше 1.
         Мантисса хранится в  четырех младших байтах,  а экспонента -  в
         пятом (старшем).  Обратная операция  выполняется так:  мантиссу
         надо умножить на двойку в степени экспоненты.
              Если  же  число  было  малой  десятичной  дробью, например
         0,0000375, то делить на два его, конечно, бессмысленно. В  этом
         случае его нужно умножать на два до тех пор, пока оно не станет
         больше, чем  0.5, но  меньше, чем  1. Только  экспонента в этом
         случае считается отрицательной. На знак экспоненты указывает ее
         величина. Если  в старшем  байте стоит  число, большее  128, то
         экспонента положительная, а если меньше, то отрицательная.
              "Спектрум" ограничен  и в  работе с  очень малыми дробями.
         Числа от -1.469367*10^(-39) до +1.469367*10^(-39) он не воспри-
         нимает и считает их нулем.
              А как же в пятибайтной форме изображается ноль? Единствен-
         ная возможная и самая естественная форма:  00 00 00  00 00
              Поскольку представление дробей  в двоичной форме  выглядит
         не очень очевидным, да к  тому же может возникнуть путаница  со
         знаками, мы здесь приведем пример из книги Виккерса "БЕЙСИК ZX-
         Спектрума" (эта книга  является официальной фирменной  инструк-
         цией к компьютерам "ZX-Spectrum 16" и "ZX-Spectrum 48").
              Предположим, что  Вам надо  записать в  интегральной форме
         число 1/10. Оно меньше, чем 0,5. Будем последовательно умножать
         его на два, а когда старший разряд будет переходить за единицу,
         будем сносить ее в двоичную дробь.
              Десятиричная форма              Двоичная форма
                   0.1                           0.
                   0.1*2=0.2                     0.0
                   0.2*2=0.4                     0.00
                   0.4*2=0.8                     0.000
                         ┌─────────────> ─────────────┐
                   0.8*2=1.6                     0.0001
                         ┌─────────────> ──────────────┐
                   0.6*2=1.2                     0.00011
+                                  - 67 -

                   0.2*2=0.4                     0.000110
                   0.4*2=0.8                     0.0001100
                         ┌─────────────> ─────────────────┐
                   0.8*2=1.6                     0.00011001
                             и так далее.

              Таким образом, двоичная форма десятиричного числа 0.1:
                     0.000110011001100110011001100... и т.д.
              Сместим дробную точку вправо до первой единицы. Количество
         шагов даст нам экспоненту, а оставшаяся часть будет  мантиссой.
         В нашем случае экспонента равна -3, а мантисса -
                     0.1100110011001100... .
              Для хранения этого числа в компьютере оно преобразуется  в
         интегральную форму следующим путем:
              1) Запишем в пятом байте величину экспоненты,  увеличенную
         на 128, т.е. в нашем примере это будет 125.
              2) Запишем  первые 8  знаков мантиссы  в четвертом  байте,
         очередные 8 - в третьем и т.д.
              3) В старшем (седьмом) бите четвертого байта мантиссы  по-
         местим 0, если число положительное и 1, если число  отрицатель-
         ное.
              Итак, мы имеем:
               5 байт      4 байт     3 байт       2 байт     1 байт
              01111001    01001100   11001100     11001100   11001100
              Обратите внимание на то,  что хоть мы и  заменили значащую
         единицу в седьмом бите  четвертого байта на 0  (чтобы показать,
         что число положительное), тем не менее компьютер все же  знает,
         что здесь должна быть единица. Это происходит потому, что  ман-
         тисса всегда больше, чем 0.5,  а значит этот бит равен  единице
         ВСЕГДА, просто для положительного числа не показан.

                    ПРЕДСТАВЛЕНИЕ СТРИНГОВ В ПЯТИБАЙТНОЙ ФОРМЕ.
              Стринги (строки) можно тоже представить в пятибайтной фор-
         ме, но поскольку они могут быть длинными, то текст должен  хра-
         ниться где-то отдельно. Например, Вам надо хранить в  строковой
         переменной слово  "Спектрум". В  этом случае  пятый байт всегда
         равен нулю. Четвертый и третий байты содержат младшую и старшую
         часть адреса, в котором хранится первый символ стринга (в нашем
+                                 - 68 -

         случае "С"). Обозначим их aa, bb. Второй и первый байт содержат
         длину этого стринга. Обозначим их cc, dd. Итого:
                              00 aa bb cc dd

                             СТЕК КАЛЬКУЛЯТОРА.
              Это область памяти,  в которой калькулятор  компьютера вы-
         полняет все операции. Он работает точно так же, как  и машинный
         стек процессора. Разница состоит в том, что:
              - во-первых,  машинный стек  "растет" сверху  вниз, а стек
         калькулятора - снизу вверх;
              - во-вторых, машинный стек оперирует с двухбайтными  вели-
         чинами, которые как правило выражают адреса, а стек калькулято-
         ра оперирует с пятибайтными числами, которые выражают  действи-
         тельные числа или символьные строки (стринги).
              - в-третьих, на  место нахождения вершины  машинного стека
         указывает содержимое регистра SP (указатель стека). На  основа-
         ние (начало) стека калькулятора указывает системная  переменная
         STKBOT. Ее адрес - 23651, а длина - 2 байта. Есть еще одна сис-
         темная переменная STKEND, которая  указывает на байт ОЗУ,  сле-
         дующий за вершиной стека калькулятора. Ее адрес 23653 и длина -
         2 байта. Если стек пуст, то содержимое этих двух системных  пе-
         ременных совпадает. Самое верхнее  число на стеке, таким  обра-
         зом, располагается в адресах от (STKEND)-5 до (STKEND)-1.
         **************************************************************
         * Примечание: (STKEND) здесь стоит в скобках потому, что это *
         * косвенная адресация. Если адрес STKEND равен 23653, то     *
         * адрес (STKEND) - это то, что содержится в STKEND.          *
         **************************************************************
              Применение стека  позволяет следующим  образом работать  с
         калькулятором:
              - помещать данные на стек;
              - выполнять с ними математические операции;
              - снимать результат со стека.
              Те, кто знаком с языком программирования ФОРТ,  обнаружат,
         что операции с калькулятором очень похожи на работу в ФОРТ-сис-
         темах.


                                  - 69 -

                            КОМАНДЫ КАЛЬКУЛЯТОРА.
              Команды  калькулятора  начинаются  с  инструкции  RST   28
         (код EF) - это как  бы "включение калькулятора". За этим  кодом
         должна идти последовательность байтов, каждый из которых  явля-
         ется командой калькулятора.  Таким образом, эта  последователь-
         ность байтов является последовательностью команд. Вы,  конечно,
         знаете, что  всякая последовательность  команд представляет  из
         себя программу.  Итак, с  команды RST  28 начинается выполнение
         программы калькулятора.  Эта программа очевидно написана не  на
         БЕЙСИКе, но и не в машинных кодах. У калькулятора своя  система
         команд, отличная от системы команд процессора Z-80. Можно  счи-
         тать, что эта программа  написана в кодах калькулятора.  Завер-
         шается эта  программа командой  калькулятора "end  calc" (конец
         вычислений).  Ее код - 38. Таким образом, простейшая  программа
         калькулятора выглядит так:
               Код         Значение          Комментарий
               EF           RST 28          Включение калькулятора
               38           end calc        Выключение калькулятора
              Как видите, эта программа ничего не делает, но тем не  ме-
         нее имеет побочный эффект. Он состоит в том, что при выходе  из
         калькулятора  в  регистре  DE  процессора  находится содержимое
         (STKEND), а в регистре HL - (STKEND)-5. Другими словами, регис-
         тры HL и DE становятся указателями стека калькулятора. HL  ука-
         зывает на первый байт (байт экспоненты) числа, находящегося  на
         вершине стека, а DE  указывает на первый свободный  байт памяти
         ОЗУ, находящийся над стеком калькулятора.

                         СИСТЕМА КОМАНД КАЛЬКУЛЯТОРА
              Полная таблица системы команд калькулятора приведена в
         нашем "Справочнике по программированию в машинных кодах Z-80",
         см. третью часть нашего пособия.
              Здесь мы рассмотрим основные  команды и укажем на  те осо-
         бенности, которые должны быть учтены при программировании. Каж-
         дая команда состоит из шестнадцатиричного кода и имени, которое
         поясняет ее назначение. Мы будем записывать имя команд  кальку-
         лятора строчными буквами, чтобы  отличать их от прописных  букв
         мнемоник АССЕМБЛЕРа.
              Первая команда,  которую мы  рассмотрим -  это add (сложе-
+                                  - 70 -

         ние). Она предназначена, как следует из названия, для  сложения
         двух чисел. Они должны находиться на вершине стека  калькулято-
         ра. Работа команды  состоит в том,  что эти числа  снимаются со
         стека, а  на их  место помещается  их сумма.  Таким образом, на
         стеке оказывается на одно число меньше, чем было.  Команда  add
         называется бинарной потому, что для ее выполнения требуются два
         операнда, хотя после операции получается один результат.

                                 БИНАРНЫЕ ОПЕРАЦИИ.
              Есть еще много различных бинарных операций и функций.  Как
         и  следовало  ожидать,  бинарными  являются операции "subtract"
         (вычитание), "multiply"  (умножение), "devide"  (деление). Есть
         еще команда "power" (  возведение в степень), которая  возводит
         одно число в степень второго.

                                УНИТАРНЫЕ ОПЕРАЦИИ.
              Калькулятор имеет также и унитарные операции, которые  ис-
         пользуют только один операнд, снимая его с вершины стека и  за-
         меняя его  результатом. Такова,  например, операция  "sqr" (вы-
         числение квадратного корня). Унитарные операции оставляют длину
         стека калькулятора без изменений.
              Рассмотрим в качестве демонстрационного примера  программу
         для вычисления  корня квадратного  из суммы  синуса и  косинуса
         числа X. Перед началом программы величина X должна находиться в
         верхних пяти байтах стека калькулятора.
                              SQR (COS X + SIN X)
              Пример достаточно прост, чтобы Вы сами смогли его  просле-
         дить с помощью таблицы  системы команд калькулятора (см.  Спра-
         вочник...) и проникнуться  духом техники выполнения  вычислений
         и работы со стеком калькулятора.
         Код   Команда    Число на  Число перед  Комментарий
                          вершине       ним
         EF    RST 28         X         -        Включение калькулятора
         31  duplicate        X          X       Повторение числа на
                                                 вершине стека.
         20    cos         cos X         X       Вычисление косинуса
         01  exchange         X        cos X     Поменять местами верх-
                                                 два числа на стеке
+                                   - 71 -

         Код   Команда    Число на  Число перед  Комментарий
                          вершине       ним
         1F    sin         sin X       cos X     Вычисление синуса
         0F    add        sinX+cosX      -       Сложение
         28    sqr    sqr(sinX+cosX)     -       Вычисление квадратного
                                                 корня
         38  end calc sqr(sinX+cosX)     -       Выключение калькулятора

              В состав команд калькулятора входят также логические функ-
         ции and и or. Они работают также, как и в БЕЙСИКе.
              X and Y равно X, если Y не равен нулю, в противном  случае
         результат - 0.
              X or Y равно X, если  Y не равен нулю, в противном  случае
         результат - единица.
              Логическая функция not  дает единицу, если  оригинал равен
         нулю, в противном случае - ноль.
              Но здесь есть и две новые команды:
              less_zero (Код 36) дает единицу, если оригинал меньше ну-
         ля, в противном случае дает ноль.
              gtr_zero (Код 37) дает единицу, если оригинал больше нуля,
         в противном случае дает ноль.

              К Вашим услугам пять готовых констант, которые могут быть
         помещены на стек немедленно. Их коды от A0 до A4 включительно.
              stk_zero (код А0) помещает на стек число 0.
              stk_one  (код А1) помещает на стек число 1.
              stk_half (код A2) помещает на стек число 0.5
              stk_pi/2 (код А3) помещает на стек одну вторую числа "пи".
              stk_ten  (код А4) помещает на стек число 10 (десятиричное)
              Это очень удобно, поскольку эти числа постоянно встречают-
         ся в расчетах.

              Некоторые  функции  калькулятора  могут вызвать удивление.
         Например, Вы можете увидеть в таблице две функции usr. Это  usr
         (str) и usr (num), т.е. usr (стринг) и usr (число).
              В БЕЙСИКе есть только  одно ключевое слово USR.  Разница в
         том, что  с его  помощью в  БЕЙСИКе можно  выполнить две разные
         операции.  Например,  USR  "J"  даст  Вам адрес символа графики
+                                  - 72 -

         пользователя, помещенного для использования в графическом режи-
         ме на клавишу "J". В этой команде "J" - стринг, а не число.
              С другой стороны, USR_число даст Вам результат работы  ма-
         шиннокодовой программы, начинающейся  с адреса, заданного  этим
         числом. Попробуйте, например, PRINT 65536-USR 7962. Вы  получи-
         те, сколько байтов свободной памяти у Вас осталось.
              Калькулятор не настолько мудр. Он сам не в состоянии опре-
         делить, является ли число на вершине стека числом или  символь-
         ным стрингом. Ему надо об этом сообщить. Отсюда и необходимость
         в двух различных функциях usr.
              Более того, команда калькулятора usr (число) одна из самых
         удивительных команд набора. Вот, что она делает:
              - с вершины стека снимается число и отправляется в регист-
         ровую пару BC.  Разумеется, если оно  помещается по размеру,  а
         помещается туда только  целое положительное число.  В противном
         случае Вы получите сообщение об ошибке;
              - затем  содержимое BC  принимается за  адрес и вызывается
         программа, начинающаяся с этого адреса;
              - по завершении работы этой программы то значение регистра
         BC, которое находится там в момент выхода, помещается на верши-
         ну стека калькулятора;
              -  после  всего  этого  калькулятор переходит к исполнению
         следующей команды.

              Есть и другие инструкции, различающие стринги и числа. На-
         пример, инструкция add имеет две различные команды калькулятора
         и, соответственно, два различных кода для работы со стрингами и
         числами:
              Команда add (код 0F) складывает числа нормальным образом -
         так, что 1 + 2 = 3, в то время, как команда s_add (код 17)
         выполняет слияние стрингов, так что
                       "SPEC" + "TRUM" = "SPECTRUM".

              Интересно работает команда peek (2B). Она снимает со стека
         адрес, обращается по нему в память, находит то, что там  содер-
         жится и помещает число на вершину стека.


                                   - 73 -

                             ПАМЯТЬ КАЛЬКУЛЯТОРА
              Калькулятор "Спектрума" имеет шесть ячеек памяти. В  прин-
         ципе, как  мы увидим  позже, их  количество можно  увеличить. В
         каждой из этих ячеек можно хранить число или стринг. Набор  ко-
         манд калькулятора имеет  команды от С0  до С5 включительно  для
         того, чтобы помещать в эти ячейки число, находящееся на вершине
         стека. При этом  число с вершины  стека не снимается,  а только
         выполняется его копирование в заданную пятибайтную ячейку.
              Обратные  команды  от  Е0  до  Е5 могут вызывать число или
         стринг из памяти калькулятора и помещать его на вершину стека.
              В качестве примера рассмотрим опять же вычисление
                          SQR (SIN X + COS X),
         но уже другим способом, с использованием памяти калькулятора.
         Код   Команда   Число на    Число перед   Комментарий
                         вершине         ним

         EF     RST 28      X             -      Включение калькулятора
         C3    store M3     X             -      Помещение числа в
                                                 третью ячейку памяти
         20     cos       cos X           -      Вычисление косинуса
         E3    recall M3    X           cos X    Вызов числа из третьей
                                                 ячейки памяти
         1F     sin       sin X         cos X    Вычисление синуса
         0F     add     sin X + cos X     -      Сложение
         28     sqr   sqr(sinX+cosX)      -      Вычисление квадратного
                                                 корня
         38 end calc  sqr(sinX+cosX)      -      Выключение калькулятора

              Прежде, чем мы перейдем  к обсуждению того, как  увеличить
         количество ячеек  памяти калькулятора,  мы должны  остановиться
         еще на одном вопросе.
              Дело  в  том,  что  есть  некоторые команды калькулятора и
         процедуры ПЗУ, которые  могут нарушить содержимое  ячеек памяти
         калькулятора. Это происходит потому, что они сами их используют
         при своей работе. Это надо  знать, чтобы не совершить ошибку  в
         расчетах.
              sin, cos, tan, asn, acs, atn, ln нарушают содержимое ячеек
         памяти калькулятора M0, M1, M2.
                                  - 74 -

              exp - ячейки M0, M1, M2, M3.
              int, mod_div, get_argt - M0.
              str$ - нарушает все шесть ячеек от М0 до М5.
              usr_n -  может нарушить  или не  нарушить содержимое любой
         ячейки.
              Печать графических символов (от CHR$128 до CHR$145)  нару-
         шает ячейки М0 и М1 памяти калькулятора.
              Обращение к процедуре ПЗУ PRINT_FP, находящейся по адресу
         2DE3 и служащей для печати десятичных чисел с плавающей точкой,
         разрушает содержимое всех ячеек памяти.
              "Спектрум", строго говоря, имеет немало "жучков" (а попро-
         сту ошибок) в своем ПЗУ. Как мы указали, функция вычисления це-
         лой части числа int  нарушает содержимое нулевой ячейки  памяти
         калькулятора, но если говорить по-правде, это нарушение  проис-
         ходит только тогда, когда вычисляется целая часть отрицательно-
         го числа. Если аргумент  положительный, то ячейка М0  останется
         нетронутой.
              Функция mod_div  предназначена для  вычисления частного  и
         остатка от деления  одного числа на  другое, скажем X  и Y. Она
         должна снять со стека  два числа, выполнить вычисления  и заме-
         нить их на стеке двумя новыми числами - остатком X-Y*INT(X/Y) и
         частным INT(X/Y). К сожалению, процедура ПЗУ, которая выполняет
         эти действия,  совершенно не  принимает во  внимание тот  факт,
         что int может разрушить М0. В результате, если X -  отрицатель-
         ное число, функция mod div дает неверный результат /1.

                        РАСШИРЕНИЕ ПАМЯТИ КАЛЬКУЛЯТОРА.
              Введение в  работу более  шести ячеек  памяти основывается
         на использовании системной  переменной MEM. Она  расположена по
         адресу 5С68 (23656). Как Вы знаете, каждая единица хранения  на
         стеке  занимает  пять  байтов,  поэтому  и каждая ячейка памяти
         калькулятора должна тоже занимать пять байтов. М0 находится по
         ───────────────────────────────────────────────────────────────
         /1   Читатели, желающие более подробно ознакомиться с  ошибками
         ПЗУ "Спектрума" могут это сделать в 9-12-м выпусках нашего  пе-
         риодического издания "ZX-РЕВЮ" за 1992 год, где приведен весьма
         детальный  обзор,  выполненный  нами  по материалам иностранной
         печати.
+                                - 75 -

         адресу, который указывает МЕМ. М1 - по адресу (МЕМ)+5; М2 -  по
         адресу  (МЕМ)+0А  и  т.д.  Нормально  системная  переменная МЕМ
         содержит 5С92 (23698),  т.е. указывает на  системную переменную
         МЕМВОТ. Поскольку  МЕМВОТ имеет  30 байтов,  то в  этой области
         можно разместить ровно 6 ячеек памяти.
              Предположим, что Вы хотите иметь 32 ячейки памяти  кальку-
         лятора (это максимальное возможное количество). Первое, что Вам
         для этого надо сделать - это выделить 160 байтов свободной  па-
         мяти. Можно использовать область памяти выше RAMTOP,  предвари-
         тельно установив RAMTOP командой CLEAR. Другой способ - размес-
         тить эту память в рабочей области, что можно сделать из  машин-
         ного кода командой RST 30. Для этого надо разместить в регистре
         BC необходимое количество байтов (в нашем случае это 160 десят.
         или A0 шестнадц.) и  дать команду RST 30.  Процедура отработает
         и указанное количество байтов будет отведено. На выходе из этой
         процедуры регистр DE будет  содержать адрес первого, а  регистр
         HL - адрес последнего байта выделенной памяти. После этого все,
         что Вам нужно - это перегрузить содержимое DE в системную пере-
         менную МЕМ.
              Для работы с новыми ячейками памяти служат команды:
              С6 - для ячейки М6 (store M6);
              C7 - для ячейки М7 (store M7);
              ..............................
              DF - для ячейки M1F(store M1F);

              Вызов данных из этих новых ячеек выполняется командами  от
         Е6 (recall M6) до FF (recall M1F).
              Однако есть и  ограничения на изменение  содержимого пере-
         менной МЕМ.  Если в  ней будет  содержаться адрес,  отличный от
         предварительно установленного 5С92, то не будет работать коман-
         да калькулятора  str$ (код  2Е) и  не будет  работать процедура
         печати чисел с плавающей точкой PRINT_FP. Если Вам они  необхо-
         димы, Вы должны восстанавливать 5С92 в переменной МЕМ перед  их
         использованием.

                  ВЫПОЛНЕНИЕ ПЕРЕХОДОВ В КОДАХ КАЛЬКУЛЯТОРА.
              Для этой цели служит команда jump. Это двухбайтная  коман-
         да. В первом байте  стоит ее код -  33, а за ним  идет величина
+                                  - 76 -

         "смещения", указывающая на сколько байтов выполняется  переход.
         Инструкция очень похожа на команду машинного кода JR S, но име-
         ет отличие. Мы уже  неоднократно указывали на то,  что величина
         "смещения" отсчитывается в машинных кодах не от адреса, в кото-
         ром размещена команда JR, а от адреса, в котором находится  код
         следующей за  ней операции.  В кодах  же калькулятора  величина
         "смещения" отсчитывается именно от того адреса, в котором стоит
         команда jump.
              Величина "смещения  " задается  в двоичной  дополнительной
         форме,  поэтому  возможны  переходы  как  вперед,  так и назад.
         Вперед  на  0...127  (0...7F)  байтов  и  назад  на   -1...-128
         (FF...80) байтов.

                              ОБРАБОТКА УСЛОВИЙ.
              Калькулятор  имеет  средства  для  организации вычислений,
         аналогичных   тем,   которые   выполняет   конструкция  БЕЙСИКа
         IF...THEN. Между  IF и  THEN стоит  выражение, которое подлежит
         проверке  и  может  принимать  значения  TRUE  (ИСТИНА) и FALSE
         (ЛОЖЬ). После THEN стоит  выражение, которое выполняется в  том
         случае, если условие имеет значение TRUE.
              В кодах калькулятора может быть выполнено все то же самое.
         Кое-что, может быть, даже проще, но есть одно ограничение. Если
         в БЕЙСИКе после THEN выходным  может быть любой оператор, то  в
         кодах калькулятора выходной  может быть только  команда относи-
         тельного  перехода.  Это  означает,  что можно создавать только
         конструкции типа IF...THEN GO TO ...
              Это ограничение можно даже и не рассматривать как  ограни-
         чение, потому, что  достаточно немного изменить  структуру про-
         граммы и Вы опять можете делать что угодно.
              Сама же конструкция перехода по условию выражается в каль-
         куляторе командой jump_true. Как и команда jump это двухбайтная
         команда.  Первым  идет  код  операции  00,  а за ним величина s
         ("смещение"), задаваемая одним байтом в двоичной дополнительной
         форме. "Смещение" отсчитывается точно  так же, как и  в команде
         jump, рассмотренной выше.  Работает команда следующим  образом.
         Со стека снимается верхнее число. Если оно имеет значение TRUE,
         т.е. не  равно нулю,  выполняется переход.   Если же  со  стека
         поступил 0, то переход  не выполняется, а байт,  выражающий ве-
+                                  - 77 -

         личину "смещения" игнорируется.
              Идея использования ненулевых значений для выражения  логи-
         ческого значения TRUE и нулевых значений для выражения FALSE  -
         это не просто  удобный прием, это  основа логики работы  "Спек-
         трума". Фактически мы можем зайти так далеко, что признаем TRUE
         и FALSE иным типом данных, отличным от чисел и стрингов - логи-
         ческими данными.
              Например, команда калькулятора lt_z  (меньше, чем 0 код  -
         36) заменит число, находящееся  на вершине стека на  TRUE, если
         это число отрицательное, и на FALSE, если оно положительное.
              Другой пример. Команда not (код 30) заменит значение  TRUE
         на вершине стека на FALSE или наоборот. Такой логический подход
         (вместо числового) упрощает понимание работы программ.
              Команда калькулятора not, если  на нее смотреть под  таким
         углом  зрения,  имеет  двойное  значение. Во-первых, она меняет
         логическое значение, находящееся  на вершине стека  на противо-
         положное. Во-вторых, если  содержимое вершины стека  рассматри-
         вать как число, то после этой команды там будет 0. Таким  обра-
         зом, эта команда может быть использована для обнуления  вершины
         стека, если там был не ноль.

                              КОМАНДЫ "И" (and).
              Калькулятор  имеет  две  команды  and.  Одна  для работы с
         числами - n_and (код 08), а другая - для работы со стрингами  -
         s_and (код 10).
              Команда n_and работает достаточно прямолинейно:
                     TRUE n_and TRUE = TRUE
                     TRUE n_and FALSE = FALSE
                     FALSE n_and FALSE = FALSE
              Она может быть использована и в такой форме:
                     <число> n_and <логическое значение>
              Это же самое можно было бы сделать и в БЕЙСИКе. Попробуй-
         те:
                        PRINT (7 AND (X>9))
              Подставьте вместо X числа 10 и 8.

              Вторая команда -  s_and. Для нее  на вершине стека  должен
         быть стринг,  а за  ним следовать  логическое значение. Команда
+                                 - 78 -

         работает так. Логическое значение удаляется со стека, а  стринг
         заменяется пустым стрингом  в том и  только в том  случае, если
         логическое значение было FALSE.
              Таким образом, мы  можем с помощью  калькулятора приводить
         выражения к логическому результату. Другими словами,  рассчиты-
         вать значение выражений в виде  TRUE или FALSE, а затем  выпол-
         нять переход по условию.

                           В-РЕГИСТР КАЛЬКУЛЯТОРА.
              Микропроцессор Z-80 имеет много регистров, доступ к  кото-
         рым открывает программирование  в машинных кодах.   Калькулятор
         же имеет только один регистр - "B". В  нем можно хранить  целое
         число от 0 до 255.
              При включении  калькулятора по  команде RST  28 происходит
         автоматический перенос содержимого регистра B процессора в  ре-
         гистр B калькулятора.  Совершенно аналогично при  окончании вы-
         числений в регистр процессора B переносится то, что было в  ре-
         гистре  B  калькулятора  перед  командой  end_calc. Более того,
         "Спектрум"  имеет  системную  переменную  под  названием  B_REG
         (23655), в которой запоминается то, что было в регистре B каль-
         кулятора перед командой end_calc.
              Система команд калькулятора  имеет команду execute_B  (код
         38). Она  дает команду  на исполнение  той инструкции,  которая
         содержится  в  регистре  B.  Это  пример косвенного указания на
         команду. Таким образом, последовательностью команд:
                   RST 28       EF
                   execute_B    3B
                   end_calc     38
         можно  выполнить  любую  из  команд  калькулятора,  если ее код
         предварительно  поместить  в  B-регистр процессора. Разумеется,
         это справедливо только для однобайтных команд.

                        КОМАНДЫ, ЗАВИСИМЫЕ ОТ РЕГИСТРА "B"
              Многие команды калькулятора требуют для своей успешной ра-
         боты, чтобы в регистре B находилось какое-либо число.  Наиболее
         широко применимы из этих команд команды сравнения: =, <, >, <=,
         >=, <>.  В нашем  "Справочнике..." все  эти команды  оговорены.
         Обращаем Ваше внимание на то, что в системе команд калькулятора
+                                 - 79 -

         нет кода на загрузку в B-регистр числа. Чтобы это сделать, надо
         выйти в машинный код, загрузить  это число, а затем вновь  вер-
         нуться в калькулятор.
              Например,  Вам  нужна  команда,  проверяющая тот факт, что
         число, находящееся  на вершине  стека меньше,  чем следующее за
         ним число: n_lt. Эта команда снимает оба числа со стека и заме-
         няет их на TRUE, если первое число меньше второго, а в  против-
         ном  случае  -  на  FALSE.  Код  этой операции OD, но для того,
         чтобы  она  успешно  работала,  необходимо,  чтобы в регистре B
         также находилось число 0D.  Установка там этого числа  выполня-
         ется с выходом из калькулятора:
              Мнемоника       Код        Комментарий
              .........        ..        ...............
              end_calc         38        Выход из калькулятора
              LD B,OD          06        Загрузить в регистр В число OD.
                               OD
              RST 28           EF        Вызов калькулятора
              n_lt             OD        Сравнение чисел
              .........        ..        ......... и т.д.
              Точно также команда s_eq (код 16), которая проверяет  факт
         равенства двух стрингов, требует, чтобы в регистре B находилось
         число 16. Таких команд у калькулятора немало. Будьте вниматель-
         ны при работе с ними.

                   КОМАНДЫ, ИЗМЕНЯЮЩИЕ СОДЕРЖИМОЕ В-РЕГИСТРА
              Выше мы уже говорили, что есть команды, изменяющие  содер-
         жимое некоторых ячеек  памяти калькулятора. Теперь  же дополни-
         тельно отметим, что  есть команды, нарушающие  содержимое В-ре-
         гистра. Это, например, тригонометрические функции sin cos,  tan
         и др.  В таблице  системы команд  (см."Справочник...") все  эти
         команды оговорены.

                        ОРГАНИЗАЦИЯ ЦИКЛОВ ВЫЧИСЛЕНИЙ
              Аналогично программированию в машинном коде система команд
         калькулятора имеет команду djnz (DECREMENT and JUMP if NOT ZERO
         = УМЕНЬШИТЬ содержимое регистра на единицу и, если оно НЕ РАВНО
         НУЛЮ, ПЕРЕЙТИ на заданное количество байтов). Код этой  команды
         35. Также, как  и команды jump  и jump_true, она  требует после
+                                  - 80 -

         себя указания величины "смещения" s. Эта команда тоже двухбайт-
         ная.
              Команда работает  так. Когда  она встречается,  происходит
         уменьшение на 1 содержимого регистра B. Если оно не равно нулю,
         выполняется переход на заданную  величину смещения, а если  уже
         равно нулю, то  последующий байт, задающий  смещение, игнориру-
         ется и вычисления продолжаются в естественном порядке.

                           ПОМЕЩЕНИЕ ЧИСЕЛ НА СТЕК
              Как Вы уже очевидно поняли, стек калькуллятора играет  ос-
         новополагающую роль при проведении вычислений. В этой  ситуации
         совершенно необходимо  иметь команду,  с помощью  которой можно
         было бы поместить  нужное число на  стек. Такая команда  есть -
         stk_data (код 34). Это многобайтная инструкция. После кода опе-
         рации должно идти само число, записанное в так называемой  упа-
         кованной форме.  Мы понимаем, что для начинающего читателя  уже
         надоели бесконечные описания все новых и новых форм представле-
         ния данных  в компьютере,  но ничего  не поделаешь  - таким его
         сделали создатели. Во всяком случае это последняя форма, с  ко-
         торой Вам приходится иметь  дело, Вы теперь знаете  (или можете
         знать) об этом все.
              Правила перевода чисел из пятибайтной интегральной формы в
         упакованную достаточно неоднозначны и зависят от самого  числа,
         т.е. для равных чисел  эти правила различны. Мы  приводим спра-
         вочные таблицы для выполнения такого перевода.

                     УПАКОВАННАЯ ФОРМА ЦЕЛЫХ ЧИСЕЛ ОТ 0 ДО 255.
              Если число представить в виде одного байта nn, то шестнад-
         цатиричный код для помещения его на стек:
                                34 40 В0 00 nn

                    УПАКОВАННАЯ ФОРМА ЦЕЛЫХ ЧИСЕЛ ОТ 0 ДО 65535.
              Если число представить в двухбайтной форме mm, nn, то код
         для помещения его на стек:
                               34 40 B0 nn mm

             УПАКОВАННАЯ ФОРМА ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЕЛ ОТ -65535 ДО -1
              Если  представить  в  двухбайтной  дополнительной двоичной
+                                  - 81 -

         форме -1 как FFFF; -2 как FFFE и т.д., то код:
                              34 80 B0 FF nn mm
              Если Вам трудно сразу вычислить шестнадцатиричный код  от-
         рицательного числа, то Вы можете делать так: прибавить к  отри-
         цательному числу 65535,  затем результат переписать  в шестнад-
         цатиричной форме.

                        ПОМЕЩЕНИЕ НА СТЕК ПУСТОГО СТРИНГА
              Для этого можно  обойтись без команды  stk_data соответст-
         венно, без упакованной  формы. Калькулятор имеет  команду const
         zero (код  А0), которая  помещает на  стек целое  число 0.  Это
         эквивалент пустого стринга (хотя обратное утверждение  справед-
         ливо вовсе не всегда).

              УПАКОВАННАЯ ФОРМА СТРИНГОВ ДЛИНОЙ ДО 256 БАЙТОВ
              Если текст Вашего стринга хранится, начиная с какого-то
         фиксированного адреса, например pp qq и имеет длину nn байтов,
         шестнадцатиричный код для его помещения на стек:
                                34 B0 qq pp nn

              УПАКОВАННАЯ ФОРМА СТРИНГОВ ПРОИЗВОЛЬНОЙ ДЛИНЫ
              Если адрес pp qq, а длина mm nn, то шестнадцатиричный код
                               34 B0 qq pp nn mm

                      ПРОИЗВОЛЬНЫЕ ДЕЙСТВИТЕЛЬНЫЕ ЧИСЛА
              Здесь первым  шагом является  перевод числа  в пятибайтную
         интегральную форму, с помощью которой можно представить  дейст-
         вительные числа с плавающей точкой. О том, как это делается, мы
         писали выше. Предположим, что эта форма выглядит так:
                               aa ee dd cc bb
              Здесь аа - это экспонента. Далее все зависит от ее величи-
         ны. Если она находится в диапазоне от 51 до 8F, то  упакованная
         форма определяется по таблице  5.13.6.1., а если аа  выходит из
         этого диапазона, то по таблице 5.13.6.2.
              В  первом  случае  Вам  надо  определить, какая из четырех
         представленных  в  таблице  форм  Вам  подходит  и   определить
         соответствующее ей значение  аа". Во втором случае также надо в
         зависимости от  величины мантиссы  числа подобрать  упакованную
+                                  - 82 -

         форму.
                                                     Таблица 5.13.6.1.
         --------------------------------------------------------------
           Интегральная форма    Код калькулятора     Значение аа"
         --------------------------------------------------------------
           aa ee 00 00 00        34 aa" ee               aa-50
           aa ee dd 00 00        34 aa" ee dd            aa-10
           aa ee dd cc 00        34 aa" ee dd cc         aa+30
           aa ee dd cc bb        34 aa" ee dd cc bb      aa+70
         --------------------------------------------------------------

                                                     Таблица 5.13.6.2.
         --------------------------------------------------------------
           Интегральная форма    Код калькулятора       Значение аа"
         --------------------------------------------------------------
           aa ee 00 00 00        34 00 aa" ee               aa-50
           aa ee dd 00 00        34 40 aa" ee dd            aa-50
           aa ee dd cc 00        34 80 aa" ee dd cc         aa-50
           aa ee dd cc bb        34 C0 aa" ee dd cc bb      aa+70
           ------------------------------------------------------------

                      ОБЗОР ПРОЧИХ КОМАНД КАЛЬКУЛЯТОРА
              Команда read_in предполагалась для ввода символа, поступа-
         ющего с внешнего канала через подключенный к нему поток X,  где
         X - число  на вершине стека.  Ее функция -  двойная. Во-первых,
         поток выбирается в качестве текущего, а во-вторых, производится
         ввод символа, поступающего по этому потоку. Если ввод не проис-
         ходит, то выдается пустой стринг. Функция была бы очень  полез-
         ной для чтения  символов, поступающих с  клавиатуры (аналогично
         функции БЕЙСИКа INKEY$), но в ПЗУ "Спектрума" содержится  неле-
         пая и досадная ошибка. Она проявляет себя, когда X=0 или X=1, а
         оба эти потока уже  назначены для канала "K"  (клавиатура). Эта
         ошибка ведет себя так:
              Сначала выбирается канал "К", что вызывает выключение  пя-
         того бита системной переменной FLAGS (23611), что означает "го-
         товность к приему новой клавиши". В этом и состоит ошибка,  по-
         тому что немедленно после этого выполняется попытка ввести сим-
         вол из канала "К". Это делает подпрограмма, начинающаяся в  ПЗУ
+                                 - 83 -

         с адреса  10А8. Она  проверяет пятый  бит системной  переменной
         FLAGS и немедленно выполняет возврат, если он выключен, что оз-
         начает "символ поступил". Таким  образом, INKEY$ #0 почти  обя-
         зательно выдает пустой  стринг. Единственное исключение,  очень
         маловероятное, происходит когда между выключением пятого бита и
         его проверкой  происходит системное  прерывание. Только  в этом
         случае  нажатая  клавиша  будет  прочитана.  Так очень полезная
         функция  стала  бессмысленной  из-за  наличия  в  ПЗУ  досадной
         ошибки.

              Функция get_argt (код 39) вычисляет 2/PI*ASN(SIN(X)).  Это
         довольно странная  функция по  причине своей  бесполезности для
         пользователя, но к ней обращаются некоторые системные  процеду-
         ры, "зашитые" в ПЗУ, при вычислении тригонометрических функций.

              Интересна команда "trancate" (код 3A). Она служит для  вы-
         деления целой части дробного числа. В этом смысле она несколько
         похожа на оператор БЕЙСИКа INT и команду калькулятора int  (код
         27), но  если INT  округляет дробь  всегда вниз,  то "trancate"
         отсекает дробную часть, т.е. округляет "к нулю".  Пример  срав-
         нения дан в таблице.
              ----------------------------------------------------
                        X            int X        trancate X
              ----------------------------------------------------
                      5.3              5              5
                      5.8              5              5
                     -5.3             -6             -5
                     -5.8             -6             -5
              ----------------------------------------------------
